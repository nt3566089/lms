package com.oneslogi.base.dbflute.allcommon;

import java.util.*;

import org.dbflute.exception.ClassificationNotFoundException;
import org.dbflute.jdbc.Classification;
import org.dbflute.jdbc.ClassificationCodeType;
import org.dbflute.jdbc.ClassificationMeta;
import org.dbflute.jdbc.ClassificationUndefinedHandlingType;
import org.dbflute.optional.OptionalThing;
import static org.dbflute.util.DfTypeUtil.emptyStrings;

/**
 * The definition of classification.
 * @author DBFlute(AutoGenerator)
 */
public interface CDef extends Classification {

    /**
     * 処理区分マスタの処理区分CD
     */
    public enum ProcessTypeCd implements CDef {
        /** $01: 通常入荷 */
        $01("01", "$01", emptyStrings())
        ,
        /** $21: 移動 */
        $21("21", "$21", emptyStrings())
        ,
        /** $23: 調整- */
        $23("23", "$23", emptyStrings())
        ,
        /** $24: 調整+ */
        $24("24", "$24", emptyStrings())
        ,
        /** $25: 入庫格納 */
        $25("25", "$25", emptyStrings())
        ,
        /** $27: 入庫No分割 */
        $27("27", "$27", emptyStrings())
        ,
        /** $29: 強制移動 */
        $29("29", "$29", emptyStrings())
        ,
        /** $30: セット組指示 */
        $30("30", "$30", emptyStrings())
        ,
        /** $31: セット解除指示 */
        $31("31", "$31", emptyStrings())
        ,
        /** $32: 定期補充 */
        $32("32", "$32", emptyStrings())
        ,
        /** $33: 緊急補充 */
        $33("33", "$33", emptyStrings())
        ;
        private static final Map<String, ProcessTypeCd> _codeClsMap = new HashMap<String, ProcessTypeCd>();
        private static final Map<String, ProcessTypeCd> _nameClsMap = new HashMap<String, ProcessTypeCd>();
        static {
            for (ProcessTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProcessTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProcessTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProcessTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProcessTypeCd) { return OptionalThing.of((ProcessTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProcessTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProcessTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProcessTypeCd) { return (ProcessTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProcessTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProcessTypeCd> listAll() {
            return new ArrayList<ProcessTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProcessTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProcessTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProcessTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProcessTypeCd> clsList = new ArrayList<ProcessTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProcessTypeCd> groupOf(String groupName) {
            return new ArrayList<ProcessTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 検品後納品明細出力対象
     */
    public enum AfterDelivSlipOutTgt implements CDef {
        /** $1: ECお買上明細 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 納品明細 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, AfterDelivSlipOutTgt> _codeClsMap = new HashMap<String, AfterDelivSlipOutTgt>();
        private static final Map<String, AfterDelivSlipOutTgt> _nameClsMap = new HashMap<String, AfterDelivSlipOutTgt>();
        static {
            for (AfterDelivSlipOutTgt value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AfterDelivSlipOutTgt(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AfterDelivSlipOutTgt; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AfterDelivSlipOutTgt> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AfterDelivSlipOutTgt) { return OptionalThing.of((AfterDelivSlipOutTgt)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AfterDelivSlipOutTgt> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AfterDelivSlipOutTgt codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AfterDelivSlipOutTgt) { return (AfterDelivSlipOutTgt)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AfterDelivSlipOutTgt nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AfterDelivSlipOutTgt> listAll() {
            return new ArrayList<AfterDelivSlipOutTgt>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AfterDelivSlipOutTgt> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AfterDelivSlipOutTgt." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AfterDelivSlipOutTgt> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AfterDelivSlipOutTgt> clsList = new ArrayList<AfterDelivSlipOutTgt>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AfterDelivSlipOutTgt> groupOf(String groupName) {
            return new ArrayList<AfterDelivSlipOutTgt>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 検品後荷札出力フラグ
     */
    public enum AfterTagOutFlg implements CDef {
        /** $0: 出力しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: バラ出荷検品後に出力 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ケース出荷検品後に出力 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: バラ・ケース出荷検品後に出力 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, AfterTagOutFlg> _codeClsMap = new HashMap<String, AfterTagOutFlg>();
        private static final Map<String, AfterTagOutFlg> _nameClsMap = new HashMap<String, AfterTagOutFlg>();
        static {
            for (AfterTagOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AfterTagOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AfterTagOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AfterTagOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AfterTagOutFlg) { return OptionalThing.of((AfterTagOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AfterTagOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AfterTagOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AfterTagOutFlg) { return (AfterTagOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AfterTagOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AfterTagOutFlg> listAll() {
            return new ArrayList<AfterTagOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AfterTagOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AfterTagOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AfterTagOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AfterTagOutFlg> clsList = new ArrayList<AfterTagOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AfterTagOutFlg> groupOf(String groupName) {
            return new ArrayList<AfterTagOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 全数出庫フラグ
     */
    public enum AllShippingFlg implements CDef {
        /** $0: 部分出庫 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 全数出庫 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, AllShippingFlg> _codeClsMap = new HashMap<String, AllShippingFlg>();
        private static final Map<String, AllShippingFlg> _nameClsMap = new HashMap<String, AllShippingFlg>();
        static {
            for (AllShippingFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AllShippingFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AllShippingFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllShippingFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AllShippingFlg) { return OptionalThing.of((AllShippingFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllShippingFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AllShippingFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AllShippingFlg) { return (AllShippingFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AllShippingFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AllShippingFlg> listAll() {
            return new ArrayList<AllShippingFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AllShippingFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AllShippingFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AllShippingFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AllShippingFlg> clsList = new ArrayList<AllShippingFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AllShippingFlg> groupOf(String groupName) {
            return new ArrayList<AllShippingFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 引当不可フラグ表示
     */
    public enum AllcNgDisplay implements CDef {
        /** $0: 表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 非表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, AllcNgDisplay> _codeClsMap = new HashMap<String, AllcNgDisplay>();
        private static final Map<String, AllcNgDisplay> _nameClsMap = new HashMap<String, AllcNgDisplay>();
        static {
            for (AllcNgDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AllcNgDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AllcNgDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllcNgDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AllcNgDisplay) { return OptionalThing.of((AllcNgDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllcNgDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AllcNgDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AllcNgDisplay) { return (AllcNgDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AllcNgDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AllcNgDisplay> listAll() {
            return new ArrayList<AllcNgDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AllcNgDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AllcNgDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AllcNgDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AllcNgDisplay> clsList = new ArrayList<AllcNgDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AllcNgDisplay> groupOf(String groupName) {
            return new ArrayList<AllcNgDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 引当禁止フラグ
     */
    public enum AllcNgFlg implements CDef {
        /** $0: 引当可能 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 引当禁止 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, AllcNgFlg> _codeClsMap = new HashMap<String, AllcNgFlg>();
        private static final Map<String, AllcNgFlg> _nameClsMap = new HashMap<String, AllcNgFlg>();
        static {
            for (AllcNgFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AllcNgFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AllcNgFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllcNgFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AllcNgFlg) { return OptionalThing.of((AllcNgFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllcNgFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AllcNgFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AllcNgFlg) { return (AllcNgFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AllcNgFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AllcNgFlg> listAll() {
            return new ArrayList<AllcNgFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AllcNgFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AllcNgFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AllcNgFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AllcNgFlg> clsList = new ArrayList<AllcNgFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AllcNgFlg> groupOf(String groupName) {
            return new ArrayList<AllcNgFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 引当ソートキー
     */
    public enum AllocSortKey implements CDef {
        /** $lot: ロット */
        $lot("lot", "$lot", emptyStrings())
        ,
        /** $lotOrder: ロットソート順 */
        $lotOrder("lotOrder", "$lotOrder", emptyStrings())
        ,
        /** $limitDt: 期限日 */
        $limitDt("limitDt", "$limitDt", emptyStrings())
        ,
        /** $zoneCd: ゾーンCD */
        $zoneCd("zoneCd", "$zoneCd", emptyStrings())
        ,
        /** $locationCd: ロケーションCD */
        $locationCd("locationCd", "$locationCd", emptyStrings())
        ,
        /** $locationOrder: ロケーション引当順序 */
        $locationOrder("locationOrder", "$locationOrder", emptyStrings())
        ,
        /** $storeLabelNo: 入庫ラベルNo. */
        $storeLabelNo("storeLabelNo", "$storeLabelNo", emptyStrings())
        ,
        /** $storeDt: 入庫日 */
        $storeDt("storeDt", "$storeDt", emptyStrings())
        ;
        private static final Map<String, AllocSortKey> _codeClsMap = new HashMap<String, AllocSortKey>();
        private static final Map<String, AllocSortKey> _nameClsMap = new HashMap<String, AllocSortKey>();
        static {
            for (AllocSortKey value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AllocSortKey(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AllocSortKey; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllocSortKey> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AllocSortKey) { return OptionalThing.of((AllocSortKey)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AllocSortKey> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AllocSortKey codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AllocSortKey) { return (AllocSortKey)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AllocSortKey nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AllocSortKey> listAll() {
            return new ArrayList<AllocSortKey>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AllocSortKey> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AllocSortKey." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AllocSortKey> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AllocSortKey> clsList = new ArrayList<AllocSortKey>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AllocSortKey> groupOf(String groupName) {
            return new ArrayList<AllocSortKey>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 着店CDフォーマット
     */
    public enum ArrivalStoreFormat implements CDef {
        /** $YMTFMT: ヤマト用変換フォーマット */
        $YMTFMT("YMTFMT", "$YMTFMT", emptyStrings())
        ,
        /** $YUPKFMT: ゆうパック用変換フォーマット */
        $YUPKFMT("YUPKFMT", "$YUPKFMT", emptyStrings())
        ;
        private static final Map<String, ArrivalStoreFormat> _codeClsMap = new HashMap<String, ArrivalStoreFormat>();
        private static final Map<String, ArrivalStoreFormat> _nameClsMap = new HashMap<String, ArrivalStoreFormat>();
        static {
            for (ArrivalStoreFormat value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ArrivalStoreFormat(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ArrivalStoreFormat; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ArrivalStoreFormat> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ArrivalStoreFormat) { return OptionalThing.of((ArrivalStoreFormat)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ArrivalStoreFormat> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ArrivalStoreFormat codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ArrivalStoreFormat) { return (ArrivalStoreFormat)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ArrivalStoreFormat nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ArrivalStoreFormat> listAll() {
            return new ArrayList<ArrivalStoreFormat>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ArrivalStoreFormat> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ArrivalStoreFormat." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ArrivalStoreFormat> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ArrivalStoreFormat> clsList = new ArrayList<ArrivalStoreFormat>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ArrivalStoreFormat> groupOf(String groupName) {
            return new ArrayList<ArrivalStoreFormat>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 自動緊急フラグ設定フラグ
     */
    public enum AutoEmgSetFlg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, AutoEmgSetFlg> _codeClsMap = new HashMap<String, AutoEmgSetFlg>();
        private static final Map<String, AutoEmgSetFlg> _nameClsMap = new HashMap<String, AutoEmgSetFlg>();
        static {
            for (AutoEmgSetFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AutoEmgSetFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AutoEmgSetFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoEmgSetFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AutoEmgSetFlg) { return OptionalThing.of((AutoEmgSetFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoEmgSetFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AutoEmgSetFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AutoEmgSetFlg) { return (AutoEmgSetFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AutoEmgSetFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AutoEmgSetFlg> listAll() {
            return new ArrayList<AutoEmgSetFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AutoEmgSetFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AutoEmgSetFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AutoEmgSetFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AutoEmgSetFlg> clsList = new ArrayList<AutoEmgSetFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AutoEmgSetFlg> groupOf(String groupName) {
            return new ArrayList<AutoEmgSetFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 自動緊急フラグ判断対象
     */
    public enum AutoEmgSetTgt implements CDef {
        /** $1: 積込予定時刻 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 出荷予定時刻 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, AutoEmgSetTgt> _codeClsMap = new HashMap<String, AutoEmgSetTgt>();
        private static final Map<String, AutoEmgSetTgt> _nameClsMap = new HashMap<String, AutoEmgSetTgt>();
        static {
            for (AutoEmgSetTgt value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AutoEmgSetTgt(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AutoEmgSetTgt; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoEmgSetTgt> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AutoEmgSetTgt) { return OptionalThing.of((AutoEmgSetTgt)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoEmgSetTgt> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AutoEmgSetTgt codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AutoEmgSetTgt) { return (AutoEmgSetTgt)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AutoEmgSetTgt nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AutoEmgSetTgt> listAll() {
            return new ArrayList<AutoEmgSetTgt>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AutoEmgSetTgt> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AutoEmgSetTgt." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AutoEmgSetTgt> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AutoEmgSetTgt> clsList = new ArrayList<AutoEmgSetTgt>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AutoEmgSetTgt> groupOf(String groupName) {
            return new ArrayList<AutoEmgSetTgt>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 自動印刷対象フラグ
     */
    public enum AutoPrintTargetFlg implements CDef {
        /** $0: 自動印刷対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 自動印刷対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, AutoPrintTargetFlg> _codeClsMap = new HashMap<String, AutoPrintTargetFlg>();
        private static final Map<String, AutoPrintTargetFlg> _nameClsMap = new HashMap<String, AutoPrintTargetFlg>();
        static {
            for (AutoPrintTargetFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AutoPrintTargetFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AutoPrintTargetFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoPrintTargetFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AutoPrintTargetFlg) { return OptionalThing.of((AutoPrintTargetFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoPrintTargetFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AutoPrintTargetFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AutoPrintTargetFlg) { return (AutoPrintTargetFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AutoPrintTargetFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AutoPrintTargetFlg> listAll() {
            return new ArrayList<AutoPrintTargetFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AutoPrintTargetFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AutoPrintTargetFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AutoPrintTargetFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AutoPrintTargetFlg> clsList = new ArrayList<AutoPrintTargetFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AutoPrintTargetFlg> groupOf(String groupName) {
            return new ArrayList<AutoPrintTargetFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 自動出庫指示フラグ
     */
    public enum AutoShipInstFlg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, AutoShipInstFlg> _codeClsMap = new HashMap<String, AutoShipInstFlg>();
        private static final Map<String, AutoShipInstFlg> _nameClsMap = new HashMap<String, AutoShipInstFlg>();
        static {
            for (AutoShipInstFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AutoShipInstFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AutoShipInstFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoShipInstFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AutoShipInstFlg) { return OptionalThing.of((AutoShipInstFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AutoShipInstFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AutoShipInstFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AutoShipInstFlg) { return (AutoShipInstFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AutoShipInstFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AutoShipInstFlg> listAll() {
            return new ArrayList<AutoShipInstFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AutoShipInstFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AutoShipInstFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AutoShipInstFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AutoShipInstFlg> clsList = new ArrayList<AutoShipInstFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AutoShipInstFlg> groupOf(String groupName) {
            return new ArrayList<AutoShipInstFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * バーコード種別
     */
    public enum BarcodeType implements CDef {
        /** $CODE39: CODE39 */
        $CODE39("CODE39", "$CODE39", emptyStrings())
        ,
        /** $CODE128: CODE128 */
        $CODE128("CODE128", "$CODE128", emptyStrings())
        ,
        /** $CODABAR: CODABAR(NW-7) */
        $CODABAR("CODABAR", "$CODABAR", emptyStrings())
        ,
        /** $JAN: JAN(8or13) */
        $JAN("JAN", "$JAN", emptyStrings())
        ,
        /** $ITF: ITF */
        $ITF("ITF", "$ITF", emptyStrings())
        ;
        private static final Map<String, BarcodeType> _codeClsMap = new HashMap<String, BarcodeType>();
        private static final Map<String, BarcodeType> _nameClsMap = new HashMap<String, BarcodeType>();
        static {
            for (BarcodeType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private BarcodeType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.BarcodeType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BarcodeType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof BarcodeType) { return OptionalThing.of((BarcodeType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BarcodeType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static BarcodeType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof BarcodeType) { return (BarcodeType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static BarcodeType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<BarcodeType> listAll() {
            return new ArrayList<BarcodeType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<BarcodeType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: BarcodeType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<BarcodeType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<BarcodeType> clsList = new ArrayList<BarcodeType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<BarcodeType> groupOf(String groupName) {
            return new ArrayList<BarcodeType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * バッチ処理中フラグ
     */
    public enum BatchProgressFlg implements CDef {
        /** $1: 処理中 */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: 非処理中 */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, BatchProgressFlg> _codeClsMap = new HashMap<String, BatchProgressFlg>();
        private static final Map<String, BatchProgressFlg> _nameClsMap = new HashMap<String, BatchProgressFlg>();
        static {
            for (BatchProgressFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private BatchProgressFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.BatchProgressFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BatchProgressFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof BatchProgressFlg) { return OptionalThing.of((BatchProgressFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BatchProgressFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static BatchProgressFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof BatchProgressFlg) { return (BatchProgressFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static BatchProgressFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<BatchProgressFlg> listAll() {
            return new ArrayList<BatchProgressFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<BatchProgressFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: BatchProgressFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<BatchProgressFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<BatchProgressFlg> clsList = new ArrayList<BatchProgressFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<BatchProgressFlg> groupOf(String groupName) {
            return new ArrayList<BatchProgressFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 荷材選択スキップ
     */
    public enum BoxSelectSkip implements CDef {
        /** $0: スキップしない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: スキップする */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, BoxSelectSkip> _codeClsMap = new HashMap<String, BoxSelectSkip>();
        private static final Map<String, BoxSelectSkip> _nameClsMap = new HashMap<String, BoxSelectSkip>();
        static {
            for (BoxSelectSkip value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private BoxSelectSkip(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.BoxSelectSkip; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BoxSelectSkip> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof BoxSelectSkip) { return OptionalThing.of((BoxSelectSkip)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BoxSelectSkip> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static BoxSelectSkip codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof BoxSelectSkip) { return (BoxSelectSkip)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static BoxSelectSkip nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<BoxSelectSkip> listAll() {
            return new ArrayList<BoxSelectSkip>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<BoxSelectSkip> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: BoxSelectSkip." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<BoxSelectSkip> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<BoxSelectSkip> clsList = new ArrayList<BoxSelectSkip>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<BoxSelectSkip> groupOf(String groupName) {
            return new ArrayList<BoxSelectSkip>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * キャンセルデータ表示
     */
    public enum CancelDataDisplay implements CDef {
        /** $0: 表示しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 全件表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CancelDataDisplay> _codeClsMap = new HashMap<String, CancelDataDisplay>();
        private static final Map<String, CancelDataDisplay> _nameClsMap = new HashMap<String, CancelDataDisplay>();
        static {
            for (CancelDataDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CancelDataDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CancelDataDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CancelDataDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CancelDataDisplay) { return OptionalThing.of((CancelDataDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CancelDataDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CancelDataDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CancelDataDisplay) { return (CancelDataDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CancelDataDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CancelDataDisplay> listAll() {
            return new ArrayList<CancelDataDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CancelDataDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CancelDataDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CancelDataDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CancelDataDisplay> clsList = new ArrayList<CancelDataDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CancelDataDisplay> groupOf(String groupName) {
            return new ArrayList<CancelDataDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ケースピッキングフラグ
     */
    public enum CasePicFlg implements CDef {
        /** $0: ケースピック無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ケースピック有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CasePicFlg> _codeClsMap = new HashMap<String, CasePicFlg>();
        private static final Map<String, CasePicFlg> _nameClsMap = new HashMap<String, CasePicFlg>();
        static {
            for (CasePicFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CasePicFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CasePicFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CasePicFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CasePicFlg) { return OptionalThing.of((CasePicFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CasePicFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CasePicFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CasePicFlg) { return (CasePicFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CasePicFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CasePicFlg> listAll() {
            return new ArrayList<CasePicFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CasePicFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CasePicFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CasePicFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CasePicFlg> clsList = new ArrayList<CasePicFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CasePicFlg> groupOf(String groupName) {
            return new ArrayList<CasePicFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * センタ・荷主区分
     */
    public enum CenterClientCls implements CDef {
        /** $1: センタ */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 荷主 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, CenterClientCls> _codeClsMap = new HashMap<String, CenterClientCls>();
        private static final Map<String, CenterClientCls> _nameClsMap = new HashMap<String, CenterClientCls>();
        static {
            for (CenterClientCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterClientCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterClientCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterClientCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterClientCls) { return OptionalThing.of((CenterClientCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterClientCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterClientCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterClientCls) { return (CenterClientCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterClientCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterClientCls> listAll() {
            return new ArrayList<CenterClientCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterClientCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterClientCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterClientCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterClientCls> clsList = new ArrayList<CenterClientCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterClientCls> groupOf(String groupName) {
            return new ArrayList<CenterClientCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * センタ間移動フラグ
     */
    public enum CenterTransitFlg implements CDef {
        /** $0: 通常 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: センタ間移動 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CenterTransitFlg> _codeClsMap = new HashMap<String, CenterTransitFlg>();
        private static final Map<String, CenterTransitFlg> _nameClsMap = new HashMap<String, CenterTransitFlg>();
        static {
            for (CenterTransitFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterTransitFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterTransitFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTransitFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterTransitFlg) { return OptionalThing.of((CenterTransitFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTransitFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterTransitFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterTransitFlg) { return (CenterTransitFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterTransitFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterTransitFlg> listAll() {
            return new ArrayList<CenterTransitFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterTransitFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterTransitFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterTransitFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterTransitFlg> clsList = new ArrayList<CenterTransitFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterTransitFlg> groupOf(String groupName) {
            return new ArrayList<CenterTransitFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 文字コード
     */
    public enum CharacterCd implements CDef {
        /** $MS932: MS932 */
        $MS932("MS932", "$MS932", emptyStrings())
        ,
        /** $UTF8: UTF8 */
        $UTF8("UTF8", "$UTF8", emptyStrings())
        ;
        private static final Map<String, CharacterCd> _codeClsMap = new HashMap<String, CharacterCd>();
        private static final Map<String, CharacterCd> _nameClsMap = new HashMap<String, CharacterCd>();
        static {
            for (CharacterCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CharacterCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CharacterCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CharacterCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CharacterCd) { return OptionalThing.of((CharacterCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CharacterCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CharacterCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CharacterCd) { return (CharacterCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CharacterCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CharacterCd> listAll() {
            return new ArrayList<CharacterCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CharacterCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CharacterCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CharacterCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CharacterCd> clsList = new ArrayList<CharacterCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CharacterCd> groupOf(String groupName) {
            return new ArrayList<CharacterCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 引当可能数0非表示
     */
    public enum ChargeQty0Display implements CDef {
        /** $0: 0表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 0非表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ChargeQty0Display> _codeClsMap = new HashMap<String, ChargeQty0Display>();
        private static final Map<String, ChargeQty0Display> _nameClsMap = new HashMap<String, ChargeQty0Display>();
        static {
            for (ChargeQty0Display value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ChargeQty0Display(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ChargeQty0Display; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ChargeQty0Display> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ChargeQty0Display) { return OptionalThing.of((ChargeQty0Display)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ChargeQty0Display> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ChargeQty0Display codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ChargeQty0Display) { return (ChargeQty0Display)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ChargeQty0Display nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ChargeQty0Display> listAll() {
            return new ArrayList<ChargeQty0Display>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ChargeQty0Display> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ChargeQty0Display." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ChargeQty0Display> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ChargeQty0Display> clsList = new ArrayList<ChargeQty0Display>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ChargeQty0Display> groupOf(String groupName) {
            return new ArrayList<ChargeQty0Display>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * チェックディジット
     */
    public enum CheckDigit implements CDef {
        /** $0: チェックディジット無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $7: 7DR方式 */
        $7("7", "$7", emptyStrings())
        ;
        private static final Map<String, CheckDigit> _codeClsMap = new HashMap<String, CheckDigit>();
        private static final Map<String, CheckDigit> _nameClsMap = new HashMap<String, CheckDigit>();
        static {
            for (CheckDigit value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CheckDigit(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CheckDigit; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CheckDigit> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CheckDigit) { return OptionalThing.of((CheckDigit)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CheckDigit> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CheckDigit codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CheckDigit) { return (CheckDigit)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CheckDigit nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CheckDigit> listAll() {
            return new ArrayList<CheckDigit>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CheckDigit> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CheckDigit." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CheckDigit> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CheckDigit> clsList = new ArrayList<CheckDigit>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CheckDigit> groupOf(String groupName) {
            return new ArrayList<CheckDigit>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 元着区分
     */
    public enum CodCls implements CDef {
        /** $1: 元払 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 着払 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, CodCls> _codeClsMap = new HashMap<String, CodCls>();
        private static final Map<String, CodCls> _nameClsMap = new HashMap<String, CodCls>();
        static {
            for (CodCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CodCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CodCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CodCls) { return OptionalThing.of((CodCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CodCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CodCls) { return (CodCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CodCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CodCls> listAll() {
            return new ArrayList<CodCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CodCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CodCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CodCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CodCls> clsList = new ArrayList<CodCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CodCls> groupOf(String groupName) {
            return new ArrayList<CodCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 元／着払／代引文字
     */
    public enum CodType implements CDef {
        /** $0: 元払 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 着払 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 代引 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, CodType> _codeClsMap = new HashMap<String, CodType>();
        private static final Map<String, CodType> _nameClsMap = new HashMap<String, CodType>();
        static {
            for (CodType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CodType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CodType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CodType) { return OptionalThing.of((CodType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CodType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CodType) { return (CodType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CodType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CodType> listAll() {
            return new ArrayList<CodType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CodType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CodType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CodType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CodType> clsList = new ArrayList<CodType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CodType> groupOf(String groupName) {
            return new ArrayList<CodType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 複数番号の有無
     */
    public enum CodeFlg implements CDef {
        /** $0: 複数番号無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 複数番号有(個別番号の1) */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 複数番号有(個別番号の2) */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 複数番号有(個別番号の3) */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, CodeFlg> _codeClsMap = new HashMap<String, CodeFlg>();
        private static final Map<String, CodeFlg> _nameClsMap = new HashMap<String, CodeFlg>();
        static {
            for (CodeFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CodeFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CodeFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodeFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CodeFlg) { return OptionalThing.of((CodeFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodeFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CodeFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CodeFlg) { return (CodeFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CodeFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CodeFlg> listAll() {
            return new ArrayList<CodeFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CodeFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CodeFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CodeFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CodeFlg> clsList = new ArrayList<CodeFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CodeFlg> groupOf(String groupName) {
            return new ArrayList<CodeFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 個別番号の種別
     */
    public enum CodeType implements CDef {
        /** $0: 大口事業所 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 私書箱 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CodeType> _codeClsMap = new HashMap<String, CodeType>();
        private static final Map<String, CodeType> _nameClsMap = new HashMap<String, CodeType>();
        static {
            for (CodeType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CodeType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CodeType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodeType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CodeType) { return OptionalThing.of((CodeType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodeType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CodeType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CodeType) { return (CodeType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CodeType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CodeType> listAll() {
            return new ArrayList<CodeType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CodeType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CodeType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CodeType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CodeType> clsList = new ArrayList<CodeType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CodeType> groupOf(String groupName) {
            return new ArrayList<CodeType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 列型
     */
    public enum ColType implements CDef {
        /** $text: テキスト */
        $text("text", "$text", emptyStrings())
        ,
        /** $number: 数値 */
        $number("number", "$number", emptyStrings())
        ,
        /** $date: 日付 */
        $date("date", "$date", emptyStrings())
        ,
        /** $datetime: 日時 */
        $datetime("datetime", "$datetime", emptyStrings())
        ,
        /** $dropdown: コンボボックス */
        $dropdown("dropdown", "$dropdown", emptyStrings())
        ,
        /** $checkbox: チェックボックス */
        $checkbox("checkbox", "$checkbox", emptyStrings())
        ,
        /** $calcnumber: 計算数値 */
        $calcnumber("calcnumber", "$calcnumber", emptyStrings())
        ;
        private static final Map<String, ColType> _codeClsMap = new HashMap<String, ColType>();
        private static final Map<String, ColType> _nameClsMap = new HashMap<String, ColType>();
        static {
            for (ColType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ColType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ColType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ColType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ColType) { return OptionalThing.of((ColType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ColType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ColType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ColType) { return (ColType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ColType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ColType> listAll() {
            return new ArrayList<ColType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ColType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ColType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ColType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ColType> clsList = new ArrayList<ColType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ColType> groupOf(String groupName) {
            return new ArrayList<ColType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * コメント1有無
     */
    public enum CommentFlg implements CDef {
        /** $0: コメント1無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: コメント1有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CommentFlg> _codeClsMap = new HashMap<String, CommentFlg>();
        private static final Map<String, CommentFlg> _nameClsMap = new HashMap<String, CommentFlg>();
        static {
            for (CommentFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CommentFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CommentFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CommentFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CommentFlg) { return OptionalThing.of((CommentFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CommentFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CommentFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CommentFlg) { return (CommentFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CommentFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CommentFlg> listAll() {
            return new ArrayList<CommentFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CommentFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CommentFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CommentFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CommentFlg> clsList = new ArrayList<CommentFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CommentFlg> groupOf(String groupName) {
            return new ArrayList<CommentFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 大口事業所フラグ
     */
    public enum CompanyFlg implements CDef {
        /** $0: 通常郵便番号 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 大口事業所 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CompanyFlg> _codeClsMap = new HashMap<String, CompanyFlg>();
        private static final Map<String, CompanyFlg> _nameClsMap = new HashMap<String, CompanyFlg>();
        static {
            for (CompanyFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CompanyFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CompanyFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CompanyFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CompanyFlg) { return OptionalThing.of((CompanyFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CompanyFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CompanyFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CompanyFlg) { return (CompanyFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CompanyFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CompanyFlg> listAll() {
            return new ArrayList<CompanyFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CompanyFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CompanyFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CompanyFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CompanyFlg> clsList = new ArrayList<CompanyFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CompanyFlg> groupOf(String groupName) {
            return new ArrayList<CompanyFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * クール区分
     */
    public enum CoolCls implements CDef {
        /** $0: 通常 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: クール冷凍 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: クール冷蔵 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, CoolCls> _codeClsMap = new HashMap<String, CoolCls>();
        private static final Map<String, CoolCls> _nameClsMap = new HashMap<String, CoolCls>();
        static {
            for (CoolCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CoolCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CoolCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CoolCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CoolCls) { return OptionalThing.of((CoolCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CoolCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CoolCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CoolCls) { return (CoolCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CoolCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CoolCls> listAll() {
            return new ArrayList<CoolCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CoolCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CoolCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CoolCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CoolCls> clsList = new ArrayList<CoolCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CoolCls> groupOf(String groupName) {
            return new ArrayList<CoolCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 保冷種別
     */
    public enum CoolType implements CDef {
        /** $0: 保冷なし */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: チルド */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 冷凍 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, CoolType> _codeClsMap = new HashMap<String, CoolType>();
        private static final Map<String, CoolType> _nameClsMap = new HashMap<String, CoolType>();
        static {
            for (CoolType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CoolType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CoolType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CoolType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CoolType) { return OptionalThing.of((CoolType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CoolType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CoolType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CoolType) { return (CoolType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CoolType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CoolType> listAll() {
            return new ArrayList<CoolType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CoolType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CoolType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CoolType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CoolType> clsList = new ArrayList<CoolType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CoolType> groupOf(String groupName) {
            return new ArrayList<CoolType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 赤黒区分
     */
    public enum CorrectType implements CDef {
        /** $0: 黒 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 赤 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CorrectType> _codeClsMap = new HashMap<String, CorrectType>();
        private static final Map<String, CorrectType> _nameClsMap = new HashMap<String, CorrectType>();
        static {
            for (CorrectType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CorrectType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CorrectType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CorrectType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CorrectType) { return OptionalThing.of((CorrectType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CorrectType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CorrectType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CorrectType) { return (CorrectType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CorrectType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CorrectType> listAll() {
            return new ArrayList<CorrectType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CorrectType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CorrectType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CorrectType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CorrectType> clsList = new ArrayList<CorrectType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CorrectType> groupOf(String groupName) {
            return new ArrayList<CorrectType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * コミット区分
     */
    public enum DataInputCommitType implements CDef {
        /** $0: 一括コミット */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 随時コミット */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DataInputCommitType> _codeClsMap = new HashMap<String, DataInputCommitType>();
        private static final Map<String, DataInputCommitType> _nameClsMap = new HashMap<String, DataInputCommitType>();
        static {
            for (DataInputCommitType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DataInputCommitType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DataInputCommitType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputCommitType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DataInputCommitType) { return OptionalThing.of((DataInputCommitType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputCommitType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DataInputCommitType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DataInputCommitType) { return (DataInputCommitType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DataInputCommitType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DataInputCommitType> listAll() {
            return new ArrayList<DataInputCommitType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DataInputCommitType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DataInputCommitType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DataInputCommitType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DataInputCommitType> clsList = new ArrayList<DataInputCommitType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DataInputCommitType> groupOf(String groupName) {
            return new ArrayList<DataInputCommitType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 処理区分
     */
    public enum DataInputOperationType implements CDef {
        /** $0: アップロード */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ワーク取込 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: データ移行 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: ダウンロード */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, DataInputOperationType> _codeClsMap = new HashMap<String, DataInputOperationType>();
        private static final Map<String, DataInputOperationType> _nameClsMap = new HashMap<String, DataInputOperationType>();
        static {
            for (DataInputOperationType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DataInputOperationType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DataInputOperationType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputOperationType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DataInputOperationType) { return OptionalThing.of((DataInputOperationType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputOperationType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DataInputOperationType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DataInputOperationType) { return (DataInputOperationType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DataInputOperationType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DataInputOperationType> listAll() {
            return new ArrayList<DataInputOperationType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DataInputOperationType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DataInputOperationType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DataInputOperationType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DataInputOperationType> clsList = new ArrayList<DataInputOperationType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DataInputOperationType> groupOf(String groupName) {
            return new ArrayList<DataInputOperationType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 処理区分
     */
    public enum DataInputProcessType implements CDef {
        /** $0: 追記のみ */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 全削除後追記 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DataInputProcessType> _codeClsMap = new HashMap<String, DataInputProcessType>();
        private static final Map<String, DataInputProcessType> _nameClsMap = new HashMap<String, DataInputProcessType>();
        static {
            for (DataInputProcessType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DataInputProcessType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DataInputProcessType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputProcessType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DataInputProcessType) { return OptionalThing.of((DataInputProcessType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputProcessType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DataInputProcessType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DataInputProcessType) { return (DataInputProcessType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DataInputProcessType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DataInputProcessType> listAll() {
            return new ArrayList<DataInputProcessType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DataInputProcessType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DataInputProcessType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DataInputProcessType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DataInputProcessType> clsList = new ArrayList<DataInputProcessType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DataInputProcessType> groupOf(String groupName) {
            return new ArrayList<DataInputProcessType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 取込対象
     */
    public enum DataInputRange implements CDef {
        /** $0: 全件 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 未処理のみ */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: エラーのみ */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, DataInputRange> _codeClsMap = new HashMap<String, DataInputRange>();
        private static final Map<String, DataInputRange> _nameClsMap = new HashMap<String, DataInputRange>();
        static {
            for (DataInputRange value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DataInputRange(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DataInputRange; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputRange> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DataInputRange) { return OptionalThing.of((DataInputRange)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputRange> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DataInputRange codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DataInputRange) { return (DataInputRange)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DataInputRange nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DataInputRange> listAll() {
            return new ArrayList<DataInputRange>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DataInputRange> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DataInputRange." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DataInputRange> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DataInputRange> clsList = new ArrayList<DataInputRange>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DataInputRange> groupOf(String groupName) {
            return new ArrayList<DataInputRange>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 取込種類
     */
    public enum DataInputType implements CDef {
        /** $01: 商品マスタ取込 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 商品荷姿マスタ取込 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 取引先マスタ取込 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: ロケーションマスタ取込 */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: 在庫データ取込 */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: 着店マスタ取込(ヤマト運輸) */
        $06("06", "$06", emptyStrings())
        ,
        /** $07: 着店マスタ取込(日本郵政) */
        $07("07", "$07", emptyStrings())
        ,
        /** $08: 郵便番号マスタ取込 */
        $08("08", "$08", emptyStrings())
        ,
        /** $09: 郵便番号マスタ(大口事業所)取込 */
        $09("09", "$09", emptyStrings())
        ;
        private static final Map<String, DataInputType> _codeClsMap = new HashMap<String, DataInputType>();
        private static final Map<String, DataInputType> _nameClsMap = new HashMap<String, DataInputType>();
        static {
            for (DataInputType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DataInputType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DataInputType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DataInputType) { return OptionalThing.of((DataInputType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataInputType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DataInputType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DataInputType) { return (DataInputType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DataInputType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DataInputType> listAll() {
            return new ArrayList<DataInputType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DataInputType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DataInputType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DataInputType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DataInputType> clsList = new ArrayList<DataInputType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DataInputType> groupOf(String groupName) {
            return new ArrayList<DataInputType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * データ型
     */
    public enum DataType implements CDef {
        /** $text: テキスト */
        $text("text", "$text", emptyStrings())
        ,
        /** $number: 数値 */
        $number("number", "$number", emptyStrings())
        ,
        /** $date: 日付 */
        $date("date", "$date", emptyStrings())
        ,
        /** $datetime: 日時 */
        $datetime("datetime", "$datetime", emptyStrings())
        ,
        /** $time: 時刻 */
        $time("time", "$time", emptyStrings())
        ;
        private static final Map<String, DataType> _codeClsMap = new HashMap<String, DataType>();
        private static final Map<String, DataType> _nameClsMap = new HashMap<String, DataType>();
        static {
            for (DataType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DataType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DataType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DataType) { return OptionalThing.of((DataType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DataType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DataType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DataType) { return (DataType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DataType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DataType> listAll() {
            return new ArrayList<DataType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DataType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DataType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DataType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DataType> clsList = new ArrayList<DataType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DataType> groupOf(String groupName) {
            return new ArrayList<DataType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * デフォルト
     */
    public enum Default implements CDef {
        /** $0: デフォルトでない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: デフォルト */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Default> _codeClsMap = new HashMap<String, Default>();
        private static final Map<String, Default> _nameClsMap = new HashMap<String, Default>();
        static {
            for (Default value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Default(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Default; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Default> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Default) { return OptionalThing.of((Default)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Default> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Default codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Default) { return (Default)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Default nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Default> listAll() {
            return new ArrayList<Default>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Default> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Default." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Default> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Default> clsList = new ArrayList<Default>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Default> groupOf(String groupName) {
            return new ArrayList<Default>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * デフォルトフラグ
     */
    public enum DefaultFlg implements CDef {
        /** $0: デフォルトでない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: デフォルト */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DefaultFlg> _codeClsMap = new HashMap<String, DefaultFlg>();
        private static final Map<String, DefaultFlg> _nameClsMap = new HashMap<String, DefaultFlg>();
        static {
            for (DefaultFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DefaultFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DefaultFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DefaultFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DefaultFlg) { return OptionalThing.of((DefaultFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DefaultFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DefaultFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DefaultFlg) { return (DefaultFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DefaultFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DefaultFlg> listAll() {
            return new ArrayList<DefaultFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DefaultFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DefaultFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DefaultFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DefaultFlg> clsList = new ArrayList<DefaultFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DefaultFlg> groupOf(String groupName) {
            return new ArrayList<DefaultFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 削除フラグ
     */
    public enum DelFlg implements CDef {
        /** $0: 未削除 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 削除済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DelFlg> _codeClsMap = new HashMap<String, DelFlg>();
        private static final Map<String, DelFlg> _nameClsMap = new HashMap<String, DelFlg>();
        static {
            for (DelFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DelFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DelFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DelFlg) { return OptionalThing.of((DelFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DelFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DelFlg) { return (DelFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DelFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DelFlg> listAll() {
            return new ArrayList<DelFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DelFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DelFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DelFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DelFlg> clsList = new ArrayList<DelFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DelFlg> groupOf(String groupName) {
            return new ArrayList<DelFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 削除データ表示
     */
    public enum DeleteDataDisplay implements CDef {
        /** $0: 表示しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 全件表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DeleteDataDisplay> _codeClsMap = new HashMap<String, DeleteDataDisplay>();
        private static final Map<String, DeleteDataDisplay> _nameClsMap = new HashMap<String, DeleteDataDisplay>();
        static {
            for (DeleteDataDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DeleteDataDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DeleteDataDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DeleteDataDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DeleteDataDisplay) { return OptionalThing.of((DeleteDataDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DeleteDataDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DeleteDataDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DeleteDataDisplay) { return (DeleteDataDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DeleteDataDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DeleteDataDisplay> listAll() {
            return new ArrayList<DeleteDataDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DeleteDataDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DeleteDataDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DeleteDataDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DeleteDataDisplay> clsList = new ArrayList<DeleteDataDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DeleteDataDisplay> groupOf(String groupName) {
            return new ArrayList<DeleteDataDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送付先一致フラグ
     */
    public enum DelivMatchFlg implements CDef {
        /** $0: 不一致 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 一致 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DelivMatchFlg> _codeClsMap = new HashMap<String, DelivMatchFlg>();
        private static final Map<String, DelivMatchFlg> _nameClsMap = new HashMap<String, DelivMatchFlg>();
        static {
            for (DelivMatchFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DelivMatchFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DelivMatchFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelivMatchFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DelivMatchFlg) { return OptionalThing.of((DelivMatchFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelivMatchFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DelivMatchFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DelivMatchFlg) { return (DelivMatchFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DelivMatchFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DelivMatchFlg> listAll() {
            return new ArrayList<DelivMatchFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DelivMatchFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DelivMatchFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DelivMatchFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DelivMatchFlg> clsList = new ArrayList<DelivMatchFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DelivMatchFlg> groupOf(String groupName) {
            return new ArrayList<DelivMatchFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 納品時間帯
     */
    public enum DelivTz implements CDef {
        /** $A: 午前中 */
        $A("A", "$A", emptyStrings())
        ,
        /** $B: 12時～14時 */
        $B("B", "$B", emptyStrings())
        ,
        /** $C: 14時～16時 */
        $C("C", "$C", emptyStrings())
        ,
        /** $D: 16時～18時 */
        $D("D", "$D", emptyStrings())
        ,
        /** $E: 18時～20時 */
        $E("E", "$E", emptyStrings())
        ,
        /** $F: 18時～21時 */
        $F("F", "$F", emptyStrings())
        ,
        /** $G: 19時～21時 */
        $G("G", "$G", emptyStrings())
        ,
        /** $H: 20時～21時 */
        $H("H", "$H", emptyStrings())
        ,
        /** $I: 午前10時まで */
        $I("I", "$I", emptyStrings())
        ,
        /** $J: 午後5時まで */
        $J("J", "$J", emptyStrings())
        ;
        private static final Map<String, DelivTz> _codeClsMap = new HashMap<String, DelivTz>();
        private static final Map<String, DelivTz> _nameClsMap = new HashMap<String, DelivTz>();
        static {
            for (DelivTz value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DelivTz(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DelivTz; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelivTz> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DelivTz) { return OptionalThing.of((DelivTz)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelivTz> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DelivTz codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DelivTz) { return (DelivTz)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DelivTz nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DelivTz> listAll() {
            return new ArrayList<DelivTz>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DelivTz> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DelivTz." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DelivTz> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DelivTz> clsList = new ArrayList<DelivTz>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DelivTz> groupOf(String groupName) {
            return new ArrayList<DelivTz>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 納品先フラグ
     */
    public enum DeliveryFlg implements CDef {
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, DeliveryFlg> _codeClsMap = new HashMap<String, DeliveryFlg>();
        private static final Map<String, DeliveryFlg> _nameClsMap = new HashMap<String, DeliveryFlg>();
        static {
            for (DeliveryFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DeliveryFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DeliveryFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DeliveryFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DeliveryFlg) { return OptionalThing.of((DeliveryFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DeliveryFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DeliveryFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DeliveryFlg) { return (DeliveryFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DeliveryFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DeliveryFlg> listAll() {
            return new ArrayList<DeliveryFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DeliveryFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DeliveryFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DeliveryFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DeliveryFlg> clsList = new ArrayList<DeliveryFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DeliveryFlg> groupOf(String groupName) {
            return new ArrayList<DeliveryFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 預託先フラグ
     */
    public enum DepositFlg implements CDef {
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, DepositFlg> _codeClsMap = new HashMap<String, DepositFlg>();
        private static final Map<String, DepositFlg> _nameClsMap = new HashMap<String, DepositFlg>();
        static {
            for (DepositFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DepositFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DepositFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DepositFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DepositFlg) { return OptionalThing.of((DepositFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DepositFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DepositFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DepositFlg) { return (DepositFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DepositFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DepositFlg> listAll() {
            return new ArrayList<DepositFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DepositFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DepositFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DepositFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DepositFlg> clsList = new ArrayList<DepositFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DepositFlg> groupOf(String groupName) {
            return new ArrayList<DepositFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 表示必須
     */
    public enum DisplayRequired implements CDef {
        /** $0: 任意 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 必須 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DisplayRequired> _codeClsMap = new HashMap<String, DisplayRequired>();
        private static final Map<String, DisplayRequired> _nameClsMap = new HashMap<String, DisplayRequired>();
        static {
            for (DisplayRequired value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DisplayRequired(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DisplayRequired; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DisplayRequired> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DisplayRequired) { return OptionalThing.of((DisplayRequired)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DisplayRequired> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DisplayRequired codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DisplayRequired) { return (DisplayRequired)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DisplayRequired nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DisplayRequired> listAll() {
            return new ArrayList<DisplayRequired>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DisplayRequired> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DisplayRequired." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DisplayRequired> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DisplayRequired> clsList = new ArrayList<DisplayRequired>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DisplayRequired> groupOf(String groupName) {
            return new ArrayList<DisplayRequired>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 日付区分
     */
    public enum DtCls implements CDef {
        /** $0: 取込日 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出荷日 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 作業日 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, DtCls> _codeClsMap = new HashMap<String, DtCls>();
        private static final Map<String, DtCls> _nameClsMap = new HashMap<String, DtCls>();
        static {
            for (DtCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DtCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DtCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DtCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DtCls) { return OptionalThing.of((DtCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DtCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DtCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DtCls) { return (DtCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DtCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DtCls> listAll() {
            return new ArrayList<DtCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DtCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DtCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DtCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DtCls> clsList = new ArrayList<DtCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DtCls> groupOf(String groupName) {
            return new ArrayList<DtCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 編集可否
     */
    public enum Editable implements CDef {
        /** $0: 編集不可 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 編集可 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Editable> _codeClsMap = new HashMap<String, Editable>();
        private static final Map<String, Editable> _nameClsMap = new HashMap<String, Editable>();
        static {
            for (Editable value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Editable(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Editable; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Editable> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Editable) { return OptionalThing.of((Editable)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Editable> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Editable codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Editable) { return (Editable)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Editable nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Editable> listAll() {
            return new ArrayList<Editable>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Editable> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Editable." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Editable> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Editable> clsList = new ArrayList<Editable>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Editable> groupOf(String groupName) {
            return new ArrayList<Editable>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 緊急表示区分
     */
    public enum EmergencyDisplay implements CDef {
        /** $0: 全件表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 緊急のみ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, EmergencyDisplay> _codeClsMap = new HashMap<String, EmergencyDisplay>();
        private static final Map<String, EmergencyDisplay> _nameClsMap = new HashMap<String, EmergencyDisplay>();
        static {
            for (EmergencyDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private EmergencyDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.EmergencyDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EmergencyDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof EmergencyDisplay) { return OptionalThing.of((EmergencyDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EmergencyDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static EmergencyDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof EmergencyDisplay) { return (EmergencyDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static EmergencyDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<EmergencyDisplay> listAll() {
            return new ArrayList<EmergencyDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<EmergencyDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: EmergencyDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<EmergencyDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<EmergencyDisplay> clsList = new ArrayList<EmergencyDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<EmergencyDisplay> groupOf(String groupName) {
            return new ArrayList<EmergencyDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 緊急フラグ
     */
    public enum EmergencyFlg implements CDef {
        /** $0: 通常 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 緊急 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, EmergencyFlg> _codeClsMap = new HashMap<String, EmergencyFlg>();
        private static final Map<String, EmergencyFlg> _nameClsMap = new HashMap<String, EmergencyFlg>();
        static {
            for (EmergencyFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private EmergencyFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.EmergencyFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EmergencyFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof EmergencyFlg) { return OptionalThing.of((EmergencyFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EmergencyFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static EmergencyFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof EmergencyFlg) { return (EmergencyFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static EmergencyFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<EmergencyFlg> listAll() {
            return new ArrayList<EmergencyFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<EmergencyFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: EmergencyFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<EmergencyFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<EmergencyFlg> clsList = new ArrayList<EmergencyFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<EmergencyFlg> groupOf(String groupName) {
            return new ArrayList<EmergencyFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * エラーフラグ
     */
    public enum ErrorFlg implements CDef {
        /** $0: エラー無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: エラー有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ErrorFlg> _codeClsMap = new HashMap<String, ErrorFlg>();
        private static final Map<String, ErrorFlg> _nameClsMap = new HashMap<String, ErrorFlg>();
        static {
            for (ErrorFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ErrorFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ErrorFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ErrorFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ErrorFlg) { return OptionalThing.of((ErrorFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ErrorFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ErrorFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ErrorFlg) { return (ErrorFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ErrorFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ErrorFlg> listAll() {
            return new ArrayList<ErrorFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ErrorFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ErrorFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ErrorFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ErrorFlg> clsList = new ArrayList<ErrorFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ErrorFlg> groupOf(String groupName) {
            return new ArrayList<ErrorFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * エラー処理方法
     */
    public enum ErrorProcessMet implements CDef {
        /** $0: 全て取込まない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: エラー以外を取り込む */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ErrorProcessMet> _codeClsMap = new HashMap<String, ErrorProcessMet>();
        private static final Map<String, ErrorProcessMet> _nameClsMap = new HashMap<String, ErrorProcessMet>();
        static {
            for (ErrorProcessMet value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ErrorProcessMet(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ErrorProcessMet; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ErrorProcessMet> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ErrorProcessMet) { return OptionalThing.of((ErrorProcessMet)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ErrorProcessMet> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ErrorProcessMet codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ErrorProcessMet) { return (ErrorProcessMet)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ErrorProcessMet nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ErrorProcessMet> listAll() {
            return new ArrayList<ErrorProcessMet>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ErrorProcessMet> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ErrorProcessMet." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ErrorProcessMet> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ErrorProcessMet> clsList = new ArrayList<ErrorProcessMet>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ErrorProcessMet> groupOf(String groupName) {
            return new ArrayList<ErrorProcessMet>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 定点切れ
     */
    public enum FixedPoint implements CDef {
        /** $0: 定点切れのみ表示 */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, FixedPoint> _codeClsMap = new HashMap<String, FixedPoint>();
        private static final Map<String, FixedPoint> _nameClsMap = new HashMap<String, FixedPoint>();
        static {
            for (FixedPoint value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private FixedPoint(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.FixedPoint; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FixedPoint> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof FixedPoint) { return OptionalThing.of((FixedPoint)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FixedPoint> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static FixedPoint codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof FixedPoint) { return (FixedPoint)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static FixedPoint nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<FixedPoint> listAll() {
            return new ArrayList<FixedPoint>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<FixedPoint> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: FixedPoint." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<FixedPoint> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<FixedPoint> clsList = new ArrayList<FixedPoint>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<FixedPoint> groupOf(String groupName) {
            return new ArrayList<FixedPoint>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 強制確定フラグ
     */
    public enum ForceFixedFlg implements CDef {
        /** $0: 通常確定 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 強制確定 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ForceFixedFlg> _codeClsMap = new HashMap<String, ForceFixedFlg>();
        private static final Map<String, ForceFixedFlg> _nameClsMap = new HashMap<String, ForceFixedFlg>();
        static {
            for (ForceFixedFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ForceFixedFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ForceFixedFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ForceFixedFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ForceFixedFlg) { return OptionalThing.of((ForceFixedFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ForceFixedFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ForceFixedFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ForceFixedFlg) { return (ForceFixedFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ForceFixedFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ForceFixedFlg> listAll() {
            return new ArrayList<ForceFixedFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ForceFixedFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ForceFixedFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ForceFixedFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ForceFixedFlg> clsList = new ArrayList<ForceFixedFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ForceFixedFlg> groupOf(String groupName) {
            return new ArrayList<ForceFixedFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 外貨フラグ
     */
    public enum ForeignFlg implements CDef {
        /** $0: 内貨 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 外貨 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ForeignFlg> _codeClsMap = new HashMap<String, ForeignFlg>();
        private static final Map<String, ForeignFlg> _nameClsMap = new HashMap<String, ForeignFlg>();
        static {
            for (ForeignFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ForeignFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ForeignFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ForeignFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ForeignFlg) { return OptionalThing.of((ForeignFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ForeignFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ForeignFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ForeignFlg) { return (ForeignFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ForeignFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ForeignFlg> listAll() {
            return new ArrayList<ForeignFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ForeignFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ForeignFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ForeignFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ForeignFlg> clsList = new ArrayList<ForeignFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ForeignFlg> groupOf(String groupName) {
            return new ArrayList<ForeignFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ギフトフラグ
     */
    public enum GiftFlg implements CDef {
        /** $0: ギフト指定無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ギフト指定有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, GiftFlg> _codeClsMap = new HashMap<String, GiftFlg>();
        private static final Map<String, GiftFlg> _nameClsMap = new HashMap<String, GiftFlg>();
        static {
            for (GiftFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private GiftFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.GiftFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<GiftFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof GiftFlg) { return OptionalThing.of((GiftFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<GiftFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static GiftFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof GiftFlg) { return (GiftFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static GiftFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<GiftFlg> listAll() {
            return new ArrayList<GiftFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<GiftFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: GiftFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<GiftFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<GiftFlg> clsList = new ArrayList<GiftFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<GiftFlg> groupOf(String groupName) {
            return new ArrayList<GiftFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ギフト用納品書種別
     */
    public enum GiftStatementType implements CDef {
        /** $0: 通常 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 金額非表示 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 明細非表示 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, GiftStatementType> _codeClsMap = new HashMap<String, GiftStatementType>();
        private static final Map<String, GiftStatementType> _nameClsMap = new HashMap<String, GiftStatementType>();
        static {
            for (GiftStatementType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private GiftStatementType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.GiftStatementType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<GiftStatementType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof GiftStatementType) { return OptionalThing.of((GiftStatementType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<GiftStatementType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static GiftStatementType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof GiftStatementType) { return (GiftStatementType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static GiftStatementType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<GiftStatementType> listAll() {
            return new ArrayList<GiftStatementType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<GiftStatementType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: GiftStatementType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<GiftStatementType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<GiftStatementType> clsList = new ArrayList<GiftStatementType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<GiftStatementType> groupOf(String groupName) {
            return new ArrayList<GiftStatementType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * HT文字認識使用フラグ
     */
    public enum HtCharReadFlg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, HtCharReadFlg> _codeClsMap = new HashMap<String, HtCharReadFlg>();
        private static final Map<String, HtCharReadFlg> _nameClsMap = new HashMap<String, HtCharReadFlg>();
        static {
            for (HtCharReadFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private HtCharReadFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.HtCharReadFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HtCharReadFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof HtCharReadFlg) { return OptionalThing.of((HtCharReadFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HtCharReadFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static HtCharReadFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof HtCharReadFlg) { return (HtCharReadFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static HtCharReadFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<HtCharReadFlg> listAll() {
            return new ArrayList<HtCharReadFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<HtCharReadFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: HtCharReadFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<HtCharReadFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<HtCharReadFlg> clsList = new ArrayList<HtCharReadFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<HtCharReadFlg> groupOf(String groupName) {
            return new ArrayList<HtCharReadFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 取込みフラグ
     */
    public enum ImportFlg implements CDef {
        /** $0: 未取込 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 取込済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ImportFlg> _codeClsMap = new HashMap<String, ImportFlg>();
        private static final Map<String, ImportFlg> _nameClsMap = new HashMap<String, ImportFlg>();
        static {
            for (ImportFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ImportFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ImportFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ImportFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ImportFlg) { return OptionalThing.of((ImportFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ImportFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ImportFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ImportFlg) { return (ImportFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ImportFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ImportFlg> listAll() {
            return new ArrayList<ImportFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ImportFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ImportFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ImportFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ImportFlg> clsList = new ArrayList<ImportFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ImportFlg> groupOf(String groupName) {
            return new ArrayList<ImportFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 終了したお知らせの表示
     */
    public enum InfoFlg implements CDef {
        /** $0: 表示する */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 表示しない */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InfoFlg> _codeClsMap = new HashMap<String, InfoFlg>();
        private static final Map<String, InfoFlg> _nameClsMap = new HashMap<String, InfoFlg>();
        static {
            for (InfoFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InfoFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InfoFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InfoFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InfoFlg) { return OptionalThing.of((InfoFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InfoFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InfoFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InfoFlg) { return (InfoFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InfoFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InfoFlg> listAll() {
            return new ArrayList<InfoFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InfoFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InfoFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InfoFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InfoFlg> clsList = new ArrayList<InfoFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InfoFlg> groupOf(String groupName) {
            return new ArrayList<InfoFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入出庫区分
     */
    public enum InoutType implements CDef {
        /** $0: 入庫 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出庫 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InoutType> _codeClsMap = new HashMap<String, InoutType>();
        private static final Map<String, InoutType> _nameClsMap = new HashMap<String, InoutType>();
        static {
            for (InoutType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InoutType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InoutType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InoutType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InoutType) { return OptionalThing.of((InoutType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InoutType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InoutType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InoutType) { return (InoutType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InoutType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InoutType> listAll() {
            return new ArrayList<InoutType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InoutType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InoutType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InoutType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InoutType> clsList = new ArrayList<InoutType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InoutType> groupOf(String groupName) {
            return new ArrayList<InoutType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入力区分
     */
    public enum InputType implements CDef {
        /** $00: 画面入力 */
        $00("00", "$00", emptyStrings())
        ,
        /** $10: アップロード */
        $10("10", "$10", emptyStrings())
        ,
        /** $20: EDI */
        $20("20", "$20", emptyStrings())
        ,
        /** $30: HT */
        $30("30", "$30", emptyStrings())
        ;
        private static final Map<String, InputType> _codeClsMap = new HashMap<String, InputType>();
        private static final Map<String, InputType> _nameClsMap = new HashMap<String, InputType>();
        static {
            for (InputType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InputType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InputType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InputType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InputType) { return OptionalThing.of((InputType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InputType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InputType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InputType) { return (InputType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InputType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InputType> listAll() {
            return new ArrayList<InputType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InputType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InputType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InputType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InputType> clsList = new ArrayList<InputType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InputType> groupOf(String groupName) {
            return new ArrayList<InputType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 検品フラグ
     */
    public enum InspectionFlg implements CDef {
        /** $0: 未検品 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 検品済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $7: 検品作業中 */
        $7("7", "$7", emptyStrings())
        ;
        private static final Map<String, InspectionFlg> _codeClsMap = new HashMap<String, InspectionFlg>();
        private static final Map<String, InspectionFlg> _nameClsMap = new HashMap<String, InspectionFlg>();
        static {
            for (InspectionFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InspectionFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InspectionFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InspectionFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InspectionFlg) { return OptionalThing.of((InspectionFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InspectionFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InspectionFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InspectionFlg) { return (InspectionFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InspectionFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InspectionFlg> listAll() {
            return new ArrayList<InspectionFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InspectionFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InspectionFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InspectionFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InspectionFlg> clsList = new ArrayList<InspectionFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InspectionFlg> groupOf(String groupName) {
            return new ArrayList<InspectionFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 比較条件差異
     */
    public enum InventoryLocationProduct implements CDef {
        /** $0: 商品単位の差異 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ロケーション単位の差異 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InventoryLocationProduct> _codeClsMap = new HashMap<String, InventoryLocationProduct>();
        private static final Map<String, InventoryLocationProduct> _nameClsMap = new HashMap<String, InventoryLocationProduct>();
        static {
            for (InventoryLocationProduct value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InventoryLocationProduct(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InventoryLocationProduct; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryLocationProduct> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InventoryLocationProduct) { return OptionalThing.of((InventoryLocationProduct)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryLocationProduct> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InventoryLocationProduct codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InventoryLocationProduct) { return (InventoryLocationProduct)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InventoryLocationProduct nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InventoryLocationProduct> listAll() {
            return new ArrayList<InventoryLocationProduct>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InventoryLocationProduct> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InventoryLocationProduct." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InventoryLocationProduct> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InventoryLocationProduct> clsList = new ArrayList<InventoryLocationProduct>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InventoryLocationProduct> groupOf(String groupName) {
            return new ArrayList<InventoryLocationProduct>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送り状データ出力フラグ
     */
    public enum InvoiceCreateFlg implements CDef {
        /** $0: 未出力 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出力済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InvoiceCreateFlg> _codeClsMap = new HashMap<String, InvoiceCreateFlg>();
        private static final Map<String, InvoiceCreateFlg> _nameClsMap = new HashMap<String, InvoiceCreateFlg>();
        static {
            for (InvoiceCreateFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InvoiceCreateFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InvoiceCreateFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InvoiceCreateFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InvoiceCreateFlg) { return OptionalThing.of((InvoiceCreateFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InvoiceCreateFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InvoiceCreateFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InvoiceCreateFlg) { return (InvoiceCreateFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InvoiceCreateFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InvoiceCreateFlg> listAll() {
            return new ArrayList<InvoiceCreateFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InvoiceCreateFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InvoiceCreateFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InvoiceCreateFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InvoiceCreateFlg> clsList = new ArrayList<InvoiceCreateFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InvoiceCreateFlg> groupOf(String groupName) {
            return new ArrayList<InvoiceCreateFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 項目型
     */
    public enum ItemType implements CDef {
        /** $text: テキスト */
        $text("text", "$text", emptyStrings())
        ,
        /** $number: 数値 */
        $number("number", "$number", emptyStrings())
        ,
        /** $date: 日付 */
        $date("date", "$date", emptyStrings())
        ,
        /** $datetime: 日時 */
        $datetime("datetime", "$datetime", emptyStrings())
        ,
        /** $dropdown: コンボボックス */
        $dropdown("dropdown", "$dropdown", emptyStrings())
        ,
        /** $checkbox: チェックボックス */
        $checkbox("checkbox", "$checkbox", emptyStrings())
        ,
        /** $grid: グリッド */
        $grid("grid", "$grid", emptyStrings())
        ;
        private static final Map<String, ItemType> _codeClsMap = new HashMap<String, ItemType>();
        private static final Map<String, ItemType> _nameClsMap = new HashMap<String, ItemType>();
        static {
            for (ItemType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ItemType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ItemType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ItemType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ItemType) { return OptionalThing.of((ItemType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ItemType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ItemType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ItemType) { return (ItemType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ItemType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ItemType> listAll() {
            return new ArrayList<ItemType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ItemType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ItemType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ItemType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ItemType> clsList = new ArrayList<ItemType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ItemType> groupOf(String groupName) {
            return new ArrayList<ItemType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 最新フラグ
     */
    public enum LastFlg implements CDef {
        /** $0: 最新でない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 最新 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LastFlg> _codeClsMap = new HashMap<String, LastFlg>();
        private static final Map<String, LastFlg> _nameClsMap = new HashMap<String, LastFlg>();
        static {
            for (LastFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LastFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LastFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LastFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LastFlg) { return OptionalThing.of((LastFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LastFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LastFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LastFlg) { return (LastFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LastFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LastFlg> listAll() {
            return new ArrayList<LastFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LastFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LastFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LastFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LastFlg> clsList = new ArrayList<LastFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LastFlg> groupOf(String groupName) {
            return new ArrayList<LastFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 期限日管理フラグ
     */
    public enum LimitDtManagFlg implements CDef {
        /** $1: 管理する */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: 管理しない */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, LimitDtManagFlg> _codeClsMap = new HashMap<String, LimitDtManagFlg>();
        private static final Map<String, LimitDtManagFlg> _nameClsMap = new HashMap<String, LimitDtManagFlg>();
        static {
            for (LimitDtManagFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LimitDtManagFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LimitDtManagFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitDtManagFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LimitDtManagFlg) { return OptionalThing.of((LimitDtManagFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitDtManagFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LimitDtManagFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LimitDtManagFlg) { return (LimitDtManagFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LimitDtManagFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LimitDtManagFlg> listAll() {
            return new ArrayList<LimitDtManagFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LimitDtManagFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LimitDtManagFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LimitDtManagFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LimitDtManagFlg> clsList = new ArrayList<LimitDtManagFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LimitDtManagFlg> groupOf(String groupName) {
            return new ArrayList<LimitDtManagFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 期限日逆転防止フラグ
     */
    public enum LimitDtReverseFlg implements CDef {
        /** $1: 管理する */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: 管理しない */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, LimitDtReverseFlg> _codeClsMap = new HashMap<String, LimitDtReverseFlg>();
        private static final Map<String, LimitDtReverseFlg> _nameClsMap = new HashMap<String, LimitDtReverseFlg>();
        static {
            for (LimitDtReverseFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LimitDtReverseFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LimitDtReverseFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitDtReverseFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LimitDtReverseFlg) { return OptionalThing.of((LimitDtReverseFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitDtReverseFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LimitDtReverseFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LimitDtReverseFlg) { return (LimitDtReverseFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LimitDtReverseFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LimitDtReverseFlg> listAll() {
            return new ArrayList<LimitDtReverseFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LimitDtReverseFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LimitDtReverseFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LimitDtReverseFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LimitDtReverseFlg> clsList = new ArrayList<LimitDtReverseFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LimitDtReverseFlg> groupOf(String groupName) {
            return new ArrayList<LimitDtReverseFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 制限メッセージCD
     */
    public enum LimitMessageCd implements CDef {
        /** $inputLimitCheckNumericOnlyError: 数字のみメッセージCD */
        $inputLimitCheckNumericOnlyError("inputLimitCheckNumericOnlyError", "$inputLimitCheckNumericOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckNumericAndHyphenOnlyError: 数字と-のみ(電話番号等)メッセージCD */
        $inputLimitCheckNumericAndHyphenOnlyError("inputLimitCheckNumericAndHyphenOnlyError", "$inputLimitCheckNumericAndHyphenOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckAlphabetOnlyError: 英字のみメッセージCD */
        $inputLimitCheckAlphabetOnlyError("inputLimitCheckAlphabetOnlyError", "$inputLimitCheckAlphabetOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckAlphabetAndHyphenOnlyError: 英字と-のみメッセージCD */
        $inputLimitCheckAlphabetAndHyphenOnlyError("inputLimitCheckAlphabetAndHyphenOnlyError", "$inputLimitCheckAlphabetAndHyphenOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckAlphabetAndNumericOnlyError: 英数字のみメッセージCD */
        $inputLimitCheckAlphabetAndNumericOnlyError("inputLimitCheckAlphabetAndNumericOnlyError", "$inputLimitCheckAlphabetAndNumericOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckAlphabetAndNumericAndHyphenOnlyError: 英数字と-のみメッセージCD */
        $inputLimitCheckAlphabetAndNumericAndHyphenOnlyError("inputLimitCheckAlphabetAndNumericAndHyphenOnlyError", "$inputLimitCheckAlphabetAndNumericAndHyphenOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckAlphabetAndNumericAndSymbolOnlyError: 英数字と記号(半角カタカナ,SPを除く)メッセージCD */
        $inputLimitCheckAlphabetAndNumericAndSymbolOnlyError("inputLimitCheckAlphabetAndNumericAndSymbolOnlyError", "$inputLimitCheckAlphabetAndNumericAndSymbolOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckHalfWidthOnlyError: 半角文字のみメッセージCD */
        $inputLimitCheckHalfWidthOnlyError("inputLimitCheckHalfWidthOnlyError", "$inputLimitCheckHalfWidthOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckFullWidthOnlyError: 全角文字のみメッセージCD */
        $inputLimitCheckFullWidthOnlyError("inputLimitCheckFullWidthOnlyError", "$inputLimitCheckFullWidthOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckTimeOnlyError: 時刻のみ(hh24:mm)メッセージCD */
        $inputLimitCheckTimeOnlyError("inputLimitCheckTimeOnlyError", "$inputLimitCheckTimeOnlyError", emptyStrings())
        ,
        /** $inputLimitCheckTimeHHMMSSOnlyError: 時刻のみ(hh24:mm:ss)メッセージCD */
        $inputLimitCheckTimeHHMMSSOnlyError("inputLimitCheckTimeHHMMSSOnlyError", "$inputLimitCheckTimeHHMMSSOnlyError", emptyStrings())
        ;
        private static final Map<String, LimitMessageCd> _codeClsMap = new HashMap<String, LimitMessageCd>();
        private static final Map<String, LimitMessageCd> _nameClsMap = new HashMap<String, LimitMessageCd>();
        static {
            for (LimitMessageCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LimitMessageCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LimitMessageCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitMessageCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LimitMessageCd) { return OptionalThing.of((LimitMessageCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitMessageCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LimitMessageCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LimitMessageCd) { return (LimitMessageCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LimitMessageCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LimitMessageCd> listAll() {
            return new ArrayList<LimitMessageCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LimitMessageCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LimitMessageCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LimitMessageCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LimitMessageCd> clsList = new ArrayList<LimitMessageCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LimitMessageCd> groupOf(String groupName) {
            return new ArrayList<LimitMessageCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 改行コード
     */
    public enum LineFeedCd implements CDef {
        /** $1: CRLF */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: CR */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: LF */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, LineFeedCd> _codeClsMap = new HashMap<String, LineFeedCd>();
        private static final Map<String, LineFeedCd> _nameClsMap = new HashMap<String, LineFeedCd>();
        static {
            for (LineFeedCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LineFeedCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LineFeedCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LineFeedCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LineFeedCd) { return OptionalThing.of((LineFeedCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LineFeedCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LineFeedCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LineFeedCd) { return (LineFeedCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LineFeedCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LineFeedCd> listAll() {
            return new ArrayList<LineFeedCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LineFeedCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LineFeedCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LineFeedCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LineFeedCd> clsList = new ArrayList<LineFeedCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LineFeedCd> groupOf(String groupName) {
            return new ArrayList<LineFeedCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * リスト発行フラグ
     */
    public enum ListOutFlg implements CDef {
        /** $0: 未発行 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 発行済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ListOutFlg> _codeClsMap = new HashMap<String, ListOutFlg>();
        private static final Map<String, ListOutFlg> _nameClsMap = new HashMap<String, ListOutFlg>();
        static {
            for (ListOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ListOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ListOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ListOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ListOutFlg) { return OptionalThing.of((ListOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ListOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ListOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ListOutFlg) { return (ListOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ListOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ListOutFlg> listAll() {
            return new ArrayList<ListOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ListOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ListOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ListOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ListOutFlg> clsList = new ArrayList<ListOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ListOutFlg> groupOf(String groupName) {
            return new ArrayList<ListOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 発行区分
     */
    public enum ListOutKbn implements CDef {
        /** $0: 未発行 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 発行済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 全件 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, ListOutKbn> _codeClsMap = new HashMap<String, ListOutKbn>();
        private static final Map<String, ListOutKbn> _nameClsMap = new HashMap<String, ListOutKbn>();
        static {
            for (ListOutKbn value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ListOutKbn(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ListOutKbn; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ListOutKbn> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ListOutKbn) { return OptionalThing.of((ListOutKbn)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ListOutKbn> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ListOutKbn codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ListOutKbn) { return (ListOutKbn)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ListOutKbn nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ListOutKbn> listAll() {
            return new ArrayList<ListOutKbn>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ListOutKbn> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ListOutKbn." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ListOutKbn> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ListOutKbn> clsList = new ArrayList<ListOutKbn>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ListOutKbn> groupOf(String groupName) {
            return new ArrayList<ListOutKbn>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * リスト発行フラグ(一覧表示用)
     */
    public enum ListOutFlgDisp implements CDef {
        /** $0: 未発行 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 発行済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 一部発行済 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, ListOutFlgDisp> _codeClsMap = new HashMap<String, ListOutFlgDisp>();
        private static final Map<String, ListOutFlgDisp> _nameClsMap = new HashMap<String, ListOutFlgDisp>();
        static {
            for (ListOutFlgDisp value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ListOutFlgDisp(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ListOutFlgDisp; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ListOutFlgDisp> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ListOutFlgDisp) { return OptionalThing.of((ListOutFlgDisp)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ListOutFlgDisp> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ListOutFlgDisp codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ListOutFlgDisp) { return (ListOutFlgDisp)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ListOutFlgDisp nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ListOutFlgDisp> listAll() {
            return new ArrayList<ListOutFlgDisp>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ListOutFlgDisp> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ListOutFlgDisp." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ListOutFlgDisp> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ListOutFlgDisp> clsList = new ArrayList<ListOutFlgDisp>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ListOutFlgDisp> groupOf(String groupName) {
            return new ArrayList<ListOutFlgDisp>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 積込フラグ
     */
    public enum LoadingFlg implements CDef {
        /** $0: 未検品 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 検品済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LoadingFlg> _codeClsMap = new HashMap<String, LoadingFlg>();
        private static final Map<String, LoadingFlg> _nameClsMap = new HashMap<String, LoadingFlg>();
        static {
            for (LoadingFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LoadingFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LoadingFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LoadingFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LoadingFlg) { return OptionalThing.of((LoadingFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LoadingFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LoadingFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LoadingFlg) { return (LoadingFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LoadingFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LoadingFlg> listAll() {
            return new ArrayList<LoadingFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LoadingFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LoadingFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LoadingFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LoadingFlg> clsList = new ArrayList<LoadingFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LoadingFlg> groupOf(String groupName) {
            return new ArrayList<LoadingFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ロケーション種別
     */
    public enum LocationType implements CDef {
        /** $00: 通常ロケーション */
        $00("00", "$00", emptyStrings())
        ,
        /** $01: 入庫仮ロケーション */
        $01("01", "$01", emptyStrings())
        ;
        private static final Map<String, LocationType> _codeClsMap = new HashMap<String, LocationType>();
        private static final Map<String, LocationType> _nameClsMap = new HashMap<String, LocationType>();
        static {
            for (LocationType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LocationType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LocationType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LocationType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LocationType) { return OptionalThing.of((LocationType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LocationType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LocationType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LocationType) { return (LocationType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LocationType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LocationType> listAll() {
            return new ArrayList<LocationType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LocationType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LocationType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LocationType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LocationType> clsList = new ArrayList<LocationType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LocationType> groupOf(String groupName) {
            return new ArrayList<LocationType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ロックアウト
     */
    public enum Lockout implements CDef {
        /** $0: アンロック */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ロックアウト */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Lockout> _codeClsMap = new HashMap<String, Lockout>();
        private static final Map<String, Lockout> _nameClsMap = new HashMap<String, Lockout>();
        static {
            for (Lockout value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Lockout(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Lockout; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Lockout> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Lockout) { return OptionalThing.of((Lockout)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Lockout> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Lockout codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Lockout) { return (Lockout)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Lockout nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Lockout> listAll() {
            return new ArrayList<Lockout>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Lockout> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Lockout." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Lockout> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Lockout> clsList = new ArrayList<Lockout>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Lockout> groupOf(String groupName) {
            return new ArrayList<Lockout>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ログ明細ステータス
     */
    public enum LogDtlStatus implements CDef {
        /** $1: 情報 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 警告 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: エラー */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, LogDtlStatus> _codeClsMap = new HashMap<String, LogDtlStatus>();
        private static final Map<String, LogDtlStatus> _nameClsMap = new HashMap<String, LogDtlStatus>();
        static {
            for (LogDtlStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LogDtlStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LogDtlStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogDtlStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LogDtlStatus) { return OptionalThing.of((LogDtlStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogDtlStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LogDtlStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LogDtlStatus) { return (LogDtlStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LogDtlStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LogDtlStatus> listAll() {
            return new ArrayList<LogDtlStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LogDtlStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LogDtlStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LogDtlStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LogDtlStatus> clsList = new ArrayList<LogDtlStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LogDtlStatus> groupOf(String groupName) {
            return new ArrayList<LogDtlStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ログ明細種別
     */
    public enum LogDtlType implements CDef {
        /** $1: セクション開始ログ */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: セクション終了ログ */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 明細ログ */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 基盤出力ログ */
        $4("4", "$4", emptyStrings())
        ;
        private static final Map<String, LogDtlType> _codeClsMap = new HashMap<String, LogDtlType>();
        private static final Map<String, LogDtlType> _nameClsMap = new HashMap<String, LogDtlType>();
        static {
            for (LogDtlType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LogDtlType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LogDtlType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogDtlType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LogDtlType) { return OptionalThing.of((LogDtlType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogDtlType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LogDtlType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LogDtlType) { return (LogDtlType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LogDtlType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LogDtlType> listAll() {
            return new ArrayList<LogDtlType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LogDtlType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LogDtlType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LogDtlType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LogDtlType> clsList = new ArrayList<LogDtlType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LogDtlType> groupOf(String groupName) {
            return new ArrayList<LogDtlType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ログステータス
     */
    public enum LogStatus implements CDef {
        /** $1: 処理中 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 正常終了 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 異常終了 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, LogStatus> _codeClsMap = new HashMap<String, LogStatus>();
        private static final Map<String, LogStatus> _nameClsMap = new HashMap<String, LogStatus>();
        static {
            for (LogStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LogStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LogStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LogStatus) { return OptionalThing.of((LogStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LogStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LogStatus) { return (LogStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LogStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LogStatus> listAll() {
            return new ArrayList<LogStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LogStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LogStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LogStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LogStatus> clsList = new ArrayList<LogStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LogStatus> groupOf(String groupName) {
            return new ArrayList<LogStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ロット管理フラグ
     */
    public enum LotManagFlg implements CDef {
        /** $1: 管理する */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: 管理しない */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, LotManagFlg> _codeClsMap = new HashMap<String, LotManagFlg>();
        private static final Map<String, LotManagFlg> _nameClsMap = new HashMap<String, LotManagFlg>();
        static {
            for (LotManagFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LotManagFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LotManagFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LotManagFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LotManagFlg) { return OptionalThing.of((LotManagFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LotManagFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LotManagFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LotManagFlg) { return (LotManagFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LotManagFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LotManagFlg> listAll() {
            return new ArrayList<LotManagFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LotManagFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LotManagFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LotManagFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LotManagFlg> clsList = new ArrayList<LotManagFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LotManagFlg> groupOf(String groupName) {
            return new ArrayList<LotManagFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ロット逆転防止フラグ
     */
    public enum LotReverseFlg implements CDef {
        /** $1: 管理する */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: 管理しない */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, LotReverseFlg> _codeClsMap = new HashMap<String, LotReverseFlg>();
        private static final Map<String, LotReverseFlg> _nameClsMap = new HashMap<String, LotReverseFlg>();
        static {
            for (LotReverseFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LotReverseFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LotReverseFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LotReverseFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LotReverseFlg) { return OptionalThing.of((LotReverseFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LotReverseFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LotReverseFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LotReverseFlg) { return (LotReverseFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LotReverseFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LotReverseFlg> listAll() {
            return new ArrayList<LotReverseFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LotReverseFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LotReverseFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LotReverseFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LotReverseFlg> clsList = new ArrayList<LotReverseFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LotReverseFlg> groupOf(String groupName) {
            return new ArrayList<LotReverseFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入庫No.マージ区分
     */
    public enum MergeCls implements CDef {
        /** $00: マージしない */
        $00("00", "$00", emptyStrings())
        ,
        /** $01: ピックロケのみ自動マージ */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 自動マージ */
        $02("02", "$02", emptyStrings())
        ;
        private static final Map<String, MergeCls> _codeClsMap = new HashMap<String, MergeCls>();
        private static final Map<String, MergeCls> _nameClsMap = new HashMap<String, MergeCls>();
        static {
            for (MergeCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MergeCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MergeCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MergeCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MergeCls) { return OptionalThing.of((MergeCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MergeCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MergeCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MergeCls) { return (MergeCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MergeCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MergeCls> listAll() {
            return new ArrayList<MergeCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MergeCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MergeCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MergeCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MergeCls> clsList = new ArrayList<MergeCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MergeCls> groupOf(String groupName) {
            return new ArrayList<MergeCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 名寄せ有無
     */
    public enum MergeFlg implements CDef {
        /** $0: 名寄せ無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 名寄せ有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, MergeFlg> _codeClsMap = new HashMap<String, MergeFlg>();
        private static final Map<String, MergeFlg> _nameClsMap = new HashMap<String, MergeFlg>();
        static {
            for (MergeFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MergeFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MergeFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MergeFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MergeFlg) { return OptionalThing.of((MergeFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MergeFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MergeFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MergeFlg) { return (MergeFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MergeFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MergeFlg> listAll() {
            return new ArrayList<MergeFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MergeFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MergeFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MergeFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MergeFlg> clsList = new ArrayList<MergeFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MergeFlg> groupOf(String groupName) {
            return new ArrayList<MergeFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 属性
     */
    public enum MessageType implements CDef {
        /** $error: エラー */
        $error("error", "$error", emptyStrings())
        ,
        /** $warn: 警告 */
        $warn("warn", "$warn", emptyStrings())
        ,
        /** $info: 情報 */
        $info("info", "$info", emptyStrings())
        ,
        /** $confirm: 確認 */
        $confirm("confirm", "$confirm", emptyStrings())
        ;
        private static final Map<String, MessageType> _codeClsMap = new HashMap<String, MessageType>();
        private static final Map<String, MessageType> _nameClsMap = new HashMap<String, MessageType>();
        static {
            for (MessageType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MessageType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MessageType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MessageType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MessageType) { return OptionalThing.of((MessageType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MessageType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MessageType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MessageType) { return (MessageType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MessageType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MessageType> listAll() {
            return new ArrayList<MessageType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MessageType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MessageType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MessageType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MessageType> clsList = new ArrayList<MessageType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MessageType> groupOf(String groupName) {
            return new ArrayList<MessageType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 混載フラグ
     */
    public enum MixedFlg implements CDef {
        /** $0: 単品 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 混載 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, MixedFlg> _codeClsMap = new HashMap<String, MixedFlg>();
        private static final Map<String, MixedFlg> _nameClsMap = new HashMap<String, MixedFlg>();
        static {
            for (MixedFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MixedFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MixedFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MixedFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MixedFlg) { return OptionalThing.of((MixedFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MixedFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MixedFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MixedFlg) { return (MixedFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MixedFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MixedFlg> listAll() {
            return new ArrayList<MixedFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MixedFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MixedFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MixedFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MixedFlg> clsList = new ArrayList<MixedFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MixedFlg> groupOf(String groupName) {
            return new ArrayList<MixedFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫移動指示ステータス
     */
    public enum MoveInstStatus implements CDef {
        /** $00: 未作業 */
        $00("00", "$00", emptyStrings())
        ,
        /** $01: 作業中 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 完了 */
        $02("02", "$02", emptyStrings())
        ,
        /** $99: 取消 */
        $99("99", "$99", emptyStrings())
        ;
        private static final Map<String, MoveInstStatus> _codeClsMap = new HashMap<String, MoveInstStatus>();
        private static final Map<String, MoveInstStatus> _nameClsMap = new HashMap<String, MoveInstStatus>();
        static {
            for (MoveInstStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MoveInstStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MoveInstStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MoveInstStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MoveInstStatus) { return OptionalThing.of((MoveInstStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MoveInstStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MoveInstStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MoveInstStatus) { return (MoveInstStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MoveInstStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MoveInstStatus> listAll() {
            return new ArrayList<MoveInstStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MoveInstStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MoveInstStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MoveInstStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MoveInstStatus> clsList = new ArrayList<MoveInstStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MoveInstStatus> groupOf(String groupName) {
            return new ArrayList<MoveInstStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * マルチピック計算区分
     */
    public enum MultiPicCls implements CDef {
        /** $0: マルチピック計算無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: マルチピック計算有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, MultiPicCls> _codeClsMap = new HashMap<String, MultiPicCls>();
        private static final Map<String, MultiPicCls> _nameClsMap = new HashMap<String, MultiPicCls>();
        static {
            for (MultiPicCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MultiPicCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MultiPicCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MultiPicCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MultiPicCls) { return OptionalThing.of((MultiPicCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MultiPicCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MultiPicCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MultiPicCls) { return (MultiPicCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MultiPicCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MultiPicCls> listAll() {
            return new ArrayList<MultiPicCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MultiPicCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MultiPicCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MultiPicCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MultiPicCls> clsList = new ArrayList<MultiPicCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MultiPicCls> groupOf(String groupName) {
            return new ArrayList<MultiPicCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * マルチピック計算フラグ
     */
    public enum MultiPicFlg implements CDef {
        /** $0: 計算無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 計算有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, MultiPicFlg> _codeClsMap = new HashMap<String, MultiPicFlg>();
        private static final Map<String, MultiPicFlg> _nameClsMap = new HashMap<String, MultiPicFlg>();
        static {
            for (MultiPicFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MultiPicFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MultiPicFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MultiPicFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MultiPicFlg) { return OptionalThing.of((MultiPicFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MultiPicFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MultiPicFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MultiPicFlg) { return (MultiPicFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MultiPicFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MultiPicFlg> listAll() {
            return new ArrayList<MultiPicFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MultiPicFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MultiPicFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MultiPicFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MultiPicFlg> clsList = new ArrayList<MultiPicFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MultiPicFlg> groupOf(String groupName) {
            return new ArrayList<MultiPicFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 必須
     */
    public enum Necessary implements CDef {
        /** $0: 任意 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 必須 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Necessary> _codeClsMap = new HashMap<String, Necessary>();
        private static final Map<String, Necessary> _nameClsMap = new HashMap<String, Necessary>();
        static {
            for (Necessary value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Necessary(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Necessary; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Necessary> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Necessary) { return OptionalThing.of((Necessary)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Necessary> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Necessary codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Necessary) { return (Necessary)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Necessary nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Necessary> listAll() {
            return new ArrayList<Necessary>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Necessary> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Necessary." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Necessary> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Necessary> clsList = new ArrayList<Necessary>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Necessary> groupOf(String groupName) {
            return new ArrayList<Necessary>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 未出庫全件表示区分
     */
    public enum NoAllcDisplayFlg implements CDef {
        /** $0: 全件ではない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 全件表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, NoAllcDisplayFlg> _codeClsMap = new HashMap<String, NoAllcDisplayFlg>();
        private static final Map<String, NoAllcDisplayFlg> _nameClsMap = new HashMap<String, NoAllcDisplayFlg>();
        static {
            for (NoAllcDisplayFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NoAllcDisplayFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NoAllcDisplayFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoAllcDisplayFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NoAllcDisplayFlg) { return OptionalThing.of((NoAllcDisplayFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoAllcDisplayFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NoAllcDisplayFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NoAllcDisplayFlg) { return (NoAllcDisplayFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NoAllcDisplayFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NoAllcDisplayFlg> listAll() {
            return new ArrayList<NoAllcDisplayFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NoAllcDisplayFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NoAllcDisplayFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NoAllcDisplayFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NoAllcDisplayFlg> clsList = new ArrayList<NoAllcDisplayFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NoAllcDisplayFlg> groupOf(String groupName) {
            return new ArrayList<NoAllcDisplayFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 未確定のみ表示
     */
    public enum NoConfirmedFlg implements CDef {
        /** $0: 全件表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 未確定のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, NoConfirmedFlg> _codeClsMap = new HashMap<String, NoConfirmedFlg>();
        private static final Map<String, NoConfirmedFlg> _nameClsMap = new HashMap<String, NoConfirmedFlg>();
        static {
            for (NoConfirmedFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NoConfirmedFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NoConfirmedFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoConfirmedFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NoConfirmedFlg) { return OptionalThing.of((NoConfirmedFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoConfirmedFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NoConfirmedFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NoConfirmedFlg) { return (NoConfirmedFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NoConfirmedFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NoConfirmedFlg> listAll() {
            return new ArrayList<NoConfirmedFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NoConfirmedFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NoConfirmedFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NoConfirmedFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NoConfirmedFlg> clsList = new ArrayList<NoConfirmedFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NoConfirmedFlg> groupOf(String groupName) {
            return new ArrayList<NoConfirmedFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 下積み厳禁区分
     */
    public enum NoStockCls implements CDef {
        /** $0: 無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, NoStockCls> _codeClsMap = new HashMap<String, NoStockCls>();
        private static final Map<String, NoStockCls> _nameClsMap = new HashMap<String, NoStockCls>();
        static {
            for (NoStockCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NoStockCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NoStockCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoStockCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NoStockCls) { return OptionalThing.of((NoStockCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoStockCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NoStockCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NoStockCls) { return (NoStockCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NoStockCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NoStockCls> listAll() {
            return new ArrayList<NoStockCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NoStockCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NoStockCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NoStockCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NoStockCls> clsList = new ArrayList<NoStockCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NoStockCls> groupOf(String groupName) {
            return new ArrayList<NoStockCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 欠品無のみ表示
     */
    public enum NoStockOutFlg implements CDef {
        /** $0: 欠品無のみ表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 欠品有のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, NoStockOutFlg> _codeClsMap = new HashMap<String, NoStockOutFlg>();
        private static final Map<String, NoStockOutFlg> _nameClsMap = new HashMap<String, NoStockOutFlg>();
        static {
            for (NoStockOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NoStockOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NoStockOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoStockOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NoStockOutFlg) { return OptionalThing.of((NoStockOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoStockOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NoStockOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NoStockOutFlg) { return (NoStockOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NoStockOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NoStockOutFlg> listAll() {
            return new ArrayList<NoStockOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NoStockOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NoStockOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NoStockOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NoStockOutFlg> clsList = new ArrayList<NoStockOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NoStockOutFlg> groupOf(String groupName) {
            return new ArrayList<NoStockOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 逆さま厳禁区分
     */
    public enum NoUpsideDownCls implements CDef {
        /** $0: 無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, NoUpsideDownCls> _codeClsMap = new HashMap<String, NoUpsideDownCls>();
        private static final Map<String, NoUpsideDownCls> _nameClsMap = new HashMap<String, NoUpsideDownCls>();
        static {
            for (NoUpsideDownCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NoUpsideDownCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NoUpsideDownCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoUpsideDownCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NoUpsideDownCls) { return OptionalThing.of((NoUpsideDownCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoUpsideDownCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NoUpsideDownCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NoUpsideDownCls) { return (NoUpsideDownCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NoUpsideDownCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NoUpsideDownCls> listAll() {
            return new ArrayList<NoUpsideDownCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NoUpsideDownCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NoUpsideDownCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NoUpsideDownCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NoUpsideDownCls> clsList = new ArrayList<NoUpsideDownCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NoUpsideDownCls> groupOf(String groupName) {
            return new ArrayList<NoUpsideDownCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 未完了のみ表示
     */
    public enum NotCompletedFlg implements CDef {
        /** $0: 全件表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 未完了のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, NotCompletedFlg> _codeClsMap = new HashMap<String, NotCompletedFlg>();
        private static final Map<String, NotCompletedFlg> _nameClsMap = new HashMap<String, NotCompletedFlg>();
        static {
            for (NotCompletedFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NotCompletedFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NotCompletedFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NotCompletedFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NotCompletedFlg) { return OptionalThing.of((NotCompletedFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NotCompletedFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NotCompletedFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NotCompletedFlg) { return (NotCompletedFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NotCompletedFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NotCompletedFlg> listAll() {
            return new ArrayList<NotCompletedFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NotCompletedFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NotCompletedFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NotCompletedFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NotCompletedFlg> clsList = new ArrayList<NotCompletedFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NotCompletedFlg> groupOf(String groupName) {
            return new ArrayList<NotCompletedFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ワンタイムフラグ
     */
    public enum OnetimeFlg implements CDef {
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, OnetimeFlg> _codeClsMap = new HashMap<String, OnetimeFlg>();
        private static final Map<String, OnetimeFlg> _nameClsMap = new HashMap<String, OnetimeFlg>();
        static {
            for (OnetimeFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private OnetimeFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.OnetimeFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OnetimeFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof OnetimeFlg) { return OptionalThing.of((OnetimeFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OnetimeFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static OnetimeFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof OnetimeFlg) { return (OnetimeFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static OnetimeFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<OnetimeFlg> listAll() {
            return new ArrayList<OnetimeFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<OnetimeFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: OnetimeFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<OnetimeFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<OnetimeFlg> clsList = new ArrayList<OnetimeFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<OnetimeFlg> groupOf(String groupName) {
            return new ArrayList<OnetimeFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * HT/SD過入荷可フラグ
     */
    public enum OverStoreNumFlg implements CDef {
        /** $0: 不可 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 可能 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, OverStoreNumFlg> _codeClsMap = new HashMap<String, OverStoreNumFlg>();
        private static final Map<String, OverStoreNumFlg> _nameClsMap = new HashMap<String, OverStoreNumFlg>();
        static {
            for (OverStoreNumFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private OverStoreNumFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.OverStoreNumFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OverStoreNumFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof OverStoreNumFlg) { return OptionalThing.of((OverStoreNumFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OverStoreNumFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static OverStoreNumFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof OverStoreNumFlg) { return (OverStoreNumFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static OverStoreNumFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<OverStoreNumFlg> listAll() {
            return new ArrayList<OverStoreNumFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<OverStoreNumFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: OverStoreNumFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<OverStoreNumFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<OverStoreNumFlg> clsList = new ArrayList<OverStoreNumFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<OverStoreNumFlg> groupOf(String groupName) {
            return new ArrayList<OverStoreNumFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 梱包計算処理区分
     */
    public enum PackingCalCls implements CDef {
        /** $0: 梱包計算無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 容積と重量による梱包計算 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PackingCalCls> _codeClsMap = new HashMap<String, PackingCalCls>();
        private static final Map<String, PackingCalCls> _nameClsMap = new HashMap<String, PackingCalCls>();
        static {
            for (PackingCalCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PackingCalCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PackingCalCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingCalCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PackingCalCls) { return OptionalThing.of((PackingCalCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingCalCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PackingCalCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PackingCalCls) { return (PackingCalCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PackingCalCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PackingCalCls> listAll() {
            return new ArrayList<PackingCalCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PackingCalCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PackingCalCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PackingCalCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PackingCalCls> clsList = new ArrayList<PackingCalCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PackingCalCls> groupOf(String groupName) {
            return new ArrayList<PackingCalCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 梱包方法
     */
    public enum PackingProcessCls implements CDef {
        /** $0: 受取側考慮(出荷指示昇順) */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: なるべく詰める(容積降順) */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PackingProcessCls> _codeClsMap = new HashMap<String, PackingProcessCls>();
        private static final Map<String, PackingProcessCls> _nameClsMap = new HashMap<String, PackingProcessCls>();
        static {
            for (PackingProcessCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PackingProcessCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PackingProcessCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingProcessCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PackingProcessCls) { return OptionalThing.of((PackingProcessCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingProcessCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PackingProcessCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PackingProcessCls) { return (PackingProcessCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PackingProcessCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PackingProcessCls> listAll() {
            return new ArrayList<PackingProcessCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PackingProcessCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PackingProcessCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PackingProcessCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PackingProcessCls> clsList = new ArrayList<PackingProcessCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PackingProcessCls> groupOf(String groupName) {
            return new ArrayList<PackingProcessCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 個数口表示フラグ
     */
    public enum PackingShowFlg implements CDef {
        /** $0: 表示する */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 表示しない */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PackingShowFlg> _codeClsMap = new HashMap<String, PackingShowFlg>();
        private static final Map<String, PackingShowFlg> _nameClsMap = new HashMap<String, PackingShowFlg>();
        static {
            for (PackingShowFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PackingShowFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PackingShowFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingShowFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PackingShowFlg) { return OptionalThing.of((PackingShowFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingShowFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PackingShowFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PackingShowFlg) { return (PackingShowFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PackingShowFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PackingShowFlg> listAll() {
            return new ArrayList<PackingShowFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PackingShowFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PackingShowFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PackingShowFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PackingShowFlg> clsList = new ArrayList<PackingShowFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PackingShowFlg> groupOf(String groupName) {
            return new ArrayList<PackingShowFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 梱包ステータス
     */
    public enum PackingStatus implements CDef {
        /** $10: 未出荷 */
        $10("10", "$10", emptyStrings())
        ,
        /** $15: 出庫指示中 */
        $15("15", "$15", emptyStrings())
        ,
        /** $20: 出庫指示解除中 */
        $20("20", "$20", emptyStrings())
        ,
        /** $25: 出庫指示済 */
        $25("25", "$25", emptyStrings())
        ,
        /** $30: ピッキング中 */
        $30("30", "$30", emptyStrings())
        ,
        /** $35: ピッキング済 */
        $35("35", "$35", emptyStrings())
        ,
        /** $40: 出荷検品中 */
        $40("40", "$40", emptyStrings())
        ,
        /** $45: 出荷検品中断 */
        $45("45", "$45", emptyStrings())
        ,
        /** $50: 出荷検品済 */
        $50("50", "$50", emptyStrings())
        ,
        /** $55: 出荷確定済 */
        $55("55", "$55", emptyStrings())
        ,
        /** $60: 承認待ち */
        $60("60", "$60", emptyStrings())
        ,
        /** $90: キャンセル */
        $90("90", "$90", emptyStrings())
        ,
        /** $99: エラー有 */
        $99("99", "$99", emptyStrings())
        ;
        private static final Map<String, PackingStatus> _codeClsMap = new HashMap<String, PackingStatus>();
        private static final Map<String, PackingStatus> _nameClsMap = new HashMap<String, PackingStatus>();
        static {
            for (PackingStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PackingStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PackingStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PackingStatus) { return OptionalThing.of((PackingStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PackingStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PackingStatus) { return (PackingStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PackingStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PackingStatus> listAll() {
            return new ArrayList<PackingStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PackingStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PackingStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PackingStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PackingStatus> clsList = new ArrayList<PackingStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PackingStatus> groupOf(String groupName) {
            return new ArrayList<PackingStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * パスワードリセット
     */
    public enum PasswordReset implements CDef {
        /** $0: 強制しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 強制する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PasswordReset> _codeClsMap = new HashMap<String, PasswordReset>();
        private static final Map<String, PasswordReset> _nameClsMap = new HashMap<String, PasswordReset>();
        static {
            for (PasswordReset value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PasswordReset(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PasswordReset; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PasswordReset> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PasswordReset) { return OptionalThing.of((PasswordReset)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PasswordReset> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PasswordReset codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PasswordReset) { return (PasswordReset)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PasswordReset nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PasswordReset> listAll() {
            return new ArrayList<PasswordReset>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PasswordReset> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PasswordReset." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PasswordReset> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PasswordReset> clsList = new ArrayList<PasswordReset>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PasswordReset> groupOf(String groupName) {
            return new ArrayList<PasswordReset>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * HT/SD過去日入力可フラグ
     */
    public enum PastStoreDtFlg implements CDef {
        /** $0: 不可 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 可能 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PastStoreDtFlg> _codeClsMap = new HashMap<String, PastStoreDtFlg>();
        private static final Map<String, PastStoreDtFlg> _nameClsMap = new HashMap<String, PastStoreDtFlg>();
        static {
            for (PastStoreDtFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PastStoreDtFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PastStoreDtFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PastStoreDtFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PastStoreDtFlg) { return OptionalThing.of((PastStoreDtFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PastStoreDtFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PastStoreDtFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PastStoreDtFlg) { return (PastStoreDtFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PastStoreDtFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PastStoreDtFlg> listAll() {
            return new ArrayList<PastStoreDtFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PastStoreDtFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PastStoreDtFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PastStoreDtFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PastStoreDtFlg> clsList = new ArrayList<PastStoreDtFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PastStoreDtFlg> groupOf(String groupName) {
            return new ArrayList<PastStoreDtFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 削除
     */
    public enum PhysicalDelete implements CDef {
        /** $1: 削除 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PhysicalDelete> _codeClsMap = new HashMap<String, PhysicalDelete>();
        private static final Map<String, PhysicalDelete> _nameClsMap = new HashMap<String, PhysicalDelete>();
        static {
            for (PhysicalDelete value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PhysicalDelete(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PhysicalDelete; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PhysicalDelete> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PhysicalDelete) { return OptionalThing.of((PhysicalDelete)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PhysicalDelete> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PhysicalDelete codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PhysicalDelete) { return (PhysicalDelete)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PhysicalDelete nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PhysicalDelete> listAll() {
            return new ArrayList<PhysicalDelete>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PhysicalDelete> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PhysicalDelete." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PhysicalDelete> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PhysicalDelete> clsList = new ArrayList<PhysicalDelete>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PhysicalDelete> groupOf(String groupName) {
            return new ArrayList<PhysicalDelete>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ピッキング方法
     */
    public enum PicCls implements CDef {
        /** $1: 一次ピッキング */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 二次ピッキング */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: ケースピッキング */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 送り状・荷札 */
        $4("4", "$4", emptyStrings())
        ;
        private static final Map<String, PicCls> _codeClsMap = new HashMap<String, PicCls>();
        private static final Map<String, PicCls> _nameClsMap = new HashMap<String, PicCls>();
        static {
            for (PicCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PicCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PicCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PicCls) { return OptionalThing.of((PicCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PicCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PicCls) { return (PicCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PicCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PicCls> listAll() {
            return new ArrayList<PicCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PicCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PicCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PicCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PicCls> clsList = new ArrayList<PicCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PicCls> groupOf(String groupName) {
            return new ArrayList<PicCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 最適ピック提案ブレイクキー
     */
    public enum PicMthdRcmdBreakKey implements CDef {
        /** $1: 配送コース */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 運送業者 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, PicMthdRcmdBreakKey> _codeClsMap = new HashMap<String, PicMthdRcmdBreakKey>();
        private static final Map<String, PicMthdRcmdBreakKey> _nameClsMap = new HashMap<String, PicMthdRcmdBreakKey>();
        static {
            for (PicMthdRcmdBreakKey value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PicMthdRcmdBreakKey(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PicMthdRcmdBreakKey; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicMthdRcmdBreakKey> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PicMthdRcmdBreakKey) { return OptionalThing.of((PicMthdRcmdBreakKey)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicMthdRcmdBreakKey> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PicMthdRcmdBreakKey codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PicMthdRcmdBreakKey) { return (PicMthdRcmdBreakKey)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PicMthdRcmdBreakKey nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PicMthdRcmdBreakKey> listAll() {
            return new ArrayList<PicMthdRcmdBreakKey>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PicMthdRcmdBreakKey> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PicMthdRcmdBreakKey." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PicMthdRcmdBreakKey> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PicMthdRcmdBreakKey> clsList = new ArrayList<PicMthdRcmdBreakKey>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PicMthdRcmdBreakKey> groupOf(String groupName) {
            return new ArrayList<PicMthdRcmdBreakKey>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 最適ピック提案フラグ
     */
    public enum PicMthdRcmdFlg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PicMthdRcmdFlg> _codeClsMap = new HashMap<String, PicMthdRcmdFlg>();
        private static final Map<String, PicMthdRcmdFlg> _nameClsMap = new HashMap<String, PicMthdRcmdFlg>();
        static {
            for (PicMthdRcmdFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PicMthdRcmdFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PicMthdRcmdFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicMthdRcmdFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PicMthdRcmdFlg) { return OptionalThing.of((PicMthdRcmdFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicMthdRcmdFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PicMthdRcmdFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PicMthdRcmdFlg) { return (PicMthdRcmdFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PicMthdRcmdFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PicMthdRcmdFlg> listAll() {
            return new ArrayList<PicMthdRcmdFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PicMthdRcmdFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PicMthdRcmdFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PicMthdRcmdFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PicMthdRcmdFlg> clsList = new ArrayList<PicMthdRcmdFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PicMthdRcmdFlg> groupOf(String groupName) {
            return new ArrayList<PicMthdRcmdFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 最適ピックリスト出力フラグ
     */
    public enum PicMthdRcmdListOut implements CDef {
        /** $0: 出力しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出力する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PicMthdRcmdListOut> _codeClsMap = new HashMap<String, PicMthdRcmdListOut>();
        private static final Map<String, PicMthdRcmdListOut> _nameClsMap = new HashMap<String, PicMthdRcmdListOut>();
        static {
            for (PicMthdRcmdListOut value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PicMthdRcmdListOut(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PicMthdRcmdListOut; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicMthdRcmdListOut> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PicMthdRcmdListOut) { return OptionalThing.of((PicMthdRcmdListOut)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PicMthdRcmdListOut> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PicMthdRcmdListOut codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PicMthdRcmdListOut) { return (PicMthdRcmdListOut)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PicMthdRcmdListOut nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PicMthdRcmdListOut> listAll() {
            return new ArrayList<PicMthdRcmdListOut>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PicMthdRcmdListOut> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PicMthdRcmdListOut." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PicMthdRcmdListOut> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PicMthdRcmdListOut> clsList = new ArrayList<PicMthdRcmdListOut>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PicMthdRcmdListOut> groupOf(String groupName) {
            return new ArrayList<PicMthdRcmdListOut>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出庫フラグ
     */
    public enum PickingFlg implements CDef {
        /** $0: 未出庫 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出庫済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $7: 出庫作業中 */
        $7("7", "$7", emptyStrings())
        ;
        private static final Map<String, PickingFlg> _codeClsMap = new HashMap<String, PickingFlg>();
        private static final Map<String, PickingFlg> _nameClsMap = new HashMap<String, PickingFlg>();
        static {
            for (PickingFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PickingFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PickingFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PickingFlg) { return OptionalThing.of((PickingFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PickingFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PickingFlg) { return (PickingFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PickingFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PickingFlg> listAll() {
            return new ArrayList<PickingFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PickingFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PickingFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PickingFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PickingFlg> clsList = new ArrayList<PickingFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PickingFlg> groupOf(String groupName) {
            return new ArrayList<PickingFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ピックロケフラグ
     */
    public enum PickingLocationFlg implements CDef {
        /** $1: ピックロケーション */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: ピックロケーション以外 */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, PickingLocationFlg> _codeClsMap = new HashMap<String, PickingLocationFlg>();
        private static final Map<String, PickingLocationFlg> _nameClsMap = new HashMap<String, PickingLocationFlg>();
        static {
            for (PickingLocationFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PickingLocationFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PickingLocationFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingLocationFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PickingLocationFlg) { return OptionalThing.of((PickingLocationFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingLocationFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PickingLocationFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PickingLocationFlg) { return (PickingLocationFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PickingLocationFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PickingLocationFlg> listAll() {
            return new ArrayList<PickingLocationFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PickingLocationFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PickingLocationFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PickingLocationFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PickingLocationFlg> clsList = new ArrayList<PickingLocationFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PickingLocationFlg> groupOf(String groupName) {
            return new ArrayList<PickingLocationFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出庫ステータス
     */
    public enum PickingStatus implements CDef {
        /** $10: 未出荷 */
        $10("10", "$10", emptyStrings())
        ,
        /** $15: 出庫指示中 */
        $15("15", "$15", emptyStrings())
        ,
        /** $20: 出庫指示解除中 */
        $20("20", "$20", emptyStrings())
        ,
        /** $25: 出庫指示済 */
        $25("25", "$25", emptyStrings())
        ,
        /** $30: ピッキング中 */
        $30("30", "$30", emptyStrings())
        ,
        /** $35: ピッキング済 */
        $35("35", "$35", emptyStrings())
        ,
        /** $40: 出荷検品中 */
        $40("40", "$40", emptyStrings())
        ,
        /** $45: 出荷検品中断 */
        $45("45", "$45", emptyStrings())
        ,
        /** $50: 出荷検品済 */
        $50("50", "$50", emptyStrings())
        ,
        /** $55: 出荷確定済 */
        $55("55", "$55", emptyStrings())
        ,
        /** $60: 承認待ち */
        $60("60", "$60", emptyStrings())
        ,
        /** $90: キャンセル */
        $90("90", "$90", emptyStrings())
        ,
        /** $99: エラー有 */
        $99("99", "$99", emptyStrings())
        ;
        private static final Map<String, PickingStatus> _codeClsMap = new HashMap<String, PickingStatus>();
        private static final Map<String, PickingStatus> _nameClsMap = new HashMap<String, PickingStatus>();
        static {
            for (PickingStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PickingStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PickingStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PickingStatus) { return OptionalThing.of((PickingStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PickingStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PickingStatus) { return (PickingStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PickingStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PickingStatus> listAll() {
            return new ArrayList<PickingStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PickingStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PickingStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PickingStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PickingStatus> clsList = new ArrayList<PickingStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PickingStatus> groupOf(String groupName) {
            return new ArrayList<PickingStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ピッキング種別
     */
    public enum PickingType implements CDef {
        /** $0: バラ */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ケース */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PickingType> _codeClsMap = new HashMap<String, PickingType>();
        private static final Map<String, PickingType> _nameClsMap = new HashMap<String, PickingType>();
        static {
            for (PickingType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PickingType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PickingType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PickingType) { return OptionalThing.of((PickingType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PickingType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PickingType) { return (PickingType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PickingType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PickingType> listAll() {
            return new ArrayList<PickingType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PickingType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PickingType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PickingType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PickingType> clsList = new ArrayList<PickingType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PickingType> groupOf(String groupName) {
            return new ArrayList<PickingType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 郵便種別
     */
    public enum PostType implements CDef {
        /** $0: ゆうパック */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ゆうメール */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 通常(定型) */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 通常(定型外) */
        $3("3", "$3", emptyStrings())
        ,
        /** $5: ポスパケット */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: 宛名ラベル */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, PostType> _codeClsMap = new HashMap<String, PostType>();
        private static final Map<String, PostType> _nameClsMap = new HashMap<String, PostType>();
        static {
            for (PostType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PostType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PostType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PostType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PostType) { return OptionalThing.of((PostType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PostType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PostType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PostType) { return (PostType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PostType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PostType> listAll() {
            return new ArrayList<PostType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PostType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PostType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PostType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PostType> clsList = new ArrayList<PostType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PostType> groupOf(String groupName) {
            return new ArrayList<PostType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 印刷データタイプ
     */
    public enum PrintDataType implements CDef {
        /** $1: 通常 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 保護PDF */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, PrintDataType> _codeClsMap = new HashMap<String, PrintDataType>();
        private static final Map<String, PrintDataType> _nameClsMap = new HashMap<String, PrintDataType>();
        static {
            for (PrintDataType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrintDataType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrintDataType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintDataType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrintDataType) { return OptionalThing.of((PrintDataType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintDataType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrintDataType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrintDataType) { return (PrintDataType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrintDataType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrintDataType> listAll() {
            return new ArrayList<PrintDataType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrintDataType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrintDataType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrintDataType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrintDataType> clsList = new ArrayList<PrintDataType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrintDataType> groupOf(String groupName) {
            return new ArrayList<PrintDataType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * エラーのみ
     */
    public enum PrintErrorFlg implements CDef {
        /** $0: 全て */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: エラーのみ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PrintErrorFlg> _codeClsMap = new HashMap<String, PrintErrorFlg>();
        private static final Map<String, PrintErrorFlg> _nameClsMap = new HashMap<String, PrintErrorFlg>();
        static {
            for (PrintErrorFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrintErrorFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrintErrorFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintErrorFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrintErrorFlg) { return OptionalThing.of((PrintErrorFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintErrorFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrintErrorFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrintErrorFlg) { return (PrintErrorFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrintErrorFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrintErrorFlg> listAll() {
            return new ArrayList<PrintErrorFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrintErrorFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrintErrorFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrintErrorFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrintErrorFlg> clsList = new ArrayList<PrintErrorFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrintErrorFlg> groupOf(String groupName) {
            return new ArrayList<PrintErrorFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 印刷キューステータス
     */
    public enum PrintQueueStatus implements CDef {
        /** $0: 未印刷 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 印刷中 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PrintQueueStatus> _codeClsMap = new HashMap<String, PrintQueueStatus>();
        private static final Map<String, PrintQueueStatus> _nameClsMap = new HashMap<String, PrintQueueStatus>();
        static {
            for (PrintQueueStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrintQueueStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrintQueueStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintQueueStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrintQueueStatus) { return OptionalThing.of((PrintQueueStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintQueueStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrintQueueStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrintQueueStatus) { return (PrintQueueStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrintQueueStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrintQueueStatus> listAll() {
            return new ArrayList<PrintQueueStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrintQueueStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrintQueueStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrintQueueStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrintQueueStatus> clsList = new ArrayList<PrintQueueStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrintQueueStatus> groupOf(String groupName) {
            return new ArrayList<PrintQueueStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 印刷結果区分
     */
    public enum PrintResultClass implements CDef {
        /** $0: 印刷成功 */
        $0("0", "$0", emptyStrings())
        ,
        /** $9: 印刷失敗 */
        $9("9", "$9", emptyStrings())
        ;
        private static final Map<String, PrintResultClass> _codeClsMap = new HashMap<String, PrintResultClass>();
        private static final Map<String, PrintResultClass> _nameClsMap = new HashMap<String, PrintResultClass>();
        static {
            for (PrintResultClass value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrintResultClass(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrintResultClass; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintResultClass> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrintResultClass) { return OptionalThing.of((PrintResultClass)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintResultClass> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrintResultClass codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrintResultClass) { return (PrintResultClass)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrintResultClass nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrintResultClass> listAll() {
            return new ArrayList<PrintResultClass>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrintResultClass> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrintResultClass." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrintResultClass> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrintResultClass> clsList = new ArrayList<PrintResultClass>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrintResultClass> groupOf(String groupName) {
            return new ArrayList<PrintResultClass>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 印刷サービスステータス
     */
    public enum PrintServiceStatus implements CDef {
        /** $0: サービス中 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: サービス停止中 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: シャットダウン中 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, PrintServiceStatus> _codeClsMap = new HashMap<String, PrintServiceStatus>();
        private static final Map<String, PrintServiceStatus> _nameClsMap = new HashMap<String, PrintServiceStatus>();
        static {
            for (PrintServiceStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrintServiceStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrintServiceStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintServiceStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrintServiceStatus) { return OptionalThing.of((PrintServiceStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintServiceStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrintServiceStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrintServiceStatus) { return (PrintServiceStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrintServiceStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrintServiceStatus> listAll() {
            return new ArrayList<PrintServiceStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrintServiceStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrintServiceStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrintServiceStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrintServiceStatus> clsList = new ArrayList<PrintServiceStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrintServiceStatus> groupOf(String groupName) {
            return new ArrayList<PrintServiceStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 印刷ステータス
     */
    public enum PrintStatus implements CDef {
        /** $0: 未印刷 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 印刷中 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 印刷済 */
        $2("2", "$2", emptyStrings())
        ,
        /** $9: 印刷失敗 */
        $9("9", "$9", emptyStrings())
        ;
        private static final Map<String, PrintStatus> _codeClsMap = new HashMap<String, PrintStatus>();
        private static final Map<String, PrintStatus> _nameClsMap = new HashMap<String, PrintStatus>();
        static {
            for (PrintStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrintStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrintStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrintStatus) { return OptionalThing.of((PrintStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrintStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrintStatus) { return (PrintStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrintStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrintStatus> listAll() {
            return new ArrayList<PrintStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrintStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrintStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrintStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrintStatus> clsList = new ArrayList<PrintStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrintStatus> groupOf(String groupName) {
            return new ArrayList<PrintStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 再印刷有無
     */
    public enum PrintedFlg implements CDef {
        /** $0: 有 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 無 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PrintedFlg> _codeClsMap = new HashMap<String, PrintedFlg>();
        private static final Map<String, PrintedFlg> _nameClsMap = new HashMap<String, PrintedFlg>();
        static {
            for (PrintedFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrintedFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrintedFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintedFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrintedFlg) { return OptionalThing.of((PrintedFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintedFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrintedFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrintedFlg) { return (PrintedFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrintedFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrintedFlg> listAll() {
            return new ArrayList<PrintedFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrintedFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrintedFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrintedFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrintedFlg> clsList = new ArrayList<PrintedFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrintedFlg> groupOf(String groupName) {
            return new ArrayList<PrintedFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 優先フラグ
     */
    public enum PriorityFlg implements CDef {
        /** $0: 優先指定無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 優先指定有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PriorityFlg> _codeClsMap = new HashMap<String, PriorityFlg>();
        private static final Map<String, PriorityFlg> _nameClsMap = new HashMap<String, PriorityFlg>();
        static {
            for (PriorityFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PriorityFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PriorityFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PriorityFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PriorityFlg) { return OptionalThing.of((PriorityFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PriorityFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PriorityFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PriorityFlg) { return (PriorityFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PriorityFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PriorityFlg> listAll() {
            return new ArrayList<PriorityFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PriorityFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PriorityFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PriorityFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PriorityFlg> clsList = new ArrayList<PriorityFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PriorityFlg> groupOf(String groupName) {
            return new ArrayList<PriorityFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 商品ラベルソースCDバーコード種別
     */
    public enum ProductLabelJanBarcode implements CDef {
        /** $CODE39: CODE39 */
        $CODE39("CODE39", "$CODE39", emptyStrings())
        ,
        /** $CODE128: CODE128 */
        $CODE128("CODE128", "$CODE128", emptyStrings())
        ,
        /** $CODABAR: CODABAR(NW-7) */
        $CODABAR("CODABAR", "$CODABAR", emptyStrings())
        ,
        /** $JAN: JAN(8or13) */
        $JAN("JAN", "$JAN", emptyStrings())
        ,
        /** $ITF: ITF */
        $ITF("ITF", "$ITF", emptyStrings())
        ;
        private static final Map<String, ProductLabelJanBarcode> _codeClsMap = new HashMap<String, ProductLabelJanBarcode>();
        private static final Map<String, ProductLabelJanBarcode> _nameClsMap = new HashMap<String, ProductLabelJanBarcode>();
        static {
            for (ProductLabelJanBarcode value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProductLabelJanBarcode(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProductLabelJanBarcode; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductLabelJanBarcode> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProductLabelJanBarcode) { return OptionalThing.of((ProductLabelJanBarcode)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductLabelJanBarcode> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProductLabelJanBarcode codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProductLabelJanBarcode) { return (ProductLabelJanBarcode)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProductLabelJanBarcode nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProductLabelJanBarcode> listAll() {
            return new ArrayList<ProductLabelJanBarcode>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProductLabelJanBarcode> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProductLabelJanBarcode." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProductLabelJanBarcode> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProductLabelJanBarcode> clsList = new ArrayList<ProductLabelJanBarcode>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProductLabelJanBarcode> groupOf(String groupName) {
            return new ArrayList<ProductLabelJanBarcode>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 商品ラベル出力単位
     */
    public enum ProductLabelOutUnit implements CDef {
        /** $0: 1明細1枚 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 荷姿毎に1枚(在庫最小単位は全体で1枚) */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 在庫最小単位毎に1枚 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, ProductLabelOutUnit> _codeClsMap = new HashMap<String, ProductLabelOutUnit>();
        private static final Map<String, ProductLabelOutUnit> _nameClsMap = new HashMap<String, ProductLabelOutUnit>();
        static {
            for (ProductLabelOutUnit value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProductLabelOutUnit(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProductLabelOutUnit; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductLabelOutUnit> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProductLabelOutUnit) { return OptionalThing.of((ProductLabelOutUnit)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductLabelOutUnit> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProductLabelOutUnit codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProductLabelOutUnit) { return (ProductLabelOutUnit)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProductLabelOutUnit nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProductLabelOutUnit> listAll() {
            return new ArrayList<ProductLabelOutUnit>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProductLabelOutUnit> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProductLabelOutUnit." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProductLabelOutUnit> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProductLabelOutUnit> clsList = new ArrayList<ProductLabelOutUnit>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProductLabelOutUnit> groupOf(String groupName) {
            return new ArrayList<ProductLabelOutUnit>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 商品ラベル商品CDバーコード種別
     */
    public enum ProductLabelProdBarcode implements CDef {
        /** $CODE39: CODE39 */
        $CODE39("CODE39", "$CODE39", emptyStrings())
        ,
        /** $CODE128: CODE128 */
        $CODE128("CODE128", "$CODE128", emptyStrings())
        ,
        /** $CODABAR: CODABAR(NW-7) */
        $CODABAR("CODABAR", "$CODABAR", emptyStrings())
        ,
        /** $JAN: JAN(8or13) */
        $JAN("JAN", "$JAN", emptyStrings())
        ,
        /** $ITF: ITF */
        $ITF("ITF", "$ITF", emptyStrings())
        ;
        private static final Map<String, ProductLabelProdBarcode> _codeClsMap = new HashMap<String, ProductLabelProdBarcode>();
        private static final Map<String, ProductLabelProdBarcode> _nameClsMap = new HashMap<String, ProductLabelProdBarcode>();
        static {
            for (ProductLabelProdBarcode value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProductLabelProdBarcode(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProductLabelProdBarcode; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductLabelProdBarcode> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProductLabelProdBarcode) { return OptionalThing.of((ProductLabelProdBarcode)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductLabelProdBarcode> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProductLabelProdBarcode codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProductLabelProdBarcode) { return (ProductLabelProdBarcode)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProductLabelProdBarcode nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProductLabelProdBarcode> listAll() {
            return new ArrayList<ProductLabelProdBarcode>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProductLabelProdBarcode> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProductLabelProdBarcode." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProductLabelProdBarcode> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProductLabelProdBarcode> clsList = new ArrayList<ProductLabelProdBarcode>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProductLabelProdBarcode> groupOf(String groupName) {
            return new ArrayList<ProductLabelProdBarcode>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 商品毎別梱包
     */
    public enum ProductPartPacking implements CDef {
        /** $0: 不可 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 可能 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ProductPartPacking> _codeClsMap = new HashMap<String, ProductPartPacking>();
        private static final Map<String, ProductPartPacking> _nameClsMap = new HashMap<String, ProductPartPacking>();
        static {
            for (ProductPartPacking value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProductPartPacking(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProductPartPacking; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductPartPacking> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProductPartPacking) { return OptionalThing.of((ProductPartPacking)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductPartPacking> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProductPartPacking codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProductPartPacking) { return (ProductPartPacking)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProductPartPacking nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProductPartPacking> listAll() {
            return new ArrayList<ProductPartPacking>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProductPartPacking> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProductPartPacking." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProductPartPacking> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProductPartPacking> clsList = new ArrayList<ProductPartPacking>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProductPartPacking> groupOf(String groupName) {
            return new ArrayList<ProductPartPacking>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 商品種別コード
     */
    public enum ProductTypeCode implements CDef {
        /** $101: ゆうパック */
        $101("101", "$101", emptyStrings())
        ,
        /** $102: 空港ゆうパック */
        $102("102", "$102", emptyStrings())
        ,
        /** $103: チルドゆうパック */
        $103("103", "$103", emptyStrings())
        ,
        /** $105: 冷凍ゆうパック */
        $105("105", "$105", emptyStrings())
        ,
        /** $107: ゴルフゆうパック */
        $107("107", "$107", emptyStrings())
        ,
        /** $113: スキー・ホテル等ゆうパック */
        $113("113", "$113", emptyStrings())
        ,
        /** $201: 着払ゆうパック */
        $201("201", "$201", emptyStrings())
        ,
        /** $202: 着払ゆうパック(チルド) */
        $202("202", "$202", emptyStrings())
        ,
        /** $203: 着払ゆうパック(冷凍) */
        $203("203", "$203", emptyStrings())
        ,
        /** $601: 代金引換まとめ送金サービス */
        $601("601", "$601", emptyStrings())
        ,
        /** $603: 代金引換まとめ送金サービス(チルド) */
        $603("603", "$603", emptyStrings())
        ,
        /** $605: 代金引換まとめ送金サービス(冷凍) */
        $605("605", "$605", emptyStrings())
        ,
        /** $701: スキー・ホテル等ゆうパック(往路) */
        $701("701", "$701", emptyStrings())
        ,
        /** $702: 空港ゆうパック(往路) */
        $702("702", "$702", emptyStrings())
        ,
        /** $703: スキー・ホテル等ゆうパック(復路) */
        $703("703", "$703", emptyStrings())
        ,
        /** $704: 空港ゆうパック(復路) */
        $704("704", "$704", emptyStrings())
        ,
        /** $705: ゴルフゆうパック(往路) */
        $705("705", "$705", emptyStrings())
        ,
        /** $707: ゴルフゆうパック(復路) */
        $707("707", "$707", emptyStrings())
        ;
        private static final Map<String, ProductTypeCode> _codeClsMap = new HashMap<String, ProductTypeCode>();
        private static final Map<String, ProductTypeCode> _nameClsMap = new HashMap<String, ProductTypeCode>();
        static {
            for (ProductTypeCode value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProductTypeCode(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProductTypeCode; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductTypeCode> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProductTypeCode) { return OptionalThing.of((ProductTypeCode)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductTypeCode> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProductTypeCode codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProductTypeCode) { return (ProductTypeCode)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProductTypeCode nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProductTypeCode> listAll() {
            return new ArrayList<ProductTypeCode>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProductTypeCode> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProductTypeCode." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProductTypeCode> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProductTypeCode> clsList = new ArrayList<ProductTypeCode>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProductTypeCode> groupOf(String groupName) {
            return new ArrayList<ProductTypeCode>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 0非表示
     */
    public enum Qty0Display implements CDef {
        /** $0: 0表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 0非表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Qty0Display> _codeClsMap = new HashMap<String, Qty0Display>();
        private static final Map<String, Qty0Display> _nameClsMap = new HashMap<String, Qty0Display>();
        static {
            for (Qty0Display value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Qty0Display(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Qty0Display; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Qty0Display> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Qty0Display) { return OptionalThing.of((Qty0Display)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Qty0Display> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Qty0Display codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Qty0Display) { return (Qty0Display)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Qty0Display nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Qty0Display> listAll() {
            return new ArrayList<Qty0Display>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Qty0Display> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Qty0Display." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Qty0Display> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Qty0Display> clsList = new ArrayList<Qty0Display>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Qty0Display> groupOf(String groupName) {
            return new ArrayList<Qty0Display>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 変更理由
     */
    public enum ReasonType implements CDef {
        /** $0: 変更なし */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 市政・区政・町政・分区・政令指定都市施行 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 住居表示の実施 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 区画整理 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 郵便区調整等 */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 訂正 */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: 廃止 */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, ReasonType> _codeClsMap = new HashMap<String, ReasonType>();
        private static final Map<String, ReasonType> _nameClsMap = new HashMap<String, ReasonType>();
        static {
            for (ReasonType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReasonType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReasonType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReasonType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReasonType) { return OptionalThing.of((ReasonType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReasonType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReasonType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReasonType) { return (ReasonType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReasonType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReasonType> listAll() {
            return new ArrayList<ReasonType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReasonType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReasonType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReasonType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReasonType> clsList = new ArrayList<ReasonType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReasonType> groupOf(String groupName) {
            return new ArrayList<ReasonType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入荷納品ステータス
     */
    public enum ReceiveDeliveryStatus implements CDef {
        /** $00: 未完 */
        $00("00", "$00", emptyStrings())
        ,
        /** $01: 完納 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 分納 */
        $02("02", "$02", emptyStrings())
        ,
        /** $09: 打切り */
        $09("09", "$09", emptyStrings())
        ;
        private static final Map<String, ReceiveDeliveryStatus> _codeClsMap = new HashMap<String, ReceiveDeliveryStatus>();
        private static final Map<String, ReceiveDeliveryStatus> _nameClsMap = new HashMap<String, ReceiveDeliveryStatus>();
        static {
            for (ReceiveDeliveryStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReceiveDeliveryStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReceiveDeliveryStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveDeliveryStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReceiveDeliveryStatus) { return OptionalThing.of((ReceiveDeliveryStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveDeliveryStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReceiveDeliveryStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReceiveDeliveryStatus) { return (ReceiveDeliveryStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReceiveDeliveryStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReceiveDeliveryStatus> listAll() {
            return new ArrayList<ReceiveDeliveryStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReceiveDeliveryStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReceiveDeliveryStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReceiveDeliveryStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReceiveDeliveryStatus> clsList = new ArrayList<ReceiveDeliveryStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReceiveDeliveryStatus> groupOf(String groupName) {
            return new ArrayList<ReceiveDeliveryStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入荷フラグ
     */
    public enum ReceiveFlg implements CDef {
        /** $0: 入荷対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 入荷対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ReceiveFlg> _codeClsMap = new HashMap<String, ReceiveFlg>();
        private static final Map<String, ReceiveFlg> _nameClsMap = new HashMap<String, ReceiveFlg>();
        static {
            for (ReceiveFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReceiveFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReceiveFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReceiveFlg) { return OptionalThing.of((ReceiveFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReceiveFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReceiveFlg) { return (ReceiveFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReceiveFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReceiveFlg> listAll() {
            return new ArrayList<ReceiveFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReceiveFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReceiveFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReceiveFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReceiveFlg> clsList = new ArrayList<ReceiveFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReceiveFlg> groupOf(String groupName) {
            return new ArrayList<ReceiveFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入荷ステータス
     */
    public enum ReceiveStatus implements CDef {
        /** $01: 未入荷 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 入荷中 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 入荷済 */
        $03("03", "$03", emptyStrings())
        ,
        /** $90: 入荷削除 */
        $90("90", "$90", emptyStrings())
        ,
        /** $99: エラー有 */
        $99("99", "$99", emptyStrings())
        ;
        private static final Map<String, ReceiveStatus> _codeClsMap = new HashMap<String, ReceiveStatus>();
        private static final Map<String, ReceiveStatus> _nameClsMap = new HashMap<String, ReceiveStatus>();
        static {
            for (ReceiveStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReceiveStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReceiveStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReceiveStatus) { return OptionalThing.of((ReceiveStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReceiveStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReceiveStatus) { return (ReceiveStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReceiveStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReceiveStatus> listAll() {
            return new ArrayList<ReceiveStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReceiveStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReceiveStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReceiveStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReceiveStatus> clsList = new ArrayList<ReceiveStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReceiveStatus> groupOf(String groupName) {
            return new ArrayList<ReceiveStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 補充ロケ割付区分
     */
    public enum ReplenishAllocCls implements CDef {
        /** $0: バッチ毎同一SKUは同一ロケに割付 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 補充毎に別ロケを割付 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ReplenishAllocCls> _codeClsMap = new HashMap<String, ReplenishAllocCls>();
        private static final Map<String, ReplenishAllocCls> _nameClsMap = new HashMap<String, ReplenishAllocCls>();
        static {
            for (ReplenishAllocCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReplenishAllocCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReplenishAllocCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishAllocCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReplenishAllocCls) { return OptionalThing.of((ReplenishAllocCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishAllocCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReplenishAllocCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReplenishAllocCls) { return (ReplenishAllocCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReplenishAllocCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReplenishAllocCls> listAll() {
            return new ArrayList<ReplenishAllocCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReplenishAllocCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReplenishAllocCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReplenishAllocCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReplenishAllocCls> clsList = new ArrayList<ReplenishAllocCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReplenishAllocCls> groupOf(String groupName) {
            return new ArrayList<ReplenishAllocCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 補充商品CD未設定
     */
    public enum ReplenishProductCdUnset implements CDef {
        /** $1: 未設定のみ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ReplenishProductCdUnset> _codeClsMap = new HashMap<String, ReplenishProductCdUnset>();
        private static final Map<String, ReplenishProductCdUnset> _nameClsMap = new HashMap<String, ReplenishProductCdUnset>();
        static {
            for (ReplenishProductCdUnset value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReplenishProductCdUnset(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReplenishProductCdUnset; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishProductCdUnset> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReplenishProductCdUnset) { return OptionalThing.of((ReplenishProductCdUnset)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishProductCdUnset> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReplenishProductCdUnset codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReplenishProductCdUnset) { return (ReplenishProductCdUnset)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReplenishProductCdUnset nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReplenishProductCdUnset> listAll() {
            return new ArrayList<ReplenishProductCdUnset>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReplenishProductCdUnset> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReplenishProductCdUnset." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReplenishProductCdUnset> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReplenishProductCdUnset> clsList = new ArrayList<ReplenishProductCdUnset>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReplenishProductCdUnset> groupOf(String groupName) {
            return new ArrayList<ReplenishProductCdUnset>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 補充点検索区分
     */
    public enum ReplenishSearchCls implements CDef {
        /** $0: 補充点以下 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 補充可能 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 全て */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, ReplenishSearchCls> _codeClsMap = new HashMap<String, ReplenishSearchCls>();
        private static final Map<String, ReplenishSearchCls> _nameClsMap = new HashMap<String, ReplenishSearchCls>();
        static {
            for (ReplenishSearchCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReplenishSearchCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReplenishSearchCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishSearchCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReplenishSearchCls) { return OptionalThing.of((ReplenishSearchCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishSearchCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReplenishSearchCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReplenishSearchCls) { return (ReplenishSearchCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReplenishSearchCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReplenishSearchCls> listAll() {
            return new ArrayList<ReplenishSearchCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReplenishSearchCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReplenishSearchCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReplenishSearchCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReplenishSearchCls> clsList = new ArrayList<ReplenishSearchCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReplenishSearchCls> groupOf(String groupName) {
            return new ArrayList<ReplenishSearchCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 補充単位区分
     */
    public enum ReplenishUnitCls implements CDef {
        /** $0: 必要数 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 最大格納数荷姿切上 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ReplenishUnitCls> _codeClsMap = new HashMap<String, ReplenishUnitCls>();
        private static final Map<String, ReplenishUnitCls> _nameClsMap = new HashMap<String, ReplenishUnitCls>();
        static {
            for (ReplenishUnitCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReplenishUnitCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReplenishUnitCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishUnitCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReplenishUnitCls) { return OptionalThing.of((ReplenishUnitCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishUnitCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReplenishUnitCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReplenishUnitCls) { return (ReplenishUnitCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReplenishUnitCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReplenishUnitCls> listAll() {
            return new ArrayList<ReplenishUnitCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReplenishUnitCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReplenishUnitCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReplenishUnitCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReplenishUnitCls> clsList = new ArrayList<ReplenishUnitCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReplenishUnitCls> groupOf(String groupName) {
            return new ArrayList<ReplenishUnitCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 項目型
     */
    public enum ReportLayoutItemType implements CDef {
        /** $0: 固定項目 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出力項目 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ReportLayoutItemType> _codeClsMap = new HashMap<String, ReportLayoutItemType>();
        private static final Map<String, ReportLayoutItemType> _nameClsMap = new HashMap<String, ReportLayoutItemType>();
        static {
            for (ReportLayoutItemType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReportLayoutItemType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReportLayoutItemType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReportLayoutItemType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReportLayoutItemType) { return OptionalThing.of((ReportLayoutItemType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReportLayoutItemType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReportLayoutItemType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReportLayoutItemType) { return (ReportLayoutItemType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReportLayoutItemType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReportLayoutItemType> listAll() {
            return new ArrayList<ReportLayoutItemType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReportLayoutItemType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReportLayoutItemType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReportLayoutItemType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReportLayoutItemType> clsList = new ArrayList<ReportLayoutItemType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReportLayoutItemType> groupOf(String groupName) {
            return new ArrayList<ReportLayoutItemType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 補充種別
     */
    public enum RestockType implements CDef {
        /** $0: 定期 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 緊急 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, RestockType> _codeClsMap = new HashMap<String, RestockType>();
        private static final Map<String, RestockType> _nameClsMap = new HashMap<String, RestockType>();
        static {
            for (RestockType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private RestockType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.RestockType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RestockType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof RestockType) { return OptionalThing.of((RestockType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RestockType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static RestockType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof RestockType) { return (RestockType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static RestockType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<RestockType> listAll() {
            return new ArrayList<RestockType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<RestockType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: RestockType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<RestockType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<RestockType> clsList = new ArrayList<RestockType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<RestockType> groupOf(String groupName) {
            return new ArrayList<RestockType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 実績入力後入庫/商品ラベル出力
     */
    public enum ResultAfterProductLabel implements CDef {
        /** $0: 出力しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 画面で実績入力後のみ出力 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: HT/SDで実績入力後のみ出力 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 出力する */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, ResultAfterProductLabel> _codeClsMap = new HashMap<String, ResultAfterProductLabel>();
        private static final Map<String, ResultAfterProductLabel> _nameClsMap = new HashMap<String, ResultAfterProductLabel>();
        static {
            for (ResultAfterProductLabel value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ResultAfterProductLabel(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ResultAfterProductLabel; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResultAfterProductLabel> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ResultAfterProductLabel) { return OptionalThing.of((ResultAfterProductLabel)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResultAfterProductLabel> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ResultAfterProductLabel codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ResultAfterProductLabel) { return (ResultAfterProductLabel)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ResultAfterProductLabel nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ResultAfterProductLabel> listAll() {
            return new ArrayList<ResultAfterProductLabel>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ResultAfterProductLabel> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ResultAfterProductLabel." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ResultAfterProductLabel> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ResultAfterProductLabel> clsList = new ArrayList<ResultAfterProductLabel>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ResultAfterProductLabel> groupOf(String groupName) {
            return new ArrayList<ResultAfterProductLabel>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 期限日出荷制限フラグ
     */
    public enum ReverseValidFlg implements CDef {
        /** $0: 無効 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 有効 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ReverseValidFlg> _codeClsMap = new HashMap<String, ReverseValidFlg>();
        private static final Map<String, ReverseValidFlg> _nameClsMap = new HashMap<String, ReverseValidFlg>();
        static {
            for (ReverseValidFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReverseValidFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReverseValidFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReverseValidFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReverseValidFlg) { return OptionalThing.of((ReverseValidFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReverseValidFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReverseValidFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReverseValidFlg) { return (ReverseValidFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReverseValidFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReverseValidFlg> listAll() {
            return new ArrayList<ReverseValidFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReverseValidFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReverseValidFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReverseValidFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReverseValidFlg> clsList = new ArrayList<ReverseValidFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReverseValidFlg> groupOf(String groupName) {
            return new ArrayList<ReverseValidFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 選択
     */
    public enum Select implements CDef {
        /** $0: 選択しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 選択する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Select> _codeClsMap = new HashMap<String, Select>();
        private static final Map<String, Select> _nameClsMap = new HashMap<String, Select>();
        static {
            for (Select value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Select(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Select; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Select> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Select) { return OptionalThing.of((Select)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Select> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Select codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Select) { return (Select)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Select nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Select> listAll() {
            return new ArrayList<Select>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Select> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Select." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Select> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Select> clsList = new ArrayList<Select>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Select> groupOf(String groupName) {
            return new ArrayList<Select>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 印刷サービスステータス
     */
    public enum SelectPrintServiceStatus implements CDef {
        /** $0: サービス中 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: サービス停止中 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SelectPrintServiceStatus> _codeClsMap = new HashMap<String, SelectPrintServiceStatus>();
        private static final Map<String, SelectPrintServiceStatus> _nameClsMap = new HashMap<String, SelectPrintServiceStatus>();
        static {
            for (SelectPrintServiceStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SelectPrintServiceStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SelectPrintServiceStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SelectPrintServiceStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SelectPrintServiceStatus) { return OptionalThing.of((SelectPrintServiceStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SelectPrintServiceStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SelectPrintServiceStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SelectPrintServiceStatus) { return (SelectPrintServiceStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SelectPrintServiceStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SelectPrintServiceStatus> listAll() {
            return new ArrayList<SelectPrintServiceStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SelectPrintServiceStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SelectPrintServiceStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SelectPrintServiceStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SelectPrintServiceStatus> clsList = new ArrayList<SelectPrintServiceStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SelectPrintServiceStatus> groupOf(String groupName) {
            return new ArrayList<SelectPrintServiceStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 処理区分
     */
    public enum SerialOperationType implements CDef {
        /** $1: 入荷 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 出荷 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 削除 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, SerialOperationType> _codeClsMap = new HashMap<String, SerialOperationType>();
        private static final Map<String, SerialOperationType> _nameClsMap = new HashMap<String, SerialOperationType>();
        static {
            for (SerialOperationType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SerialOperationType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SerialOperationType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SerialOperationType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SerialOperationType) { return OptionalThing.of((SerialOperationType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SerialOperationType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SerialOperationType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SerialOperationType) { return (SerialOperationType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SerialOperationType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SerialOperationType> listAll() {
            return new ArrayList<SerialOperationType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SerialOperationType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SerialOperationType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SerialOperationType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SerialOperationType> clsList = new ArrayList<SerialOperationType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SerialOperationType> groupOf(String groupName) {
            return new ArrayList<SerialOperationType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ターゲットウインドウ
     */
    public enum TargetWindow implements CDef {
        /** $0: 同一ウインドウで開く */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 別ウインドウを新規で開く */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 別ウインドウを同一画面で開く */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, TargetWindow> _codeClsMap = new HashMap<String, TargetWindow>();
        private static final Map<String, TargetWindow> _nameClsMap = new HashMap<String, TargetWindow>();
        static {
            for (TargetWindow value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TargetWindow(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TargetWindow; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TargetWindow> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TargetWindow) { return OptionalThing.of((TargetWindow)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TargetWindow> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TargetWindow codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TargetWindow) { return (TargetWindow)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TargetWindow nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TargetWindow> listAll() {
            return new ArrayList<TargetWindow>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TargetWindow> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TargetWindow." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TargetWindow> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TargetWindow> clsList = new ArrayList<TargetWindow>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TargetWindow> groupOf(String groupName) {
            return new ArrayList<TargetWindow>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 決済種別
     */
    public enum SettlementType implements CDef {
        /** $0: 指定なし */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 全て可 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 現金のみ */
        $2("2", "$2", emptyStrings())
        ,
        /** $5: ﾃﾞﾋﾞｯﾄ･ｸﾚｼﾞｯﾄ */
        $5("5", "$5", emptyStrings())
        ;
        private static final Map<String, SettlementType> _codeClsMap = new HashMap<String, SettlementType>();
        private static final Map<String, SettlementType> _nameClsMap = new HashMap<String, SettlementType>();
        static {
            for (SettlementType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SettlementType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SettlementType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SettlementType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SettlementType) { return OptionalThing.of((SettlementType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SettlementType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SettlementType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SettlementType) { return (SettlementType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SettlementType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SettlementType> listAll() {
            return new ArrayList<SettlementType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SettlementType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SettlementType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SettlementType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SettlementType> clsList = new ArrayList<SettlementType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SettlementType> groupOf(String groupName) {
            return new ArrayList<SettlementType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 単行出荷検品荷札/納品明細出力区分
     */
    public enum SglRowInspAfterOutCls implements CDef {
        /** $1: 最初の商品検品後に出力 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 随時出力 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 最後の商品検品後に出力 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, SglRowInspAfterOutCls> _codeClsMap = new HashMap<String, SglRowInspAfterOutCls>();
        private static final Map<String, SglRowInspAfterOutCls> _nameClsMap = new HashMap<String, SglRowInspAfterOutCls>();
        static {
            for (SglRowInspAfterOutCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SglRowInspAfterOutCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SglRowInspAfterOutCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SglRowInspAfterOutCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SglRowInspAfterOutCls) { return OptionalThing.of((SglRowInspAfterOutCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SglRowInspAfterOutCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SglRowInspAfterOutCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SglRowInspAfterOutCls) { return (SglRowInspAfterOutCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SglRowInspAfterOutCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SglRowInspAfterOutCls> listAll() {
            return new ArrayList<SglRowInspAfterOutCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SglRowInspAfterOutCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SglRowInspAfterOutCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SglRowInspAfterOutCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SglRowInspAfterOutCls> clsList = new ArrayList<SglRowInspAfterOutCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SglRowInspAfterOutCls> groupOf(String groupName) {
            return new ArrayList<SglRowInspAfterOutCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 単行ピックフラグ
     */
    public enum SglRowPicFlg implements CDef {
        /** $0: 単行ピック無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 単行ピック有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SglRowPicFlg> _codeClsMap = new HashMap<String, SglRowPicFlg>();
        private static final Map<String, SglRowPicFlg> _nameClsMap = new HashMap<String, SglRowPicFlg>();
        static {
            for (SglRowPicFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SglRowPicFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SglRowPicFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SglRowPicFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SglRowPicFlg) { return OptionalThing.of((SglRowPicFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SglRowPicFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SglRowPicFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SglRowPicFlg) { return (SglRowPicFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SglRowPicFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SglRowPicFlg> listAll() {
            return new ArrayList<SglRowPicFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SglRowPicFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SglRowPicFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SglRowPicFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SglRowPicFlg> clsList = new ArrayList<SglRowPicFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SglRowPicFlg> groupOf(String groupName) {
            return new ArrayList<SglRowPicFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 部単位印刷要否
     */
    public enum SheetCollate implements CDef {
        /** $0: ページ毎印刷 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 部単位で印刷 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SheetCollate> _codeClsMap = new HashMap<String, SheetCollate>();
        private static final Map<String, SheetCollate> _nameClsMap = new HashMap<String, SheetCollate>();
        static {
            for (SheetCollate value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SheetCollate(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SheetCollate; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SheetCollate> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SheetCollate) { return OptionalThing.of((SheetCollate)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SheetCollate> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SheetCollate codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SheetCollate) { return (SheetCollate)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SheetCollate nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SheetCollate> listAll() {
            return new ArrayList<SheetCollate>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SheetCollate> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SheetCollate." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SheetCollate> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SheetCollate> clsList = new ArrayList<SheetCollate>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SheetCollate> groupOf(String groupName) {
            return new ArrayList<SheetCollate>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷フラグ
     */
    public enum ShippingFlg implements CDef {
        /** $0: 出荷対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出荷対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ShippingFlg> _codeClsMap = new HashMap<String, ShippingFlg>();
        private static final Map<String, ShippingFlg> _nameClsMap = new HashMap<String, ShippingFlg>();
        static {
            for (ShippingFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingFlg) { return OptionalThing.of((ShippingFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingFlg) { return (ShippingFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingFlg> listAll() {
            return new ArrayList<ShippingFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingFlg> clsList = new ArrayList<ShippingFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingFlg> groupOf(String groupName) {
            return new ArrayList<ShippingFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷ステータス
     */
    public enum ShippingStatus implements CDef {
        /** $10: 未出荷 */
        $10("10", "$10", emptyStrings())
        ,
        /** $15: 出庫指示中 */
        $15("15", "$15", emptyStrings())
        ,
        /** $20: 出庫指示解除中 */
        $20("20", "$20", emptyStrings())
        ,
        /** $25: 出庫指示済 */
        $25("25", "$25", emptyStrings())
        ,
        /** $30: ピッキング中 */
        $30("30", "$30", emptyStrings())
        ,
        /** $35: ピッキング済 */
        $35("35", "$35", emptyStrings())
        ,
        /** $40: 出荷検品中 */
        $40("40", "$40", emptyStrings())
        ,
        /** $45: 出荷検品中断 */
        $45("45", "$45", emptyStrings())
        ,
        /** $50: 出荷検品済 */
        $50("50", "$50", emptyStrings())
        ,
        /** $55: 出荷確定済 */
        $55("55", "$55", emptyStrings())
        ,
        /** $60: 承認待ち */
        $60("60", "$60", emptyStrings())
        ,
        /** $90: キャンセル */
        $90("90", "$90", emptyStrings())
        ,
        /** $99: エラー有 */
        $99("99", "$99", emptyStrings())
        ;
        private static final Map<String, ShippingStatus> _codeClsMap = new HashMap<String, ShippingStatus>();
        private static final Map<String, ShippingStatus> _nameClsMap = new HashMap<String, ShippingStatus>();
        static {
            for (ShippingStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingStatus) { return OptionalThing.of((ShippingStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingStatus) { return (ShippingStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingStatus> listAll() {
            return new ArrayList<ShippingStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingStatus> clsList = new ArrayList<ShippingStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingStatus> groupOf(String groupName) {
            return new ArrayList<ShippingStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷停止フラグ
     */
    public enum ShippingStopFlg implements CDef {
        /** $1: 出荷停止 */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: 出荷可能 */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, ShippingStopFlg> _codeClsMap = new HashMap<String, ShippingStopFlg>();
        private static final Map<String, ShippingStopFlg> _nameClsMap = new HashMap<String, ShippingStopFlg>();
        static {
            for (ShippingStopFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingStopFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingStopFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingStopFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingStopFlg) { return OptionalThing.of((ShippingStopFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingStopFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingStopFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingStopFlg) { return (ShippingStopFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingStopFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingStopFlg> listAll() {
            return new ArrayList<ShippingStopFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingStopFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingStopFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingStopFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingStopFlg> clsList = new ArrayList<ShippingStopFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingStopFlg> groupOf(String groupName) {
            return new ArrayList<ShippingStopFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 欠品表示区分
     */
    public enum ShortStockDisplay implements CDef {
        /** $0: 全件表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 欠品のみ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ShortStockDisplay> _codeClsMap = new HashMap<String, ShortStockDisplay>();
        private static final Map<String, ShortStockDisplay> _nameClsMap = new HashMap<String, ShortStockDisplay>();
        static {
            for (ShortStockDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShortStockDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShortStockDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShortStockDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShortStockDisplay) { return OptionalThing.of((ShortStockDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShortStockDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShortStockDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShortStockDisplay) { return (ShortStockDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShortStockDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShortStockDisplay> listAll() {
            return new ArrayList<ShortStockDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShortStockDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShortStockDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShortStockDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShortStockDisplay> clsList = new ArrayList<ShortStockDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShortStockDisplay> groupOf(String groupName) {
            return new ArrayList<ShortStockDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷検品区分
     */
    public enum ShpCheckCls implements CDef {
        /** $0: ピース検品 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ケース検品 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ShpCheckCls> _codeClsMap = new HashMap<String, ShpCheckCls>();
        private static final Map<String, ShpCheckCls> _nameClsMap = new HashMap<String, ShpCheckCls>();
        static {
            for (ShpCheckCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShpCheckCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShpCheckCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShpCheckCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShpCheckCls) { return OptionalThing.of((ShpCheckCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShpCheckCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShpCheckCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShpCheckCls) { return (ShpCheckCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShpCheckCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShpCheckCls> listAll() {
            return new ArrayList<ShpCheckCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShpCheckCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShpCheckCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShpCheckCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShpCheckCls> clsList = new ArrayList<ShpCheckCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShpCheckCls> groupOf(String groupName) {
            return new ArrayList<ShpCheckCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 未検品表示区分
     */
    public enum ShpCheckDisplay implements CDef {
        /** $0: 全件表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 未検品のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ShpCheckDisplay> _codeClsMap = new HashMap<String, ShpCheckDisplay>();
        private static final Map<String, ShpCheckDisplay> _nameClsMap = new HashMap<String, ShpCheckDisplay>();
        static {
            for (ShpCheckDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShpCheckDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShpCheckDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShpCheckDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShpCheckDisplay) { return OptionalThing.of((ShpCheckDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShpCheckDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShpCheckDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShpCheckDisplay) { return (ShpCheckDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShpCheckDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShpCheckDisplay> listAll() {
            return new ArrayList<ShpCheckDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShpCheckDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShpCheckDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShpCheckDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShpCheckDisplay> clsList = new ArrayList<ShpCheckDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShpCheckDisplay> groupOf(String groupName) {
            return new ArrayList<ShpCheckDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送り状種別
     */
    public enum SlipType implements CDef {
        /** $0: 発払い */
        $0("0", "$0", emptyStrings())
        ,
        /** $2: コレクト */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: メール便 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: タイム */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 着払い */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: メール便速達サービス */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, SlipType> _codeClsMap = new HashMap<String, SlipType>();
        private static final Map<String, SlipType> _nameClsMap = new HashMap<String, SlipType>();
        static {
            for (SlipType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SlipType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SlipType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SlipType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SlipType) { return OptionalThing.of((SlipType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SlipType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SlipType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SlipType) { return (SlipType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SlipType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SlipType> listAll() {
            return new ArrayList<SlipType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SlipType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SlipType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SlipType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SlipType> clsList = new ArrayList<SlipType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SlipType> groupOf(String groupName) {
            return new ArrayList<SlipType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 操作音再生フラグ
     */
    public enum SoundPlayFlg implements CDef {
        /** $0: 再生しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 再生する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SoundPlayFlg> _codeClsMap = new HashMap<String, SoundPlayFlg>();
        private static final Map<String, SoundPlayFlg> _nameClsMap = new HashMap<String, SoundPlayFlg>();
        static {
            for (SoundPlayFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SoundPlayFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SoundPlayFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SoundPlayFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SoundPlayFlg) { return OptionalThing.of((SoundPlayFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SoundPlayFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SoundPlayFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SoundPlayFlg) { return (SoundPlayFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SoundPlayFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SoundPlayFlg> listAll() {
            return new ArrayList<SoundPlayFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SoundPlayFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SoundPlayFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SoundPlayFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SoundPlayFlg> clsList = new ArrayList<SoundPlayFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SoundPlayFlg> groupOf(String groupName) {
            return new ArrayList<SoundPlayFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫調整フラグ
     */
    public enum StockAdjustFlg implements CDef {
        /** $0: 在庫調整対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 在庫調整対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockAdjustFlg> _codeClsMap = new HashMap<String, StockAdjustFlg>();
        private static final Map<String, StockAdjustFlg> _nameClsMap = new HashMap<String, StockAdjustFlg>();
        static {
            for (StockAdjustFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockAdjustFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockAdjustFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockAdjustFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockAdjustFlg) { return OptionalThing.of((StockAdjustFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockAdjustFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockAdjustFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockAdjustFlg) { return (StockAdjustFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockAdjustFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockAdjustFlg> listAll() {
            return new ArrayList<StockAdjustFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockAdjustFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockAdjustFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockAdjustFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockAdjustFlg> clsList = new ArrayList<StockAdjustFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockAdjustFlg> groupOf(String groupName) {
            return new ArrayList<StockAdjustFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫表示内容
     */
    public enum StockDisplayFld implements CDef {
        /** $0: 商品順（日報なし） */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 商品順（日報あり） */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ロケーション順（日報なし） */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: ロケーション順（日報あり） */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, StockDisplayFld> _codeClsMap = new HashMap<String, StockDisplayFld>();
        private static final Map<String, StockDisplayFld> _nameClsMap = new HashMap<String, StockDisplayFld>();
        static {
            for (StockDisplayFld value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockDisplayFld(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockDisplayFld; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockDisplayFld> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockDisplayFld) { return OptionalThing.of((StockDisplayFld)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockDisplayFld> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockDisplayFld codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockDisplayFld) { return (StockDisplayFld)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockDisplayFld nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockDisplayFld> listAll() {
            return new ArrayList<StockDisplayFld>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockDisplayFld> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockDisplayFld." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockDisplayFld> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockDisplayFld> clsList = new ArrayList<StockDisplayFld>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockDisplayFld> groupOf(String groupName) {
            return new ArrayList<StockDisplayFld>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫有のみフラグ
     */
    public enum StockExistOnlyFlg implements CDef {
        /** $0: 全て */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 在庫有のみ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockExistOnlyFlg> _codeClsMap = new HashMap<String, StockExistOnlyFlg>();
        private static final Map<String, StockExistOnlyFlg> _nameClsMap = new HashMap<String, StockExistOnlyFlg>();
        static {
            for (StockExistOnlyFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockExistOnlyFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockExistOnlyFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockExistOnlyFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockExistOnlyFlg) { return OptionalThing.of((StockExistOnlyFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockExistOnlyFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockExistOnlyFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockExistOnlyFlg) { return (StockExistOnlyFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockExistOnlyFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockExistOnlyFlg> listAll() {
            return new ArrayList<StockExistOnlyFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockExistOnlyFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockExistOnlyFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockExistOnlyFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockExistOnlyFlg> clsList = new ArrayList<StockExistOnlyFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockExistOnlyFlg> groupOf(String groupName) {
            return new ArrayList<StockExistOnlyFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫調整フラグ
     */
    public enum StockMoveFlg implements CDef {
        /** $0: 未調整 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 調整済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockMoveFlg> _codeClsMap = new HashMap<String, StockMoveFlg>();
        private static final Map<String, StockMoveFlg> _nameClsMap = new HashMap<String, StockMoveFlg>();
        static {
            for (StockMoveFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockMoveFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockMoveFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockMoveFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockMoveFlg) { return OptionalThing.of((StockMoveFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockMoveFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockMoveFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockMoveFlg) { return (StockMoveFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockMoveFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockMoveFlg> listAll() {
            return new ArrayList<StockMoveFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockMoveFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockMoveFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockMoveFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockMoveFlg> clsList = new ArrayList<StockMoveFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockMoveFlg> groupOf(String groupName) {
            return new ArrayList<StockMoveFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫数 0非表示
     */
    public enum StockNum0Display implements CDef {
        /** $0: 0表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 0非表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockNum0Display> _codeClsMap = new HashMap<String, StockNum0Display>();
        private static final Map<String, StockNum0Display> _nameClsMap = new HashMap<String, StockNum0Display>();
        static {
            for (StockNum0Display value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockNum0Display(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockNum0Display; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockNum0Display> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockNum0Display) { return OptionalThing.of((StockNum0Display)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockNum0Display> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockNum0Display codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockNum0Display) { return (StockNum0Display)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockNum0Display nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockNum0Display> listAll() {
            return new ArrayList<StockNum0Display>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockNum0Display> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockNum0Display." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockNum0Display> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockNum0Display> clsList = new ArrayList<StockNum0Display>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockNum0Display> groupOf(String groupName) {
            return new ArrayList<StockNum0Display>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 欠品時引当区分
     */
    public enum StockOutAllocCls implements CDef {
        /** $0: 引当可能数を引当 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 商品毎に0引当 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 納品先毎に0引当 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, StockOutAllocCls> _codeClsMap = new HashMap<String, StockOutAllocCls>();
        private static final Map<String, StockOutAllocCls> _nameClsMap = new HashMap<String, StockOutAllocCls>();
        static {
            for (StockOutAllocCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockOutAllocCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockOutAllocCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutAllocCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockOutAllocCls) { return OptionalThing.of((StockOutAllocCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutAllocCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockOutAllocCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockOutAllocCls) { return (StockOutAllocCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockOutAllocCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockOutAllocCls> listAll() {
            return new ArrayList<StockOutAllocCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockOutAllocCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockOutAllocCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockOutAllocCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockOutAllocCls> clsList = new ArrayList<StockOutAllocCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockOutAllocCls> groupOf(String groupName) {
            return new ArrayList<StockOutAllocCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 欠品時自動出庫指示フラグ
     */
    public enum StockOutAutoInstFlg implements CDef {
        /** $0: 自動出庫指示に含めない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 自動出庫指示に含める */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockOutAutoInstFlg> _codeClsMap = new HashMap<String, StockOutAutoInstFlg>();
        private static final Map<String, StockOutAutoInstFlg> _nameClsMap = new HashMap<String, StockOutAutoInstFlg>();
        static {
            for (StockOutAutoInstFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockOutAutoInstFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockOutAutoInstFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutAutoInstFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockOutAutoInstFlg) { return OptionalThing.of((StockOutAutoInstFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutAutoInstFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockOutAutoInstFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockOutAutoInstFlg) { return (StockOutAutoInstFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockOutAutoInstFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockOutAutoInstFlg> listAll() {
            return new ArrayList<StockOutAutoInstFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockOutAutoInstFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockOutAutoInstFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockOutAutoInstFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockOutAutoInstFlg> clsList = new ArrayList<StockOutAutoInstFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockOutAutoInstFlg> groupOf(String groupName) {
            return new ArrayList<StockOutAutoInstFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 欠品フラグ
     */
    public enum StockOutFlg implements CDef {
        /** $0: 欠品無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 欠品有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockOutFlg> _codeClsMap = new HashMap<String, StockOutFlg>();
        private static final Map<String, StockOutFlg> _nameClsMap = new HashMap<String, StockOutFlg>();
        static {
            for (StockOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockOutFlg) { return OptionalThing.of((StockOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockOutFlg) { return (StockOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockOutFlg> listAll() {
            return new ArrayList<StockOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockOutFlg> clsList = new ArrayList<StockOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockOutFlg> groupOf(String groupName) {
            return new ArrayList<StockOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 欠品時出庫指示取消フラグ
     */
    public enum StockOutInstCxlFlg implements CDef {
        /** $0: 出庫指示を取消しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出庫指示を取消 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockOutInstCxlFlg> _codeClsMap = new HashMap<String, StockOutInstCxlFlg>();
        private static final Map<String, StockOutInstCxlFlg> _nameClsMap = new HashMap<String, StockOutInstCxlFlg>();
        static {
            for (StockOutInstCxlFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockOutInstCxlFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockOutInstCxlFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutInstCxlFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockOutInstCxlFlg) { return OptionalThing.of((StockOutInstCxlFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutInstCxlFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockOutInstCxlFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockOutInstCxlFlg) { return (StockOutInstCxlFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockOutInstCxlFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockOutInstCxlFlg> listAll() {
            return new ArrayList<StockOutInstCxlFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockOutInstCxlFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockOutInstCxlFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockOutInstCxlFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockOutInstCxlFlg> clsList = new ArrayList<StockOutInstCxlFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockOutInstCxlFlg> groupOf(String groupName) {
            return new ArrayList<StockOutInstCxlFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 欠品時出荷指示分離フラグ
     */
    public enum StockOutInstSplitFlg implements CDef {
        /** $0: 分離しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 分離する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockOutInstSplitFlg> _codeClsMap = new HashMap<String, StockOutInstSplitFlg>();
        private static final Map<String, StockOutInstSplitFlg> _nameClsMap = new HashMap<String, StockOutInstSplitFlg>();
        static {
            for (StockOutInstSplitFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockOutInstSplitFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockOutInstSplitFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutInstSplitFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockOutInstSplitFlg) { return OptionalThing.of((StockOutInstSplitFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockOutInstSplitFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockOutInstSplitFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockOutInstSplitFlg) { return (StockOutInstSplitFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockOutInstSplitFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockOutInstSplitFlg> listAll() {
            return new ArrayList<StockOutInstSplitFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockOutInstSplitFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockOutInstSplitFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockOutInstSplitFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockOutInstSplitFlg> clsList = new ArrayList<StockOutInstSplitFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockOutInstSplitFlg> groupOf(String groupName) {
            return new ArrayList<StockOutInstSplitFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫数表示
     */
    public enum StockQtyDisplay implements CDef {
        /** $0: 表示しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 表示する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockQtyDisplay> _codeClsMap = new HashMap<String, StockQtyDisplay>();
        private static final Map<String, StockQtyDisplay> _nameClsMap = new HashMap<String, StockQtyDisplay>();
        static {
            for (StockQtyDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockQtyDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockQtyDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockQtyDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockQtyDisplay) { return OptionalThing.of((StockQtyDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockQtyDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockQtyDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockQtyDisplay) { return (StockQtyDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockQtyDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockQtyDisplay> listAll() {
            return new ArrayList<StockQtyDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockQtyDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockQtyDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockQtyDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockQtyDisplay> clsList = new ArrayList<StockQtyDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockQtyDisplay> groupOf(String groupName) {
            return new ArrayList<StockQtyDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 棚卸データ有
     */
    public enum StockTakingInput implements CDef {
        /** $1: 棚卸入力有のみ表示 */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: 棚卸入力無のみ表示 */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, StockTakingInput> _codeClsMap = new HashMap<String, StockTakingInput>();
        private static final Map<String, StockTakingInput> _nameClsMap = new HashMap<String, StockTakingInput>();
        static {
            for (StockTakingInput value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockTakingInput(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockTakingInput; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockTakingInput> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockTakingInput) { return OptionalThing.of((StockTakingInput)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockTakingInput> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockTakingInput codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockTakingInput) { return (StockTakingInput)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockTakingInput nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockTakingInput> listAll() {
            return new ArrayList<StockTakingInput>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockTakingInput> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockTakingInput." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockTakingInput> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockTakingInput> clsList = new ArrayList<StockTakingInput>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockTakingInput> groupOf(String groupName) {
            return new ArrayList<StockTakingInput>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫対象
     */
    public enum StockTarget implements CDef {
        /** $0: 全部対象 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 引当可能数＋引当済数＞０ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockTarget> _codeClsMap = new HashMap<String, StockTarget>();
        private static final Map<String, StockTarget> _nameClsMap = new HashMap<String, StockTarget>();
        static {
            for (StockTarget value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockTarget(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockTarget; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockTarget> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockTarget) { return OptionalThing.of((StockTarget)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockTarget> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockTarget codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockTarget) { return (StockTarget)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockTarget nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockTarget> listAll() {
            return new ArrayList<StockTarget>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockTarget> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockTarget." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockTarget> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockTarget> clsList = new ArrayList<StockTarget>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockTarget> groupOf(String groupName) {
            return new ArrayList<StockTarget>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入庫日管理フラグ
     */
    public enum StoreDtFlg implements CDef {
        /** $0: 管理しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 管理する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StoreDtFlg> _codeClsMap = new HashMap<String, StoreDtFlg>();
        private static final Map<String, StoreDtFlg> _nameClsMap = new HashMap<String, StoreDtFlg>();
        static {
            for (StoreDtFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StoreDtFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StoreDtFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreDtFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StoreDtFlg) { return OptionalThing.of((StoreDtFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreDtFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StoreDtFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StoreDtFlg) { return (StoreDtFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StoreDtFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StoreDtFlg> listAll() {
            return new ArrayList<StoreDtFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StoreDtFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StoreDtFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StoreDtFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StoreDtFlg> clsList = new ArrayList<StoreDtFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StoreDtFlg> groupOf(String groupName) {
            return new ArrayList<StoreDtFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 格納フラグ
     */
    public enum StoreFlg implements CDef {
        /** $0: 未格納 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 格納 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StoreFlg> _codeClsMap = new HashMap<String, StoreFlg>();
        private static final Map<String, StoreFlg> _nameClsMap = new HashMap<String, StoreFlg>();
        static {
            for (StoreFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StoreFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StoreFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StoreFlg) { return OptionalThing.of((StoreFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StoreFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StoreFlg) { return (StoreFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StoreFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StoreFlg> listAll() {
            return new ArrayList<StoreFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StoreFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StoreFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StoreFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StoreFlg> clsList = new ArrayList<StoreFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StoreFlg> groupOf(String groupName) {
            return new ArrayList<StoreFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入庫No.分割表示
     */
    public enum StoreNoDivideDisplay implements CDef {
        /** $0: 表示しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 表示する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StoreNoDivideDisplay> _codeClsMap = new HashMap<String, StoreNoDivideDisplay>();
        private static final Map<String, StoreNoDivideDisplay> _nameClsMap = new HashMap<String, StoreNoDivideDisplay>();
        static {
            for (StoreNoDivideDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StoreNoDivideDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StoreNoDivideDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreNoDivideDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StoreNoDivideDisplay) { return OptionalThing.of((StoreNoDivideDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreNoDivideDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StoreNoDivideDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StoreNoDivideDisplay) { return (StoreNoDivideDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StoreNoDivideDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StoreNoDivideDisplay> listAll() {
            return new ArrayList<StoreNoDivideDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StoreNoDivideDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StoreNoDivideDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StoreNoDivideDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StoreNoDivideDisplay> clsList = new ArrayList<StoreNoDivideDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StoreNoDivideDisplay> groupOf(String groupName) {
            return new ArrayList<StoreNoDivideDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入庫No.管理フラグ
     */
    public enum StoreNoFlg implements CDef {
        /** $0: 管理しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 管理する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StoreNoFlg> _codeClsMap = new HashMap<String, StoreNoFlg>();
        private static final Map<String, StoreNoFlg> _nameClsMap = new HashMap<String, StoreNoFlg>();
        static {
            for (StoreNoFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StoreNoFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StoreNoFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreNoFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StoreNoFlg) { return OptionalThing.of((StoreNoFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreNoFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StoreNoFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StoreNoFlg) { return (StoreNoFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StoreNoFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StoreNoFlg> listAll() {
            return new ArrayList<StoreNoFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StoreNoFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StoreNoFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StoreNoFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StoreNoFlg> clsList = new ArrayList<StoreNoFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StoreNoFlg> groupOf(String groupName) {
            return new ArrayList<StoreNoFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入庫No.マージフラグ
     */
    public enum StoreNoMergeFlg implements CDef {
        /** $0: マージしない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: マージする */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StoreNoMergeFlg> _codeClsMap = new HashMap<String, StoreNoMergeFlg>();
        private static final Map<String, StoreNoMergeFlg> _nameClsMap = new HashMap<String, StoreNoMergeFlg>();
        static {
            for (StoreNoMergeFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StoreNoMergeFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StoreNoMergeFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreNoMergeFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StoreNoMergeFlg) { return OptionalThing.of((StoreNoMergeFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StoreNoMergeFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StoreNoMergeFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StoreNoMergeFlg) { return (StoreNoMergeFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StoreNoMergeFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StoreNoMergeFlg> listAll() {
            return new ArrayList<StoreNoMergeFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StoreNoMergeFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StoreNoMergeFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StoreNoMergeFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StoreNoMergeFlg> clsList = new ArrayList<StoreNoMergeFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StoreNoMergeFlg> groupOf(String groupName) {
            return new ArrayList<StoreNoMergeFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * システムログステータス
     */
    public enum SystemLogStatus implements CDef {
        /** $1: 正常 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 異常 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, SystemLogStatus> _codeClsMap = new HashMap<String, SystemLogStatus>();
        private static final Map<String, SystemLogStatus> _nameClsMap = new HashMap<String, SystemLogStatus>();
        static {
            for (SystemLogStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SystemLogStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SystemLogStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SystemLogStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SystemLogStatus) { return OptionalThing.of((SystemLogStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SystemLogStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SystemLogStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SystemLogStatus) { return (SystemLogStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SystemLogStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SystemLogStatus> listAll() {
            return new ArrayList<SystemLogStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SystemLogStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SystemLogStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SystemLogStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SystemLogStatus> clsList = new ArrayList<SystemLogStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SystemLogStatus> groupOf(String groupName) {
            return new ArrayList<SystemLogStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * システムログ種別
     */
    public enum SystemLogType implements CDef {
        /** $1: 通常 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: SQL(SELECT) */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: SQL(INSERT) */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: SQL(UPDATE) */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: SQL(DELETE) */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: SQL(OTHERS) */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, SystemLogType> _codeClsMap = new HashMap<String, SystemLogType>();
        private static final Map<String, SystemLogType> _nameClsMap = new HashMap<String, SystemLogType>();
        static {
            for (SystemLogType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SystemLogType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SystemLogType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SystemLogType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SystemLogType) { return OptionalThing.of((SystemLogType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SystemLogType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SystemLogType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SystemLogType) { return (SystemLogType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SystemLogType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SystemLogType> listAll() {
            return new ArrayList<SystemLogType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SystemLogType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SystemLogType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SystemLogType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SystemLogType> clsList = new ArrayList<SystemLogType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SystemLogType> groupOf(String groupName) {
            return new ArrayList<SystemLogType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * システム種別
     */
    public enum SystemType implements CDef {
        /** $base: 基盤 */
        $base("base", "$base", emptyStrings())
        ,
        /** $wms: WMS */
        $wms("wms", "$wms", emptyStrings())
        ;
        private static final Map<String, SystemType> _codeClsMap = new HashMap<String, SystemType>();
        private static final Map<String, SystemType> _nameClsMap = new HashMap<String, SystemType>();
        static {
            for (SystemType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SystemType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SystemType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SystemType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SystemType) { return OptionalThing.of((SystemType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SystemType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SystemType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SystemType) { return (SystemType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SystemType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SystemType> listAll() {
            return new ArrayList<SystemType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SystemType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SystemType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SystemType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SystemType> clsList = new ArrayList<SystemType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SystemType> groupOf(String groupName) {
            return new ArrayList<SystemType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 荷札納品書在中出力フラグ
     */
    public enum TagDeliveryOutFlg implements CDef {
        /** $0: 出力しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 1枚目のみ出力 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, TagDeliveryOutFlg> _codeClsMap = new HashMap<String, TagDeliveryOutFlg>();
        private static final Map<String, TagDeliveryOutFlg> _nameClsMap = new HashMap<String, TagDeliveryOutFlg>();
        static {
            for (TagDeliveryOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TagDeliveryOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TagDeliveryOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TagDeliveryOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TagDeliveryOutFlg) { return OptionalThing.of((TagDeliveryOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TagDeliveryOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TagDeliveryOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TagDeliveryOutFlg) { return (TagDeliveryOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TagDeliveryOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TagDeliveryOutFlg> listAll() {
            return new ArrayList<TagDeliveryOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TagDeliveryOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TagDeliveryOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TagDeliveryOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TagDeliveryOutFlg> clsList = new ArrayList<TagDeliveryOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TagDeliveryOutFlg> groupOf(String groupName) {
            return new ArrayList<TagDeliveryOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業日/出荷日/納品日区分
     */
    public enum TakingShippingDtFlg implements CDef {
        /** $0: 作業日 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出荷日 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 納品日 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, TakingShippingDtFlg> _codeClsMap = new HashMap<String, TakingShippingDtFlg>();
        private static final Map<String, TakingShippingDtFlg> _nameClsMap = new HashMap<String, TakingShippingDtFlg>();
        static {
            for (TakingShippingDtFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TakingShippingDtFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TakingShippingDtFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TakingShippingDtFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TakingShippingDtFlg) { return OptionalThing.of((TakingShippingDtFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TakingShippingDtFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TakingShippingDtFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TakingShippingDtFlg) { return (TakingShippingDtFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TakingShippingDtFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TakingShippingDtFlg> listAll() {
            return new ArrayList<TakingShippingDtFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TakingShippingDtFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TakingShippingDtFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TakingShippingDtFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TakingShippingDtFlg> clsList = new ArrayList<TakingShippingDtFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TakingShippingDtFlg> groupOf(String groupName) {
            return new ArrayList<TakingShippingDtFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業日/出荷日区分
     */
    public enum TakingShippingFlg implements CDef {
        /** $0: 作業日 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出荷日 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, TakingShippingFlg> _codeClsMap = new HashMap<String, TakingShippingFlg>();
        private static final Map<String, TakingShippingFlg> _nameClsMap = new HashMap<String, TakingShippingFlg>();
        static {
            for (TakingShippingFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TakingShippingFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TakingShippingFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TakingShippingFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TakingShippingFlg) { return OptionalThing.of((TakingShippingFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TakingShippingFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TakingShippingFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TakingShippingFlg) { return (TakingShippingFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TakingShippingFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TakingShippingFlg> listAll() {
            return new ArrayList<TakingShippingFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TakingShippingFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TakingShippingFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TakingShippingFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TakingShippingFlg> clsList = new ArrayList<TakingShippingFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TakingShippingFlg> groupOf(String groupName) {
            return new ArrayList<TakingShippingFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 表示位置
     */
    public enum TextAlign implements CDef {
        /** $left: 左寄せ */
        $left("left", "$left", emptyStrings())
        ,
        /** $right: 右寄せ */
        $right("right", "$right", emptyStrings())
        ,
        /** $center: 中央揃え */
        $center("center", "$center", emptyStrings())
        ;
        private static final Map<String, TextAlign> _codeClsMap = new HashMap<String, TextAlign>();
        private static final Map<String, TextAlign> _nameClsMap = new HashMap<String, TextAlign>();
        static {
            for (TextAlign value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TextAlign(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TextAlign; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TextAlign> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TextAlign) { return OptionalThing.of((TextAlign)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TextAlign> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TextAlign codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TextAlign) { return (TextAlign)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TextAlign nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TextAlign> listAll() {
            return new ArrayList<TextAlign>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TextAlign> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TextAlign." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TextAlign> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TextAlign> clsList = new ArrayList<TextAlign>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TextAlign> groupOf(String groupName) {
            return new ArrayList<TextAlign>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * トータルピックフラグ
     */
    public enum TotalPicFlg implements CDef {
        /** $0: トータルピック無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: トータルピック有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, TotalPicFlg> _codeClsMap = new HashMap<String, TotalPicFlg>();
        private static final Map<String, TotalPicFlg> _nameClsMap = new HashMap<String, TotalPicFlg>();
        static {
            for (TotalPicFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TotalPicFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TotalPicFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TotalPicFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TotalPicFlg) { return OptionalThing.of((TotalPicFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TotalPicFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TotalPicFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TotalPicFlg) { return (TotalPicFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TotalPicFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TotalPicFlg> listAll() {
            return new ArrayList<TotalPicFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TotalPicFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TotalPicFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TotalPicFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TotalPicFlg> clsList = new ArrayList<TotalPicFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TotalPicFlg> groupOf(String groupName) {
            return new ArrayList<TotalPicFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 追跡番号採番単位
     */
    public enum TrackingNumberingUnit implements CDef {
        /** $1: 出庫作業No単位 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 梱包単位 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, TrackingNumberingUnit> _codeClsMap = new HashMap<String, TrackingNumberingUnit>();
        private static final Map<String, TrackingNumberingUnit> _nameClsMap = new HashMap<String, TrackingNumberingUnit>();
        static {
            for (TrackingNumberingUnit value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TrackingNumberingUnit(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TrackingNumberingUnit; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TrackingNumberingUnit> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TrackingNumberingUnit) { return OptionalThing.of((TrackingNumberingUnit)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TrackingNumberingUnit> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TrackingNumberingUnit codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TrackingNumberingUnit) { return (TrackingNumberingUnit)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TrackingNumberingUnit nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TrackingNumberingUnit> listAll() {
            return new ArrayList<TrackingNumberingUnit>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TrackingNumberingUnit> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TrackingNumberingUnit." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TrackingNumberingUnit> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TrackingNumberingUnit> clsList = new ArrayList<TrackingNumberingUnit>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TrackingNumberingUnit> groupOf(String groupName) {
            return new ArrayList<TrackingNumberingUnit>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 積送中在庫のみ表示
     */
    public enum TransitDisplay implements CDef {
        /** $0: 全件表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 積送中在庫のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, TransitDisplay> _codeClsMap = new HashMap<String, TransitDisplay>();
        private static final Map<String, TransitDisplay> _nameClsMap = new HashMap<String, TransitDisplay>();
        static {
            for (TransitDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TransitDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TransitDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TransitDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TransitDisplay) { return OptionalThing.of((TransitDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TransitDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TransitDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TransitDisplay) { return (TransitDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TransitDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TransitDisplay> listAll() {
            return new ArrayList<TransitDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TransitDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TransitDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TransitDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TransitDisplay> clsList = new ArrayList<TransitDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TransitDisplay> groupOf(String groupName) {
            return new ArrayList<TransitDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * アンマッチ有
     */
    public enum Unmatch implements CDef {
        /** $1: アンマッチ有のみ表示 */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: 全件表示 */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, Unmatch> _codeClsMap = new HashMap<String, Unmatch>();
        private static final Map<String, Unmatch> _nameClsMap = new HashMap<String, Unmatch>();
        static {
            for (Unmatch value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Unmatch(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Unmatch; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Unmatch> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Unmatch) { return OptionalThing.of((Unmatch)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Unmatch> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Unmatch codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Unmatch) { return (Unmatch)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Unmatch nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Unmatch> listAll() {
            return new ArrayList<Unmatch>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Unmatch> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Unmatch." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Unmatch> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Unmatch> clsList = new ArrayList<Unmatch>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Unmatch> groupOf(String groupName) {
            return new ArrayList<Unmatch>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 修正コード
     */
    public enum UpdCd implements CDef {
        /** $0: 修正なし */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 新規追加 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 廃止 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, UpdCd> _codeClsMap = new HashMap<String, UpdCd>();
        private static final Map<String, UpdCd> _nameClsMap = new HashMap<String, UpdCd>();
        static {
            for (UpdCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private UpdCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.UpdCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UpdCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof UpdCd) { return OptionalThing.of((UpdCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UpdCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static UpdCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof UpdCd) { return (UpdCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static UpdCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<UpdCd> listAll() {
            return new ArrayList<UpdCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<UpdCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: UpdCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<UpdCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<UpdCd> clsList = new ArrayList<UpdCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<UpdCd> groupOf(String groupName) {
            return new ArrayList<UpdCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 更新区分
     */
    public enum UpdType implements CDef {
        /** $0: 変更なし */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 変更あり */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 廃止 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, UpdType> _codeClsMap = new HashMap<String, UpdType>();
        private static final Map<String, UpdType> _nameClsMap = new HashMap<String, UpdType>();
        static {
            for (UpdType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private UpdType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.UpdType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UpdType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof UpdType) { return OptionalThing.of((UpdType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UpdType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static UpdType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof UpdType) { return (UpdType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static UpdType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<UpdType> listAll() {
            return new ArrayList<UpdType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<UpdType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: UpdType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<UpdType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<UpdType> clsList = new ArrayList<UpdType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<UpdType> groupOf(String groupName) {
            return new ArrayList<UpdType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 更新可否
     */
    public enum Updatable implements CDef {
        /** $0: 更新不可 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 更新可能 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Updatable> _codeClsMap = new HashMap<String, Updatable>();
        private static final Map<String, Updatable> _nameClsMap = new HashMap<String, Updatable>();
        static {
            for (Updatable value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Updatable(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Updatable; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Updatable> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Updatable) { return OptionalThing.of((Updatable)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Updatable> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Updatable codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Updatable) { return (Updatable)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Updatable nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Updatable> listAll() {
            return new ArrayList<Updatable>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Updatable> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Updatable." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Updatable> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Updatable> clsList = new ArrayList<Updatable>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Updatable> groupOf(String groupName) {
            return new ArrayList<Updatable>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * アップロードテーブル名
     */
    public enum UploadTableNm implements CDef {
        /** $tRakutenOrder: 楽天RMS受注 */
        $tRakutenOrder("tRakutenOrder", "$tRakutenOrder", emptyStrings())
        ,
        /** $tAmazonOrder: Amazon受注 */
        $tAmazonOrder("tAmazonOrder", "$tAmazonOrder", emptyStrings())
        ,
        /** $tYahooOrder: Yahoo受注 */
        $tYahooOrder("tYahooOrder", "$tYahooOrder", emptyStrings())
        ;
        private static final Map<String, UploadTableNm> _codeClsMap = new HashMap<String, UploadTableNm>();
        private static final Map<String, UploadTableNm> _nameClsMap = new HashMap<String, UploadTableNm>();
        static {
            for (UploadTableNm value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private UploadTableNm(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.UploadTableNm; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UploadTableNm> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof UploadTableNm) { return OptionalThing.of((UploadTableNm)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UploadTableNm> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static UploadTableNm codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof UploadTableNm) { return (UploadTableNm)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static UploadTableNm nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<UploadTableNm> listAll() {
            return new ArrayList<UploadTableNm>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<UploadTableNm> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: UploadTableNm." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<UploadTableNm> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<UploadTableNm> clsList = new ArrayList<UploadTableNm>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<UploadTableNm> groupOf(String groupName) {
            return new ArrayList<UploadTableNm>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * HT/SDケースピック使用フラグ
     */
    public enum UseHtShipFlg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, UseHtShipFlg> _codeClsMap = new HashMap<String, UseHtShipFlg>();
        private static final Map<String, UseHtShipFlg> _nameClsMap = new HashMap<String, UseHtShipFlg>();
        static {
            for (UseHtShipFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private UseHtShipFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.UseHtShipFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UseHtShipFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof UseHtShipFlg) { return OptionalThing.of((UseHtShipFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UseHtShipFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static UseHtShipFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof UseHtShipFlg) { return (UseHtShipFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static UseHtShipFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<UseHtShipFlg> listAll() {
            return new ArrayList<UseHtShipFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<UseHtShipFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: UseHtShipFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<UseHtShipFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<UseHtShipFlg> clsList = new ArrayList<UseHtShipFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<UseHtShipFlg> groupOf(String groupName) {
            return new ArrayList<UseHtShipFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ユーザ編集可否
     */
    public enum UserEditable implements CDef {
        /** $0: 否 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 可 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, UserEditable> _codeClsMap = new HashMap<String, UserEditable>();
        private static final Map<String, UserEditable> _nameClsMap = new HashMap<String, UserEditable>();
        static {
            for (UserEditable value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private UserEditable(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.UserEditable; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UserEditable> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof UserEditable) { return OptionalThing.of((UserEditable)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UserEditable> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static UserEditable codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof UserEditable) { return (UserEditable)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static UserEditable nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<UserEditable> listAll() {
            return new ArrayList<UserEditable>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<UserEditable> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: UserEditable." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<UserEditable> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<UserEditable> clsList = new ArrayList<UserEditable>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<UserEditable> groupOf(String groupName) {
            return new ArrayList<UserEditable>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 仕入先フラグ
     */
    public enum VendorFlg implements CDef {
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, VendorFlg> _codeClsMap = new HashMap<String, VendorFlg>();
        private static final Map<String, VendorFlg> _nameClsMap = new HashMap<String, VendorFlg>();
        static {
            for (VendorFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private VendorFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.VendorFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<VendorFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof VendorFlg) { return OptionalThing.of((VendorFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<VendorFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static VendorFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof VendorFlg) { return (VendorFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static VendorFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<VendorFlg> listAll() {
            return new ArrayList<VendorFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<VendorFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: VendorFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<VendorFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<VendorFlg> clsList = new ArrayList<VendorFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<VendorFlg> groupOf(String groupName) {
            return new ArrayList<VendorFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 表示可否
     */
    public enum Visible implements CDef {
        /** $0: 非表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, Visible> _codeClsMap = new HashMap<String, Visible>();
        private static final Map<String, Visible> _nameClsMap = new HashMap<String, Visible>();
        static {
            for (Visible value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Visible(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Visible; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Visible> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Visible) { return OptionalThing.of((Visible)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Visible> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Visible codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Visible) { return (Visible)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Visible nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Visible> listAll() {
            return new ArrayList<Visible>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Visible> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Visible." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Visible> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Visible> clsList = new ArrayList<Visible>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Visible> groupOf(String groupName) {
            return new ArrayList<Visible>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 処理済フラグ
     */
    public enum WorkFlg implements CDef {
        /** $0: 未処理 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 処理済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, WorkFlg> _codeClsMap = new HashMap<String, WorkFlg>();
        private static final Map<String, WorkFlg> _nameClsMap = new HashMap<String, WorkFlg>();
        static {
            for (WorkFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private WorkFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.WorkFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof WorkFlg) { return OptionalThing.of((WorkFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static WorkFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof WorkFlg) { return (WorkFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static WorkFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<WorkFlg> listAll() {
            return new ArrayList<WorkFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<WorkFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: WorkFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<WorkFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<WorkFlg> clsList = new ArrayList<WorkFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<WorkFlg> groupOf(String groupName) {
            return new ArrayList<WorkFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業メッセージ有無
     */
    public enum WorkMessageFlg implements CDef {
        /** $0: メッセージ無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: メッセージ有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, WorkMessageFlg> _codeClsMap = new HashMap<String, WorkMessageFlg>();
        private static final Map<String, WorkMessageFlg> _nameClsMap = new HashMap<String, WorkMessageFlg>();
        static {
            for (WorkMessageFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private WorkMessageFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.WorkMessageFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkMessageFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof WorkMessageFlg) { return OptionalThing.of((WorkMessageFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkMessageFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static WorkMessageFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof WorkMessageFlg) { return (WorkMessageFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static WorkMessageFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<WorkMessageFlg> listAll() {
            return new ArrayList<WorkMessageFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<WorkMessageFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: WorkMessageFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<WorkMessageFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<WorkMessageFlg> clsList = new ArrayList<WorkMessageFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<WorkMessageFlg> groupOf(String groupName) {
            return new ArrayList<WorkMessageFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ヤマト配達時間帯
     */
    public enum YamatoDelivTz implements CDef {
        /** $0812: 午前中 */
        $0812("0812", "$0812", emptyStrings())
        ,
        /** $1214: 12時～14時 */
        $1214("1214", "$1214", emptyStrings())
        ,
        /** $1416: 14時～16時 */
        $1416("1416", "$1416", emptyStrings())
        ,
        /** $1618: 16時～18時 */
        $1618("1618", "$1618", emptyStrings())
        ,
        /** $1820: 18時～20時 */
        $1820("1820", "$1820", emptyStrings())
        ,
        /** $1921: 19時～21時 */
        $1921("1921", "$1921", emptyStrings())
        ,
        /** $2021: 20時～21時 */
        $2021("2021", "$2021", emptyStrings())
        ,
        /** $0010: 午前10時まで */
        $0010("0010", "$0010", emptyStrings())
        ,
        /** $0017: 午後5時まで */
        $0017("0017", "$0017", emptyStrings())
        ;
        private static final Map<String, YamatoDelivTz> _codeClsMap = new HashMap<String, YamatoDelivTz>();
        private static final Map<String, YamatoDelivTz> _nameClsMap = new HashMap<String, YamatoDelivTz>();
        static {
            for (YamatoDelivTz value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private YamatoDelivTz(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.YamatoDelivTz; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<YamatoDelivTz> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof YamatoDelivTz) { return OptionalThing.of((YamatoDelivTz)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<YamatoDelivTz> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static YamatoDelivTz codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof YamatoDelivTz) { return (YamatoDelivTz)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static YamatoDelivTz nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<YamatoDelivTz> listAll() {
            return new ArrayList<YamatoDelivTz>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<YamatoDelivTz> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: YamatoDelivTz." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<YamatoDelivTz> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<YamatoDelivTz> clsList = new ArrayList<YamatoDelivTz>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<YamatoDelivTz> groupOf(String groupName) {
            return new ArrayList<YamatoDelivTz>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ゆうパック配達時間帯
     */
    public enum YupackDelivTz implements CDef {
        /** $00: 時間指定なし */
        $00("00", "$00", emptyStrings())
        ,
        /** $51: 午前中 */
        $51("51", "$51", emptyStrings())
        ,
        /** $52: 12時～14時 */
        $52("52", "$52", emptyStrings())
        ,
        /** $53: 14時～16時 */
        $53("53", "$53", emptyStrings())
        ,
        /** $54: 16時～18時 */
        $54("54", "$54", emptyStrings())
        ,
        /** $55: 18時～20時 */
        $55("55", "$55", emptyStrings())
        ,
        /** $57: 19時～21時 */
        $57("57", "$57", emptyStrings())
        ,
        /** $56: 20時～21時 */
        $56("56", "$56", emptyStrings())
        ;
        private static final Map<String, YupackDelivTz> _codeClsMap = new HashMap<String, YupackDelivTz>();
        private static final Map<String, YupackDelivTz> _nameClsMap = new HashMap<String, YupackDelivTz>();
        static {
            for (YupackDelivTz value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private YupackDelivTz(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.YupackDelivTz; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<YupackDelivTz> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof YupackDelivTz) { return OptionalThing.of((YupackDelivTz)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<YupackDelivTz> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static YupackDelivTz codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof YupackDelivTz) { return (YupackDelivTz)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static YupackDelivTz nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<YupackDelivTz> listAll() {
            return new ArrayList<YupackDelivTz>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<YupackDelivTz> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: YupackDelivTz." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<YupackDelivTz> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<YupackDelivTz> clsList = new ArrayList<YupackDelivTz>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<YupackDelivTz> groupOf(String groupName) {
            return new ArrayList<YupackDelivTz>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 郵便番号フラグ
     */
    public enum ZipFlg implements CDef {
        /** $0: 該当せず */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 該当 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ZipFlg> _codeClsMap = new HashMap<String, ZipFlg>();
        private static final Map<String, ZipFlg> _nameClsMap = new HashMap<String, ZipFlg>();
        static {
            for (ZipFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ZipFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ZipFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ZipFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ZipFlg) { return OptionalThing.of((ZipFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ZipFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ZipFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ZipFlg) { return (ZipFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ZipFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ZipFlg> listAll() {
            return new ArrayList<ZipFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ZipFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ZipFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ZipFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ZipFlg> clsList = new ArrayList<ZipFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ZipFlg> groupOf(String groupName) {
            return new ArrayList<ZipFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 実績入力後入庫/商品ラベル出力対象
     */
    public enum ResultAfterProductTarget implements CDef {
        /** $1: 入庫ラベル */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 商品ラベル */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, ResultAfterProductTarget> _codeClsMap = new HashMap<String, ResultAfterProductTarget>();
        private static final Map<String, ResultAfterProductTarget> _nameClsMap = new HashMap<String, ResultAfterProductTarget>();
        static {
            for (ResultAfterProductTarget value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ResultAfterProductTarget(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ResultAfterProductTarget; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResultAfterProductTarget> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ResultAfterProductTarget) { return OptionalThing.of((ResultAfterProductTarget)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResultAfterProductTarget> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ResultAfterProductTarget codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ResultAfterProductTarget) { return (ResultAfterProductTarget)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ResultAfterProductTarget nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ResultAfterProductTarget> listAll() {
            return new ArrayList<ResultAfterProductTarget>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ResultAfterProductTarget> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ResultAfterProductTarget." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ResultAfterProductTarget> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ResultAfterProductTarget> clsList = new ArrayList<ResultAfterProductTarget>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ResultAfterProductTarget> groupOf(String groupName) {
            return new ArrayList<ResultAfterProductTarget>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * コピー対象テーブル
     */
    public enum CopyTargetTable implements CDef {
        /** $MCenterCol: センタ列マスタ */
        $MCenterCol("MCenterCol", "$MCenterCol", emptyStrings())
        ,
        /** $MCenterItem: センタ項目マスタ */
        $MCenterItem("MCenterItem", "$MCenterItem", emptyStrings())
        ,
        /** $MCenterScreen: センタ画面マスタ */
        $MCenterScreen("MCenterScreen", "$MCenterScreen", emptyStrings())
        ,
        /** $MCarrierSlipSgw: 佐川送り状マスタ */
        $MCarrierSlipSgw("MCarrierSlipSgw", "$MCarrierSlipSgw", emptyStrings())
        ,
        /** $MCarrierSlipYmt: ヤマト送り状マスタ */
        $MCarrierSlipYmt("MCarrierSlipYmt", "$MCarrierSlipYmt", emptyStrings())
        ,
        /** $MCarrierSlipYupk: ゆうパック送り状マスタ */
        $MCarrierSlipYupk("MCarrierSlipYupk", "$MCarrierSlipYupk", emptyStrings())
        ;
        private static final Map<String, CopyTargetTable> _codeClsMap = new HashMap<String, CopyTargetTable>();
        private static final Map<String, CopyTargetTable> _nameClsMap = new HashMap<String, CopyTargetTable>();
        static {
            for (CopyTargetTable value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CopyTargetTable(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CopyTargetTable; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CopyTargetTable> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CopyTargetTable) { return OptionalThing.of((CopyTargetTable)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CopyTargetTable> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CopyTargetTable codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CopyTargetTable) { return (CopyTargetTable)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CopyTargetTable nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CopyTargetTable> listAll() {
            return new ArrayList<CopyTargetTable>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CopyTargetTable> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CopyTargetTable." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CopyTargetTable> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CopyTargetTable> clsList = new ArrayList<CopyTargetTable>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CopyTargetTable> groupOf(String groupName) {
            return new ArrayList<CopyTargetTable>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 検品ラベル出力
     */
    public enum InspectionLabelOutFlg implements CDef {
        /** $0: 出力しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出力する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InspectionLabelOutFlg> _codeClsMap = new HashMap<String, InspectionLabelOutFlg>();
        private static final Map<String, InspectionLabelOutFlg> _nameClsMap = new HashMap<String, InspectionLabelOutFlg>();
        static {
            for (InspectionLabelOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InspectionLabelOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InspectionLabelOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InspectionLabelOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InspectionLabelOutFlg) { return OptionalThing.of((InspectionLabelOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InspectionLabelOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InspectionLabelOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InspectionLabelOutFlg) { return (InspectionLabelOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InspectionLabelOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InspectionLabelOutFlg> listAll() {
            return new ArrayList<InspectionLabelOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InspectionLabelOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InspectionLabelOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InspectionLabelOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InspectionLabelOutFlg> clsList = new ArrayList<InspectionLabelOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InspectionLabelOutFlg> groupOf(String groupName) {
            return new ArrayList<InspectionLabelOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 小数管理商品梱包単位
     */
    public enum DecimalProductPacking implements CDef {
        /** $0: 荷姿単位で1梱包 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 商品単位で1梱包 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DecimalProductPacking> _codeClsMap = new HashMap<String, DecimalProductPacking>();
        private static final Map<String, DecimalProductPacking> _nameClsMap = new HashMap<String, DecimalProductPacking>();
        static {
            for (DecimalProductPacking value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DecimalProductPacking(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DecimalProductPacking; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DecimalProductPacking> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DecimalProductPacking) { return OptionalThing.of((DecimalProductPacking)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DecimalProductPacking> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DecimalProductPacking codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DecimalProductPacking) { return (DecimalProductPacking)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DecimalProductPacking nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DecimalProductPacking> listAll() {
            return new ArrayList<DecimalProductPacking>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DecimalProductPacking> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DecimalProductPacking." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DecimalProductPacking> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DecimalProductPacking> clsList = new ArrayList<DecimalProductPacking>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DecimalProductPacking> groupOf(String groupName) {
            return new ArrayList<DecimalProductPacking>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 小数有無フラグ
     */
    public enum DecimalExistFlg implements CDef {
        /** $0: 小数を含まない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 小数を含む */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DecimalExistFlg> _codeClsMap = new HashMap<String, DecimalExistFlg>();
        private static final Map<String, DecimalExistFlg> _nameClsMap = new HashMap<String, DecimalExistFlg>();
        static {
            for (DecimalExistFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DecimalExistFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DecimalExistFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DecimalExistFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DecimalExistFlg) { return OptionalThing.of((DecimalExistFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DecimalExistFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DecimalExistFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DecimalExistFlg) { return (DecimalExistFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DecimalExistFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DecimalExistFlg> listAll() {
            return new ArrayList<DecimalExistFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DecimalExistFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DecimalExistFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DecimalExistFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DecimalExistFlg> clsList = new ArrayList<DecimalExistFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DecimalExistFlg> groupOf(String groupName) {
            return new ArrayList<DecimalExistFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ケースピッキング対象
     */
    public enum CasePickFlg implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CasePickFlg> _codeClsMap = new HashMap<String, CasePickFlg>();
        private static final Map<String, CasePickFlg> _nameClsMap = new HashMap<String, CasePickFlg>();
        static {
            for (CasePickFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CasePickFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CasePickFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CasePickFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CasePickFlg) { return OptionalThing.of((CasePickFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CasePickFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CasePickFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CasePickFlg) { return (CasePickFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CasePickFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CasePickFlg> listAll() {
            return new ArrayList<CasePickFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CasePickFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CasePickFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CasePickFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CasePickFlg> clsList = new ArrayList<CasePickFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CasePickFlg> groupOf(String groupName) {
            return new ArrayList<CasePickFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 緊急補充ゾーン補充荷姿
     */
    public enum EmReplenishShapeFlg implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, EmReplenishShapeFlg> _codeClsMap = new HashMap<String, EmReplenishShapeFlg>();
        private static final Map<String, EmReplenishShapeFlg> _nameClsMap = new HashMap<String, EmReplenishShapeFlg>();
        static {
            for (EmReplenishShapeFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private EmReplenishShapeFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.EmReplenishShapeFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EmReplenishShapeFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof EmReplenishShapeFlg) { return OptionalThing.of((EmReplenishShapeFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EmReplenishShapeFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static EmReplenishShapeFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof EmReplenishShapeFlg) { return (EmReplenishShapeFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static EmReplenishShapeFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<EmReplenishShapeFlg> listAll() {
            return new ArrayList<EmReplenishShapeFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<EmReplenishShapeFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: EmReplenishShapeFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<EmReplenishShapeFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<EmReplenishShapeFlg> clsList = new ArrayList<EmReplenishShapeFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<EmReplenishShapeFlg> groupOf(String groupName) {
            return new ArrayList<EmReplenishShapeFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業ステータス
     */
    public enum WorkStatus implements CDef {
        /** $01: 作業中 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 正常終了 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 基盤強制終了 */
        $03("03", "$03", emptyStrings())
        ;
        private static final Map<String, WorkStatus> _codeClsMap = new HashMap<String, WorkStatus>();
        private static final Map<String, WorkStatus> _nameClsMap = new HashMap<String, WorkStatus>();
        static {
            for (WorkStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private WorkStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.WorkStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof WorkStatus) { return OptionalThing.of((WorkStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static WorkStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof WorkStatus) { return (WorkStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static WorkStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<WorkStatus> listAll() {
            return new ArrayList<WorkStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<WorkStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: WorkStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<WorkStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<WorkStatus> clsList = new ArrayList<WorkStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<WorkStatus> groupOf(String groupName) {
            return new ArrayList<WorkStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業実績出力フラグ
     */
    public enum WorkLogOutFlg implements CDef {
        /** $0: 未出力 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出力済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, WorkLogOutFlg> _codeClsMap = new HashMap<String, WorkLogOutFlg>();
        private static final Map<String, WorkLogOutFlg> _nameClsMap = new HashMap<String, WorkLogOutFlg>();
        static {
            for (WorkLogOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private WorkLogOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.WorkLogOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkLogOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof WorkLogOutFlg) { return OptionalThing.of((WorkLogOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkLogOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static WorkLogOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof WorkLogOutFlg) { return (WorkLogOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static WorkLogOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<WorkLogOutFlg> listAll() {
            return new ArrayList<WorkLogOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<WorkLogOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: WorkLogOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<WorkLogOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<WorkLogOutFlg> clsList = new ArrayList<WorkLogOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<WorkLogOutFlg> groupOf(String groupName) {
            return new ArrayList<WorkLogOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 権限制御区分
     */
    public enum RoleControlClass implements CDef {
        /** $1: 許可を指定 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 拒否を指定 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, RoleControlClass> _codeClsMap = new HashMap<String, RoleControlClass>();
        private static final Map<String, RoleControlClass> _nameClsMap = new HashMap<String, RoleControlClass>();
        static {
            for (RoleControlClass value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private RoleControlClass(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.RoleControlClass; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RoleControlClass> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof RoleControlClass) { return OptionalThing.of((RoleControlClass)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RoleControlClass> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static RoleControlClass codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof RoleControlClass) { return (RoleControlClass)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static RoleControlClass nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<RoleControlClass> listAll() {
            return new ArrayList<RoleControlClass>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<RoleControlClass> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: RoleControlClass." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<RoleControlClass> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<RoleControlClass> clsList = new ArrayList<RoleControlClass>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<RoleControlClass> groupOf(String groupName) {
            return new ArrayList<RoleControlClass>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Bill of Lading出力フラグ
     */
    public enum BolOutFlg implements CDef {
        /** $0: 未発行 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 発行済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, BolOutFlg> _codeClsMap = new HashMap<String, BolOutFlg>();
        private static final Map<String, BolOutFlg> _nameClsMap = new HashMap<String, BolOutFlg>();
        static {
            for (BolOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private BolOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.BolOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BolOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof BolOutFlg) { return OptionalThing.of((BolOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BolOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static BolOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof BolOutFlg) { return (BolOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static BolOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<BolOutFlg> listAll() {
            return new ArrayList<BolOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<BolOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: BolOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<BolOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<BolOutFlg> clsList = new ArrayList<BolOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<BolOutFlg> groupOf(String groupName) {
            return new ArrayList<BolOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Bill of Lading出力対象フラグ
     */
    public enum BolOutputTargetFlg implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, BolOutputTargetFlg> _codeClsMap = new HashMap<String, BolOutputTargetFlg>();
        private static final Map<String, BolOutputTargetFlg> _nameClsMap = new HashMap<String, BolOutputTargetFlg>();
        static {
            for (BolOutputTargetFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private BolOutputTargetFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.BolOutputTargetFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BolOutputTargetFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof BolOutputTargetFlg) { return OptionalThing.of((BolOutputTargetFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BolOutputTargetFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static BolOutputTargetFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof BolOutputTargetFlg) { return (BolOutputTargetFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static BolOutputTargetFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<BolOutputTargetFlg> listAll() {
            return new ArrayList<BolOutputTargetFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<BolOutputTargetFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: BolOutputTargetFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<BolOutputTargetFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<BolOutputTargetFlg> clsList = new ArrayList<BolOutputTargetFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<BolOutputTargetFlg> groupOf(String groupName) {
            return new ArrayList<BolOutputTargetFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Payment Term
     */
    public enum PaymentTerm implements CDef {
        /** $PPD: PrePaid */
        $PPD("PPD", "$PPD", emptyStrings())
        ,
        /** $PPB: PrePaid &amp; Bill */
        $PPB("PPB", "$PPB", emptyStrings())
        ,
        /** $COL: Collect */
        $COL("COL", "$COL", emptyStrings())
        ,
        /** $CO1: COD Bill FRT */
        $CO1("CO1", "$CO1", emptyStrings())
        ,
        /** $CO2: COD NOT Bill FRT */
        $CO2("CO2", "$CO2", emptyStrings())
        ,
        /** $3PL: 3rd Party */
        $3PL("3PL", "$3PL", emptyStrings())
        ;
        private static final Map<String, PaymentTerm> _codeClsMap = new HashMap<String, PaymentTerm>();
        private static final Map<String, PaymentTerm> _nameClsMap = new HashMap<String, PaymentTerm>();
        static {
            for (PaymentTerm value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PaymentTerm(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PaymentTerm; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PaymentTerm> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PaymentTerm) { return OptionalThing.of((PaymentTerm)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PaymentTerm> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PaymentTerm codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PaymentTerm) { return (PaymentTerm)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PaymentTerm nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PaymentTerm> listAll() {
            return new ArrayList<PaymentTerm>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PaymentTerm> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PaymentTerm." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PaymentTerm> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PaymentTerm> clsList = new ArrayList<PaymentTerm>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PaymentTerm> groupOf(String groupName) {
            return new ArrayList<PaymentTerm>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * CES連携フラグ
     */
    public enum CesIntegrationFlg implements CDef {
        /** $0: 連携しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 連携する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CesIntegrationFlg> _codeClsMap = new HashMap<String, CesIntegrationFlg>();
        private static final Map<String, CesIntegrationFlg> _nameClsMap = new HashMap<String, CesIntegrationFlg>();
        static {
            for (CesIntegrationFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CesIntegrationFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CesIntegrationFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CesIntegrationFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CesIntegrationFlg) { return OptionalThing.of((CesIntegrationFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CesIntegrationFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CesIntegrationFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CesIntegrationFlg) { return (CesIntegrationFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CesIntegrationFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CesIntegrationFlg> listAll() {
            return new ArrayList<CesIntegrationFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CesIntegrationFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CesIntegrationFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CesIntegrationFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CesIntegrationFlg> clsList = new ArrayList<CesIntegrationFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CesIntegrationFlg> groupOf(String groupName) {
            return new ArrayList<CesIntegrationFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 納品明細書自動発行フラグ
     */
    public enum PackingSlipAutoOutputFlg implements CDef {
        /** $0: 発行しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 発行する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PackingSlipAutoOutputFlg> _codeClsMap = new HashMap<String, PackingSlipAutoOutputFlg>();
        private static final Map<String, PackingSlipAutoOutputFlg> _nameClsMap = new HashMap<String, PackingSlipAutoOutputFlg>();
        static {
            for (PackingSlipAutoOutputFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PackingSlipAutoOutputFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PackingSlipAutoOutputFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingSlipAutoOutputFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PackingSlipAutoOutputFlg) { return OptionalThing.of((PackingSlipAutoOutputFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PackingSlipAutoOutputFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PackingSlipAutoOutputFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PackingSlipAutoOutputFlg) { return (PackingSlipAutoOutputFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PackingSlipAutoOutputFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PackingSlipAutoOutputFlg> listAll() {
            return new ArrayList<PackingSlipAutoOutputFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PackingSlipAutoOutputFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PackingSlipAutoOutputFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PackingSlipAutoOutputFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PackingSlipAutoOutputFlg> clsList = new ArrayList<PackingSlipAutoOutputFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PackingSlipAutoOutputFlg> groupOf(String groupName) {
            return new ArrayList<PackingSlipAutoOutputFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Freight Class
     */
    public enum FreightCls implements CDef {
        /** $01: 50 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 55 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 60 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: 65 */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: 70 */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: 77.5 */
        $06("06", "$06", emptyStrings())
        ,
        /** $07: 85 */
        $07("07", "$07", emptyStrings())
        ,
        /** $08: 92.5 */
        $08("08", "$08", emptyStrings())
        ,
        /** $09: 100 */
        $09("09", "$09", emptyStrings())
        ,
        /** $10: 110 */
        $10("10", "$10", emptyStrings())
        ,
        /** $11: 125 */
        $11("11", "$11", emptyStrings())
        ,
        /** $12: 150 */
        $12("12", "$12", emptyStrings())
        ,
        /** $13: 175 */
        $13("13", "$13", emptyStrings())
        ,
        /** $14: 200 */
        $14("14", "$14", emptyStrings())
        ,
        /** $15: 250 */
        $15("15", "$15", emptyStrings())
        ,
        /** $16: 300 */
        $16("16", "$16", emptyStrings())
        ,
        /** $17: 400 */
        $17("17", "$17", emptyStrings())
        ,
        /** $18: 500 */
        $18("18", "$18", emptyStrings())
        ;
        private static final Map<String, FreightCls> _codeClsMap = new HashMap<String, FreightCls>();
        private static final Map<String, FreightCls> _nameClsMap = new HashMap<String, FreightCls>();
        static {
            for (FreightCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private FreightCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.FreightCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FreightCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof FreightCls) { return OptionalThing.of((FreightCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FreightCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static FreightCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof FreightCls) { return (FreightCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static FreightCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<FreightCls> listAll() {
            return new ArrayList<FreightCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<FreightCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: FreightCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<FreightCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<FreightCls> clsList = new ArrayList<FreightCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<FreightCls> groupOf(String groupName) {
            return new ArrayList<FreightCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Saturday Delivery フラグCD
     */
    public enum SatDeliveryFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, SatDeliveryFlg> _codeClsMap = new HashMap<String, SatDeliveryFlg>();
        private static final Map<String, SatDeliveryFlg> _nameClsMap = new HashMap<String, SatDeliveryFlg>();
        static {
            for (SatDeliveryFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SatDeliveryFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SatDeliveryFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SatDeliveryFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SatDeliveryFlg) { return OptionalThing.of((SatDeliveryFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SatDeliveryFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SatDeliveryFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SatDeliveryFlg) { return (SatDeliveryFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SatDeliveryFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SatDeliveryFlg> listAll() {
            return new ArrayList<SatDeliveryFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SatDeliveryFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SatDeliveryFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SatDeliveryFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SatDeliveryFlg> clsList = new ArrayList<SatDeliveryFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SatDeliveryFlg> groupOf(String groupName) {
            return new ArrayList<SatDeliveryFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Residential Delivery フラグCD
     */
    public enum ResidentialDeliveryFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, ResidentialDeliveryFlg> _codeClsMap = new HashMap<String, ResidentialDeliveryFlg>();
        private static final Map<String, ResidentialDeliveryFlg> _nameClsMap = new HashMap<String, ResidentialDeliveryFlg>();
        static {
            for (ResidentialDeliveryFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ResidentialDeliveryFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ResidentialDeliveryFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResidentialDeliveryFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ResidentialDeliveryFlg) { return OptionalThing.of((ResidentialDeliveryFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResidentialDeliveryFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ResidentialDeliveryFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ResidentialDeliveryFlg) { return (ResidentialDeliveryFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ResidentialDeliveryFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ResidentialDeliveryFlg> listAll() {
            return new ArrayList<ResidentialDeliveryFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ResidentialDeliveryFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ResidentialDeliveryFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ResidentialDeliveryFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ResidentialDeliveryFlg> clsList = new ArrayList<ResidentialDeliveryFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ResidentialDeliveryFlg> groupOf(String groupName) {
            return new ArrayList<ResidentialDeliveryFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Collect On Delivery フラグCD
     */
    public enum CodFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, CodFlg> _codeClsMap = new HashMap<String, CodFlg>();
        private static final Map<String, CodFlg> _nameClsMap = new HashMap<String, CodFlg>();
        static {
            for (CodFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CodFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CodFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CodFlg) { return OptionalThing.of((CodFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CodFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CodFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CodFlg) { return (CodFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CodFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CodFlg> listAll() {
            return new ArrayList<CodFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CodFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CodFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CodFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CodFlg> clsList = new ArrayList<CodFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CodFlg> groupOf(String groupName) {
            return new ArrayList<CodFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Signature Required フラグCD
     */
    public enum SignatureRequiredFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, SignatureRequiredFlg> _codeClsMap = new HashMap<String, SignatureRequiredFlg>();
        private static final Map<String, SignatureRequiredFlg> _nameClsMap = new HashMap<String, SignatureRequiredFlg>();
        static {
            for (SignatureRequiredFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SignatureRequiredFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SignatureRequiredFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SignatureRequiredFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SignatureRequiredFlg) { return OptionalThing.of((SignatureRequiredFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SignatureRequiredFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SignatureRequiredFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SignatureRequiredFlg) { return (SignatureRequiredFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SignatureRequiredFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SignatureRequiredFlg> listAll() {
            return new ArrayList<SignatureRequiredFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SignatureRequiredFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SignatureRequiredFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SignatureRequiredFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SignatureRequiredFlg> clsList = new ArrayList<SignatureRequiredFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SignatureRequiredFlg> groupOf(String groupName) {
            return new ArrayList<SignatureRequiredFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Signature ReleaseフラグCD
     */
    public enum SignatureReleaseFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, SignatureReleaseFlg> _codeClsMap = new HashMap<String, SignatureReleaseFlg>();
        private static final Map<String, SignatureReleaseFlg> _nameClsMap = new HashMap<String, SignatureReleaseFlg>();
        static {
            for (SignatureReleaseFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SignatureReleaseFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SignatureReleaseFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SignatureReleaseFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SignatureReleaseFlg) { return OptionalThing.of((SignatureReleaseFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SignatureReleaseFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SignatureReleaseFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SignatureReleaseFlg) { return (SignatureReleaseFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SignatureReleaseFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SignatureReleaseFlg> listAll() {
            return new ArrayList<SignatureReleaseFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SignatureReleaseFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SignatureReleaseFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SignatureReleaseFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SignatureReleaseFlg> clsList = new ArrayList<SignatureReleaseFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SignatureReleaseFlg> groupOf(String groupName) {
            return new ArrayList<SignatureReleaseFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Call Before Delivery フラグCD
     */
    public enum CallBeforeDeliveryFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, CallBeforeDeliveryFlg> _codeClsMap = new HashMap<String, CallBeforeDeliveryFlg>();
        private static final Map<String, CallBeforeDeliveryFlg> _nameClsMap = new HashMap<String, CallBeforeDeliveryFlg>();
        static {
            for (CallBeforeDeliveryFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CallBeforeDeliveryFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CallBeforeDeliveryFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CallBeforeDeliveryFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CallBeforeDeliveryFlg) { return OptionalThing.of((CallBeforeDeliveryFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CallBeforeDeliveryFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CallBeforeDeliveryFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CallBeforeDeliveryFlg) { return (CallBeforeDeliveryFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CallBeforeDeliveryFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CallBeforeDeliveryFlg> listAll() {
            return new ArrayList<CallBeforeDeliveryFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CallBeforeDeliveryFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CallBeforeDeliveryFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CallBeforeDeliveryFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CallBeforeDeliveryFlg> clsList = new ArrayList<CallBeforeDeliveryFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CallBeforeDeliveryFlg> groupOf(String groupName) {
            return new ArrayList<CallBeforeDeliveryFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Freezable Protection フラグCD
     */
    public enum FreezableProtectionFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, FreezableProtectionFlg> _codeClsMap = new HashMap<String, FreezableProtectionFlg>();
        private static final Map<String, FreezableProtectionFlg> _nameClsMap = new HashMap<String, FreezableProtectionFlg>();
        static {
            for (FreezableProtectionFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private FreezableProtectionFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.FreezableProtectionFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FreezableProtectionFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof FreezableProtectionFlg) { return OptionalThing.of((FreezableProtectionFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FreezableProtectionFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static FreezableProtectionFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof FreezableProtectionFlg) { return (FreezableProtectionFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static FreezableProtectionFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<FreezableProtectionFlg> listAll() {
            return new ArrayList<FreezableProtectionFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<FreezableProtectionFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: FreezableProtectionFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<FreezableProtectionFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<FreezableProtectionFlg> clsList = new ArrayList<FreezableProtectionFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<FreezableProtectionFlg> groupOf(String groupName) {
            return new ArrayList<FreezableProtectionFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Guaranteed Plus フラグCD
     */
    public enum GuaranteedPlusFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, GuaranteedPlusFlg> _codeClsMap = new HashMap<String, GuaranteedPlusFlg>();
        private static final Map<String, GuaranteedPlusFlg> _nameClsMap = new HashMap<String, GuaranteedPlusFlg>();
        static {
            for (GuaranteedPlusFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private GuaranteedPlusFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.GuaranteedPlusFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<GuaranteedPlusFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof GuaranteedPlusFlg) { return OptionalThing.of((GuaranteedPlusFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<GuaranteedPlusFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static GuaranteedPlusFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof GuaranteedPlusFlg) { return (GuaranteedPlusFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static GuaranteedPlusFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<GuaranteedPlusFlg> listAll() {
            return new ArrayList<GuaranteedPlusFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<GuaranteedPlusFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: GuaranteedPlusFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<GuaranteedPlusFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<GuaranteedPlusFlg> clsList = new ArrayList<GuaranteedPlusFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<GuaranteedPlusFlg> groupOf(String groupName) {
            return new ArrayList<GuaranteedPlusFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Residential Pickup フラグCD
     */
    public enum ResidentialPickupFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, ResidentialPickupFlg> _codeClsMap = new HashMap<String, ResidentialPickupFlg>();
        private static final Map<String, ResidentialPickupFlg> _nameClsMap = new HashMap<String, ResidentialPickupFlg>();
        static {
            for (ResidentialPickupFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ResidentialPickupFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ResidentialPickupFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResidentialPickupFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ResidentialPickupFlg) { return OptionalThing.of((ResidentialPickupFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ResidentialPickupFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ResidentialPickupFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ResidentialPickupFlg) { return (ResidentialPickupFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ResidentialPickupFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ResidentialPickupFlg> listAll() {
            return new ArrayList<ResidentialPickupFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ResidentialPickupFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ResidentialPickupFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ResidentialPickupFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ResidentialPickupFlg> clsList = new ArrayList<ResidentialPickupFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ResidentialPickupFlg> groupOf(String groupName) {
            return new ArrayList<ResidentialPickupFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Do Not Stack Pallets フラグCD
     */
    public enum DoNotStackStackFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, DoNotStackStackFlg> _codeClsMap = new HashMap<String, DoNotStackStackFlg>();
        private static final Map<String, DoNotStackStackFlg> _nameClsMap = new HashMap<String, DoNotStackStackFlg>();
        static {
            for (DoNotStackStackFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DoNotStackStackFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DoNotStackStackFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DoNotStackStackFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DoNotStackStackFlg) { return OptionalThing.of((DoNotStackStackFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DoNotStackStackFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DoNotStackStackFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DoNotStackStackFlg) { return (DoNotStackStackFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DoNotStackStackFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DoNotStackStackFlg> listAll() {
            return new ArrayList<DoNotStackStackFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DoNotStackStackFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DoNotStackStackFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DoNotStackStackFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DoNotStackStackFlg> clsList = new ArrayList<DoNotStackStackFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DoNotStackStackFlg> groupOf(String groupName) {
            return new ArrayList<DoNotStackStackFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Limited Access Delivery フラグCD
     */
    public enum LimitedAccessDeliveryFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, LimitedAccessDeliveryFlg> _codeClsMap = new HashMap<String, LimitedAccessDeliveryFlg>();
        private static final Map<String, LimitedAccessDeliveryFlg> _nameClsMap = new HashMap<String, LimitedAccessDeliveryFlg>();
        static {
            for (LimitedAccessDeliveryFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LimitedAccessDeliveryFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LimitedAccessDeliveryFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitedAccessDeliveryFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LimitedAccessDeliveryFlg) { return OptionalThing.of((LimitedAccessDeliveryFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitedAccessDeliveryFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LimitedAccessDeliveryFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LimitedAccessDeliveryFlg) { return (LimitedAccessDeliveryFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LimitedAccessDeliveryFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LimitedAccessDeliveryFlg> listAll() {
            return new ArrayList<LimitedAccessDeliveryFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LimitedAccessDeliveryFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LimitedAccessDeliveryFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LimitedAccessDeliveryFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LimitedAccessDeliveryFlg> clsList = new ArrayList<LimitedAccessDeliveryFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LimitedAccessDeliveryFlg> groupOf(String groupName) {
            return new ArrayList<LimitedAccessDeliveryFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Limited Access Pickup フラグCD
     */
    public enum LimitedAccessPickupFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, LimitedAccessPickupFlg> _codeClsMap = new HashMap<String, LimitedAccessPickupFlg>();
        private static final Map<String, LimitedAccessPickupFlg> _nameClsMap = new HashMap<String, LimitedAccessPickupFlg>();
        static {
            for (LimitedAccessPickupFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LimitedAccessPickupFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LimitedAccessPickupFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitedAccessPickupFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LimitedAccessPickupFlg) { return OptionalThing.of((LimitedAccessPickupFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitedAccessPickupFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LimitedAccessPickupFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LimitedAccessPickupFlg) { return (LimitedAccessPickupFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LimitedAccessPickupFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LimitedAccessPickupFlg> listAll() {
            return new ArrayList<LimitedAccessPickupFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LimitedAccessPickupFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LimitedAccessPickupFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LimitedAccessPickupFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LimitedAccessPickupFlg> clsList = new ArrayList<LimitedAccessPickupFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LimitedAccessPickupFlg> groupOf(String groupName) {
            return new ArrayList<LimitedAccessPickupFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Over-Sized/Extreme Length フラグCD
     */
    public enum OverSizedFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, OverSizedFlg> _codeClsMap = new HashMap<String, OverSizedFlg>();
        private static final Map<String, OverSizedFlg> _nameClsMap = new HashMap<String, OverSizedFlg>();
        static {
            for (OverSizedFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private OverSizedFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.OverSizedFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OverSizedFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof OverSizedFlg) { return OptionalThing.of((OverSizedFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OverSizedFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static OverSizedFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof OverSizedFlg) { return (OverSizedFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static OverSizedFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<OverSizedFlg> listAll() {
            return new ArrayList<OverSizedFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<OverSizedFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: OverSizedFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<OverSizedFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<OverSizedFlg> clsList = new ArrayList<OverSizedFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<OverSizedFlg> groupOf(String groupName) {
            return new ArrayList<OverSizedFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Poison フラグCD
     */
    public enum PoisonFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, PoisonFlg> _codeClsMap = new HashMap<String, PoisonFlg>();
        private static final Map<String, PoisonFlg> _nameClsMap = new HashMap<String, PoisonFlg>();
        static {
            for (PoisonFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PoisonFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PoisonFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PoisonFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PoisonFlg) { return OptionalThing.of((PoisonFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PoisonFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PoisonFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PoisonFlg) { return (PoisonFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PoisonFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PoisonFlg> listAll() {
            return new ArrayList<PoisonFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PoisonFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PoisonFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PoisonFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PoisonFlg> clsList = new ArrayList<PoisonFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PoisonFlg> groupOf(String groupName) {
            return new ArrayList<PoisonFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Food フラグCD
     */
    public enum FoogFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, FoogFlg> _codeClsMap = new HashMap<String, FoogFlg>();
        private static final Map<String, FoogFlg> _nameClsMap = new HashMap<String, FoogFlg>();
        static {
            for (FoogFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private FoogFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.FoogFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FoogFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof FoogFlg) { return OptionalThing.of((FoogFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FoogFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static FoogFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof FoogFlg) { return (FoogFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static FoogFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<FoogFlg> listAll() {
            return new ArrayList<FoogFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<FoogFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: FoogFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<FoogFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<FoogFlg> clsList = new ArrayList<FoogFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<FoogFlg> groupOf(String groupName) {
            return new ArrayList<FoogFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Liftgate at delivery フラグCD (Prepaid)
     */
    public enum LiftgateDeliveryPrepaidFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, LiftgateDeliveryPrepaidFlg> _codeClsMap = new HashMap<String, LiftgateDeliveryPrepaidFlg>();
        private static final Map<String, LiftgateDeliveryPrepaidFlg> _nameClsMap = new HashMap<String, LiftgateDeliveryPrepaidFlg>();
        static {
            for (LiftgateDeliveryPrepaidFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LiftgateDeliveryPrepaidFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LiftgateDeliveryPrepaidFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgateDeliveryPrepaidFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LiftgateDeliveryPrepaidFlg) { return OptionalThing.of((LiftgateDeliveryPrepaidFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgateDeliveryPrepaidFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LiftgateDeliveryPrepaidFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LiftgateDeliveryPrepaidFlg) { return (LiftgateDeliveryPrepaidFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LiftgateDeliveryPrepaidFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LiftgateDeliveryPrepaidFlg> listAll() {
            return new ArrayList<LiftgateDeliveryPrepaidFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LiftgateDeliveryPrepaidFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LiftgateDeliveryPrepaidFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LiftgateDeliveryPrepaidFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LiftgateDeliveryPrepaidFlg> clsList = new ArrayList<LiftgateDeliveryPrepaidFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LiftgateDeliveryPrepaidFlg> groupOf(String groupName) {
            return new ArrayList<LiftgateDeliveryPrepaidFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Liftgate at delivery フラグCD (Collect)
     */
    public enum LiftgateDeliveryCollectFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, LiftgateDeliveryCollectFlg> _codeClsMap = new HashMap<String, LiftgateDeliveryCollectFlg>();
        private static final Map<String, LiftgateDeliveryCollectFlg> _nameClsMap = new HashMap<String, LiftgateDeliveryCollectFlg>();
        static {
            for (LiftgateDeliveryCollectFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LiftgateDeliveryCollectFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LiftgateDeliveryCollectFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgateDeliveryCollectFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LiftgateDeliveryCollectFlg) { return OptionalThing.of((LiftgateDeliveryCollectFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgateDeliveryCollectFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LiftgateDeliveryCollectFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LiftgateDeliveryCollectFlg) { return (LiftgateDeliveryCollectFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LiftgateDeliveryCollectFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LiftgateDeliveryCollectFlg> listAll() {
            return new ArrayList<LiftgateDeliveryCollectFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LiftgateDeliveryCollectFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LiftgateDeliveryCollectFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LiftgateDeliveryCollectFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LiftgateDeliveryCollectFlg> clsList = new ArrayList<LiftgateDeliveryCollectFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LiftgateDeliveryCollectFlg> groupOf(String groupName) {
            return new ArrayList<LiftgateDeliveryCollectFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Liftgate at pickup フラグCD (Prepaid)
     */
    public enum LiftgatePickupPrepaidFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, LiftgatePickupPrepaidFlg> _codeClsMap = new HashMap<String, LiftgatePickupPrepaidFlg>();
        private static final Map<String, LiftgatePickupPrepaidFlg> _nameClsMap = new HashMap<String, LiftgatePickupPrepaidFlg>();
        static {
            for (LiftgatePickupPrepaidFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LiftgatePickupPrepaidFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LiftgatePickupPrepaidFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgatePickupPrepaidFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LiftgatePickupPrepaidFlg) { return OptionalThing.of((LiftgatePickupPrepaidFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgatePickupPrepaidFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LiftgatePickupPrepaidFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LiftgatePickupPrepaidFlg) { return (LiftgatePickupPrepaidFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LiftgatePickupPrepaidFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LiftgatePickupPrepaidFlg> listAll() {
            return new ArrayList<LiftgatePickupPrepaidFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LiftgatePickupPrepaidFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LiftgatePickupPrepaidFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LiftgatePickupPrepaidFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LiftgatePickupPrepaidFlg> clsList = new ArrayList<LiftgatePickupPrepaidFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LiftgatePickupPrepaidFlg> groupOf(String groupName) {
            return new ArrayList<LiftgatePickupPrepaidFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Liftgate at pickup フラグCD (Collect)
     */
    public enum LiftgatePickupCollectFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, LiftgatePickupCollectFlg> _codeClsMap = new HashMap<String, LiftgatePickupCollectFlg>();
        private static final Map<String, LiftgatePickupCollectFlg> _nameClsMap = new HashMap<String, LiftgatePickupCollectFlg>();
        static {
            for (LiftgatePickupCollectFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LiftgatePickupCollectFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LiftgatePickupCollectFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgatePickupCollectFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LiftgatePickupCollectFlg) { return OptionalThing.of((LiftgatePickupCollectFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LiftgatePickupCollectFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LiftgatePickupCollectFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LiftgatePickupCollectFlg) { return (LiftgatePickupCollectFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LiftgatePickupCollectFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LiftgatePickupCollectFlg> listAll() {
            return new ArrayList<LiftgatePickupCollectFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LiftgatePickupCollectFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LiftgatePickupCollectFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LiftgatePickupCollectFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LiftgatePickupCollectFlg> clsList = new ArrayList<LiftgatePickupCollectFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LiftgatePickupCollectFlg> groupOf(String groupName) {
            return new ArrayList<LiftgatePickupCollectFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Inside Delivery フラグCD (Prepaid)
     */
    public enum InsideDeliveryPrepaidFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, InsideDeliveryPrepaidFlg> _codeClsMap = new HashMap<String, InsideDeliveryPrepaidFlg>();
        private static final Map<String, InsideDeliveryPrepaidFlg> _nameClsMap = new HashMap<String, InsideDeliveryPrepaidFlg>();
        static {
            for (InsideDeliveryPrepaidFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InsideDeliveryPrepaidFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InsideDeliveryPrepaidFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsideDeliveryPrepaidFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InsideDeliveryPrepaidFlg) { return OptionalThing.of((InsideDeliveryPrepaidFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsideDeliveryPrepaidFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InsideDeliveryPrepaidFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InsideDeliveryPrepaidFlg) { return (InsideDeliveryPrepaidFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InsideDeliveryPrepaidFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InsideDeliveryPrepaidFlg> listAll() {
            return new ArrayList<InsideDeliveryPrepaidFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InsideDeliveryPrepaidFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InsideDeliveryPrepaidFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InsideDeliveryPrepaidFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InsideDeliveryPrepaidFlg> clsList = new ArrayList<InsideDeliveryPrepaidFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InsideDeliveryPrepaidFlg> groupOf(String groupName) {
            return new ArrayList<InsideDeliveryPrepaidFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Inside Delivery フラグCD (Collect)
     */
    public enum InsideDeliveryCollectFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, InsideDeliveryCollectFlg> _codeClsMap = new HashMap<String, InsideDeliveryCollectFlg>();
        private static final Map<String, InsideDeliveryCollectFlg> _nameClsMap = new HashMap<String, InsideDeliveryCollectFlg>();
        static {
            for (InsideDeliveryCollectFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InsideDeliveryCollectFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InsideDeliveryCollectFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsideDeliveryCollectFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InsideDeliveryCollectFlg) { return OptionalThing.of((InsideDeliveryCollectFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsideDeliveryCollectFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InsideDeliveryCollectFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InsideDeliveryCollectFlg) { return (InsideDeliveryCollectFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InsideDeliveryCollectFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InsideDeliveryCollectFlg> listAll() {
            return new ArrayList<InsideDeliveryCollectFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InsideDeliveryCollectFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InsideDeliveryCollectFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InsideDeliveryCollectFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InsideDeliveryCollectFlg> clsList = new ArrayList<InsideDeliveryCollectFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InsideDeliveryCollectFlg> groupOf(String groupName) {
            return new ArrayList<InsideDeliveryCollectFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Inside Pickup フラグCD (Prepaid)
     */
    public enum InsidePickupPrepaidFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, InsidePickupPrepaidFlg> _codeClsMap = new HashMap<String, InsidePickupPrepaidFlg>();
        private static final Map<String, InsidePickupPrepaidFlg> _nameClsMap = new HashMap<String, InsidePickupPrepaidFlg>();
        static {
            for (InsidePickupPrepaidFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InsidePickupPrepaidFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InsidePickupPrepaidFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsidePickupPrepaidFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InsidePickupPrepaidFlg) { return OptionalThing.of((InsidePickupPrepaidFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsidePickupPrepaidFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InsidePickupPrepaidFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InsidePickupPrepaidFlg) { return (InsidePickupPrepaidFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InsidePickupPrepaidFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InsidePickupPrepaidFlg> listAll() {
            return new ArrayList<InsidePickupPrepaidFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InsidePickupPrepaidFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InsidePickupPrepaidFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InsidePickupPrepaidFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InsidePickupPrepaidFlg> clsList = new ArrayList<InsidePickupPrepaidFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InsidePickupPrepaidFlg> groupOf(String groupName) {
            return new ArrayList<InsidePickupPrepaidFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * Inside Pickup フラグCD (Collect)
     */
    public enum InsidePickupCollectFlg implements CDef {
        /** $1: Enable */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: Disable */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, InsidePickupCollectFlg> _codeClsMap = new HashMap<String, InsidePickupCollectFlg>();
        private static final Map<String, InsidePickupCollectFlg> _nameClsMap = new HashMap<String, InsidePickupCollectFlg>();
        static {
            for (InsidePickupCollectFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InsidePickupCollectFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InsidePickupCollectFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsidePickupCollectFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InsidePickupCollectFlg) { return OptionalThing.of((InsidePickupCollectFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsidePickupCollectFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InsidePickupCollectFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InsidePickupCollectFlg) { return (InsidePickupCollectFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InsidePickupCollectFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InsidePickupCollectFlg> listAll() {
            return new ArrayList<InsidePickupCollectFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InsidePickupCollectFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InsidePickupCollectFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InsidePickupCollectFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InsidePickupCollectFlg> clsList = new ArrayList<InsidePickupCollectFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InsidePickupCollectFlg> groupOf(String groupName) {
            return new ArrayList<InsidePickupCollectFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 提案ピッキング方法
     */
    public enum RcmdPickingCls implements CDef {
        /** $1: オーダーピッキング */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: トータルピッキング＋摘み取り */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: トータルピッキング＋種蒔き */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: マルチピッキング */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 単行ピッキング */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: ケースピッキング */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, RcmdPickingCls> _codeClsMap = new HashMap<String, RcmdPickingCls>();
        private static final Map<String, RcmdPickingCls> _nameClsMap = new HashMap<String, RcmdPickingCls>();
        static {
            for (RcmdPickingCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private RcmdPickingCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.RcmdPickingCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RcmdPickingCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof RcmdPickingCls) { return OptionalThing.of((RcmdPickingCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RcmdPickingCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static RcmdPickingCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof RcmdPickingCls) { return (RcmdPickingCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static RcmdPickingCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<RcmdPickingCls> listAll() {
            return new ArrayList<RcmdPickingCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<RcmdPickingCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: RcmdPickingCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<RcmdPickingCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<RcmdPickingCls> clsList = new ArrayList<RcmdPickingCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<RcmdPickingCls> groupOf(String groupName) {
            return new ArrayList<RcmdPickingCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 単行ピッキング対象
     */
    public enum SglRowPicTarget implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SglRowPicTarget> _codeClsMap = new HashMap<String, SglRowPicTarget>();
        private static final Map<String, SglRowPicTarget> _nameClsMap = new HashMap<String, SglRowPicTarget>();
        static {
            for (SglRowPicTarget value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SglRowPicTarget(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SglRowPicTarget; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SglRowPicTarget> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SglRowPicTarget) { return OptionalThing.of((SglRowPicTarget)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SglRowPicTarget> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SglRowPicTarget codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SglRowPicTarget) { return (SglRowPicTarget)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SglRowPicTarget nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SglRowPicTarget> listAll() {
            return new ArrayList<SglRowPicTarget>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SglRowPicTarget> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SglRowPicTarget." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SglRowPicTarget> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SglRowPicTarget> clsList = new ArrayList<SglRowPicTarget>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SglRowPicTarget> groupOf(String groupName) {
            return new ArrayList<SglRowPicTarget>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ケースピッキング対象
     */
    public enum CasePicTarget implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CasePicTarget> _codeClsMap = new HashMap<String, CasePicTarget>();
        private static final Map<String, CasePicTarget> _nameClsMap = new HashMap<String, CasePicTarget>();
        static {
            for (CasePicTarget value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CasePicTarget(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CasePicTarget; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CasePicTarget> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CasePicTarget) { return OptionalThing.of((CasePicTarget)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CasePicTarget> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CasePicTarget codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CasePicTarget) { return (CasePicTarget)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CasePicTarget nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CasePicTarget> listAll() {
            return new ArrayList<CasePicTarget>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CasePicTarget> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CasePicTarget." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CasePicTarget> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CasePicTarget> clsList = new ArrayList<CasePicTarget>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CasePicTarget> groupOf(String groupName) {
            return new ArrayList<CasePicTarget>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出退勤・休憩
     */
    public enum AttendanceLeavingRest implements CDef {
        /** $1: 出勤 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 退勤 */
        $2("2", "$2", emptyStrings())
        ,
        /** $4: 休憩開始 */
        $4("4", "$4", emptyStrings())
        ,
        /** $8: 休憩終了 */
        $8("8", "$8", emptyStrings())
        ;
        private static final Map<String, AttendanceLeavingRest> _codeClsMap = new HashMap<String, AttendanceLeavingRest>();
        private static final Map<String, AttendanceLeavingRest> _nameClsMap = new HashMap<String, AttendanceLeavingRest>();
        static {
            for (AttendanceLeavingRest value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AttendanceLeavingRest(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AttendanceLeavingRest; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AttendanceLeavingRest> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AttendanceLeavingRest) { return OptionalThing.of((AttendanceLeavingRest)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AttendanceLeavingRest> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AttendanceLeavingRest codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AttendanceLeavingRest) { return (AttendanceLeavingRest)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AttendanceLeavingRest nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AttendanceLeavingRest> listAll() {
            return new ArrayList<AttendanceLeavingRest>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AttendanceLeavingRest> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AttendanceLeavingRest." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AttendanceLeavingRest> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AttendanceLeavingRest> clsList = new ArrayList<AttendanceLeavingRest>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AttendanceLeavingRest> groupOf(String groupName) {
            return new ArrayList<AttendanceLeavingRest>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 郵便番号種別
     */
    public enum UploadZipType implements CDef {
        /** $0: 住所 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 事業所 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, UploadZipType> _codeClsMap = new HashMap<String, UploadZipType>();
        private static final Map<String, UploadZipType> _nameClsMap = new HashMap<String, UploadZipType>();
        static {
            for (UploadZipType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private UploadZipType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.UploadZipType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UploadZipType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof UploadZipType) { return OptionalThing.of((UploadZipType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UploadZipType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static UploadZipType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof UploadZipType) { return (UploadZipType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static UploadZipType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<UploadZipType> listAll() {
            return new ArrayList<UploadZipType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<UploadZipType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: UploadZipType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<UploadZipType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<UploadZipType> clsList = new ArrayList<UploadZipType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<UploadZipType> groupOf(String groupName) {
            return new ArrayList<UploadZipType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * FW
     */
    public enum FwType implements CDef {
        /** $1: 特定品種 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, FwType> _codeClsMap = new HashMap<String, FwType>();
        private static final Map<String, FwType> _nameClsMap = new HashMap<String, FwType>();
        static {
            for (FwType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private FwType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.FwType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FwType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof FwType) { return OptionalThing.of((FwType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FwType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static FwType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof FwType) { return (FwType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static FwType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<FwType> listAll() {
            return new ArrayList<FwType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<FwType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: FwType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<FwType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<FwType> clsList = new ArrayList<FwType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<FwType> groupOf(String groupName) {
            return new ArrayList<FwType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * MCA
     */
    public enum McaType implements CDef {
        /** $1: 特定品種 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, McaType> _codeClsMap = new HashMap<String, McaType>();
        private static final Map<String, McaType> _nameClsMap = new HashMap<String, McaType>();
        static {
            for (McaType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private McaType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.McaType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<McaType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof McaType) { return OptionalThing.of((McaType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<McaType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static McaType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof McaType) { return (McaType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static McaType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<McaType> listAll() {
            return new ArrayList<McaType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<McaType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: McaType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<McaType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<McaType> clsList = new ArrayList<McaType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<McaType> groupOf(String groupName) {
            return new ArrayList<McaType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 得意先フラグ
     */
    public enum AccountFlg implements CDef {
        /** $0: 使用しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, AccountFlg> _codeClsMap = new HashMap<String, AccountFlg>();
        private static final Map<String, AccountFlg> _nameClsMap = new HashMap<String, AccountFlg>();
        static {
            for (AccountFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AccountFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AccountFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AccountFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AccountFlg) { return OptionalThing.of((AccountFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AccountFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AccountFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AccountFlg) { return (AccountFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AccountFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AccountFlg> listAll() {
            return new ArrayList<AccountFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AccountFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AccountFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AccountFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AccountFlg> clsList = new ArrayList<AccountFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AccountFlg> groupOf(String groupName) {
            return new ArrayList<AccountFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * アラーム区分
     */
    public enum AlarmReasonCls implements CDef {
        /** $01: 荷揃対象データ無し */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 戸配区分マスタ不一致 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 論理在庫欠品 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: 運送業者登録無し(指定) */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: 運送業者該当無し(戸配) */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: 運送業者該当無し(店送り) */
        $06("06", "$06", emptyStrings())
        ,
        /** $07: 運送業者該当無し(直送) */
        $07("07", "$07", emptyStrings())
        ,
        /** $08: 運送業者休日振替(出荷日) */
        $08("08", "$08", emptyStrings())
        ,
        /** $09: 運送業者休日(配送日) */
        $09("09", "$09", emptyStrings())
        ,
        /** $10: 運送業者振替(大物) */
        $10("10", "$10", emptyStrings())
        ,
        /** $11: 運送業者振替(重量物) */
        $11("11", "$11", emptyStrings())
        ,
        /** $12: 荷揃処理エラー */
        $12("12", "$12", emptyStrings())
        ;
        private static final Map<String, AlarmReasonCls> _codeClsMap = new HashMap<String, AlarmReasonCls>();
        private static final Map<String, AlarmReasonCls> _nameClsMap = new HashMap<String, AlarmReasonCls>();
        static {
            for (AlarmReasonCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AlarmReasonCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AlarmReasonCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AlarmReasonCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AlarmReasonCls) { return OptionalThing.of((AlarmReasonCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AlarmReasonCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AlarmReasonCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AlarmReasonCls) { return (AlarmReasonCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AlarmReasonCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AlarmReasonCls> listAll() {
            return new ArrayList<AlarmReasonCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AlarmReasonCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AlarmReasonCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AlarmReasonCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AlarmReasonCls> clsList = new ArrayList<AlarmReasonCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AlarmReasonCls> groupOf(String groupName) {
            return new ArrayList<AlarmReasonCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * アラーム種別
     */
    public enum AlarmType implements CDef {
        /** $0: エラー */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 警告 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, AlarmType> _codeClsMap = new HashMap<String, AlarmType>();
        private static final Map<String, AlarmType> _nameClsMap = new HashMap<String, AlarmType>();
        static {
            for (AlarmType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AlarmType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AlarmType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AlarmType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AlarmType) { return OptionalThing.of((AlarmType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AlarmType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AlarmType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AlarmType) { return (AlarmType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AlarmType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AlarmType> listAll() {
            return new ArrayList<AlarmType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AlarmType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AlarmType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AlarmType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AlarmType> clsList = new ArrayList<AlarmType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AlarmType> groupOf(String groupName) {
            return new ArrayList<AlarmType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * エリア
     */
    public enum AreaCls implements CDef {
        /** $0: 0 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 1 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 2 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, AreaCls> _codeClsMap = new HashMap<String, AreaCls>();
        private static final Map<String, AreaCls> _nameClsMap = new HashMap<String, AreaCls>();
        static {
            for (AreaCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AreaCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AreaCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AreaCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AreaCls) { return OptionalThing.of((AreaCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AreaCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AreaCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AreaCls) { return (AreaCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AreaCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AreaCls> listAll() {
            return new ArrayList<AreaCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AreaCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AreaCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AreaCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AreaCls> clsList = new ArrayList<AreaCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AreaCls> groupOf(String groupName) {
            return new ArrayList<AreaCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 仕分状態
     */
    public enum AssortStatus implements CDef {
        /** $0: ピッキング中 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ピッキング完了 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 仕分完了 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, AssortStatus> _codeClsMap = new HashMap<String, AssortStatus>();
        private static final Map<String, AssortStatus> _nameClsMap = new HashMap<String, AssortStatus>();
        static {
            for (AssortStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private AssortStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.AssortStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AssortStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof AssortStatus) { return OptionalThing.of((AssortStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<AssortStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static AssortStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof AssortStatus) { return (AssortStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static AssortStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<AssortStatus> listAll() {
            return new ArrayList<AssortStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<AssortStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: AssortStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<AssortStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<AssortStatus> clsList = new ArrayList<AssortStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<AssortStatus> groupOf(String groupName) {
            return new ArrayList<AssortStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 拠点区分
     */
    public enum BaseCls implements CDef {
        /** $2000: 草加 */
        $2000("2000", "$2000", emptyStrings())
        ,
        /** $2300: 越谷 */
        $2300("2300", "$2300", emptyStrings())
        ,
        /** $2400: リテイル小菅 */
        $2400("2400", "$2400", emptyStrings())
        ,
        /** $2500: リテイル越谷 */
        $2500("2500", "$2500", emptyStrings())
        ,
        /** $5000: 東北ミドリ */
        $5000("5000", "$5000", emptyStrings())
        ,
        /** $9998: ミドリロジ管轄3PL */
        $9998("9998", "$9998", emptyStrings())
        ,
        /** $9999: ミドリロジ管轄外3PL */
        $9999("9999", "$9999", emptyStrings())
        ;
        private static final Map<String, BaseCls> _codeClsMap = new HashMap<String, BaseCls>();
        private static final Map<String, BaseCls> _nameClsMap = new HashMap<String, BaseCls>();
        static {
            for (BaseCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private BaseCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.BaseCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BaseCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof BaseCls) { return OptionalThing.of((BaseCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BaseCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static BaseCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof BaseCls) { return (BaseCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static BaseCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<BaseCls> listAll() {
            return new ArrayList<BaseCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<BaseCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: BaseCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<BaseCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<BaseCls> clsList = new ArrayList<BaseCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<BaseCls> groupOf(String groupName) {
            return new ArrayList<BaseCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 荷材
     */
    public enum BoxType implements CDef {
        /** $1: ダンボール */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, BoxType> _codeClsMap = new HashMap<String, BoxType>();
        private static final Map<String, BoxType> _nameClsMap = new HashMap<String, BoxType>();
        static {
            for (BoxType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private BoxType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.BoxType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BoxType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof BoxType) { return OptionalThing.of((BoxType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BoxType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static BoxType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof BoxType) { return (BoxType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static BoxType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<BoxType> listAll() {
            return new ArrayList<BoxType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<BoxType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: BoxType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<BoxType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<BoxType> clsList = new ArrayList<BoxType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<BoxType> groupOf(String groupName) {
            return new ArrayList<BoxType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 運送業者
     */
    public enum CarrierType implements CDef {
        /** $JP: 日本郵便 */
        $JP("JP", "$JP", emptyStrings())
        ,
        /** $YMT: ヤマト運輸 */
        $YMT("YMT", "$YMT", emptyStrings())
        ,
        /** $SGW: 佐川急便 */
        $SGW("SGW", "$SGW", emptyStrings())
        ;
        private static final Map<String, CarrierType> _codeClsMap = new HashMap<String, CarrierType>();
        private static final Map<String, CarrierType> _nameClsMap = new HashMap<String, CarrierType>();
        static {
            for (CarrierType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CarrierType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CarrierType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CarrierType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CarrierType) { return OptionalThing.of((CarrierType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CarrierType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CarrierType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CarrierType) { return (CarrierType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CarrierType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CarrierType> listAll() {
            return new ArrayList<CarrierType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CarrierType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CarrierType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CarrierType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CarrierType> clsList = new ArrayList<CarrierType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CarrierType> groupOf(String groupName) {
            return new ArrayList<CarrierType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 運送会社区分
     */
    public enum CarrierTypeCd implements CDef {
        /** $1: ヤマト運輸 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 佐川急便 */
        $2("2", "$2", emptyStrings())
        ,
        /** $6: 飛脚ゆうメール */
        $6("6", "$6", emptyStrings())
        ,
        /** $7: ゆうパケット */
        $7("7", "$7", emptyStrings())
        ;
        private static final Map<String, CarrierTypeCd> _codeClsMap = new HashMap<String, CarrierTypeCd>();
        private static final Map<String, CarrierTypeCd> _nameClsMap = new HashMap<String, CarrierTypeCd>();
        static {
            for (CarrierTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CarrierTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CarrierTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CarrierTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CarrierTypeCd) { return OptionalThing.of((CarrierTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CarrierTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CarrierTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CarrierTypeCd) { return (CarrierTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CarrierTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CarrierTypeCd> listAll() {
            return new ArrayList<CarrierTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CarrierTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CarrierTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CarrierTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CarrierTypeCd> clsList = new ArrayList<CarrierTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CarrierTypeCd> groupOf(String groupName) {
            return new ArrayList<CarrierTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ケース区分
     */
    public enum CaseTypeCd implements CDef {
        /** $Y: ケース */
        $Y("Y", "$Y", emptyStrings())
        ;
        private static final Map<String, CaseTypeCd> _codeClsMap = new HashMap<String, CaseTypeCd>();
        private static final Map<String, CaseTypeCd> _nameClsMap = new HashMap<String, CaseTypeCd>();
        static {
            for (CaseTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CaseTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CaseTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CaseTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CaseTypeCd) { return OptionalThing.of((CaseTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CaseTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CaseTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CaseTypeCd) { return (CaseTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CaseTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CaseTypeCd> listAll() {
            return new ArrayList<CaseTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CaseTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CaseTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CaseTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CaseTypeCd> clsList = new ArrayList<CaseTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CaseTypeCd> groupOf(String groupName) {
            return new ArrayList<CaseTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 締め日
     */
    public enum ClosingDt implements CDef {
        /** $0: 20 */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, ClosingDt> _codeClsMap = new HashMap<String, ClosingDt>();
        private static final Map<String, ClosingDt> _nameClsMap = new HashMap<String, ClosingDt>();
        static {
            for (ClosingDt value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ClosingDt(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ClosingDt; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ClosingDt> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ClosingDt) { return OptionalThing.of((ClosingDt)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ClosingDt> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ClosingDt codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ClosingDt) { return (ClosingDt)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ClosingDt nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ClosingDt> listAll() {
            return new ArrayList<ClosingDt>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ClosingDt> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ClosingDt." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ClosingDt> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ClosingDt> clsList = new ArrayList<ClosingDt>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ClosingDt> groupOf(String groupName) {
            return new ArrayList<ClosingDt>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 完了非表示
     */
    public enum CompletedHidden implements CDef {
        /** $1: 完了非表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CompletedHidden> _codeClsMap = new HashMap<String, CompletedHidden>();
        private static final Map<String, CompletedHidden> _nameClsMap = new HashMap<String, CompletedHidden>();
        static {
            for (CompletedHidden value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CompletedHidden(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CompletedHidden; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CompletedHidden> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CompletedHidden) { return OptionalThing.of((CompletedHidden)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CompletedHidden> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CompletedHidden codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CompletedHidden) { return (CompletedHidden)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CompletedHidden nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CompletedHidden> listAll() {
            return new ArrayList<CompletedHidden>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CompletedHidden> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CompletedHidden." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CompletedHidden> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CompletedHidden> clsList = new ArrayList<CompletedHidden>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CompletedHidden> groupOf(String groupName) {
            return new ArrayList<CompletedHidden>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出力条件
     */
    public enum Condition implements CDef {
        /** $BLDL3350: 0090 */
        $BLDL3350("BLDL3350", "$BLDL3350", emptyStrings())
        ;
        private static final Map<String, Condition> _codeClsMap = new HashMap<String, Condition>();
        private static final Map<String, Condition> _nameClsMap = new HashMap<String, Condition>();
        static {
            for (Condition value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Condition(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Condition; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Condition> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Condition) { return OptionalThing.of((Condition)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Condition> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Condition codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Condition) { return (Condition)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Condition nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Condition> listAll() {
            return new ArrayList<Condition>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Condition> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Condition." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Condition> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Condition> clsList = new ArrayList<Condition>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Condition> groupOf(String groupName) {
            return new ArrayList<Condition>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 建設支店
     */
    public enum Constract implements CDef {
        /** $1: XXXX */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: XXXX */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, Constract> _codeClsMap = new HashMap<String, Constract>();
        private static final Map<String, Constract> _nameClsMap = new HashMap<String, Constract>();
        static {
            for (Constract value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Constract(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Constract; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Constract> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Constract) { return OptionalThing.of((Constract)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Constract> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Constract codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Constract) { return (Constract)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Constract nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Constract> listAll() {
            return new ArrayList<Constract>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Constract> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Constract." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Constract> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Constract> clsList = new ArrayList<Constract>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Constract> groupOf(String groupName) {
            return new ArrayList<Constract>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ケース／バラ区分
     */
    public enum CsPsType implements CDef {
        /** $1: バラ */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ケース */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, CsPsType> _codeClsMap = new HashMap<String, CsPsType>();
        private static final Map<String, CsPsType> _nameClsMap = new HashMap<String, CsPsType>();
        static {
            for (CsPsType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CsPsType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CsPsType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CsPsType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CsPsType) { return OptionalThing.of((CsPsType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CsPsType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CsPsType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CsPsType) { return (CsPsType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CsPsType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CsPsType> listAll() {
            return new ArrayList<CsPsType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CsPsType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CsPsType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CsPsType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CsPsType> clsList = new ArrayList<CsPsType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CsPsType> groupOf(String groupName) {
            return new ArrayList<CsPsType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫区分
     */
    public enum DefaultStockType implements CDef {
        /** $W100: 通常在庫 */
        $W100("W100", "$W100", emptyStrings())
        ;
        private static final Map<String, DefaultStockType> _codeClsMap = new HashMap<String, DefaultStockType>();
        private static final Map<String, DefaultStockType> _nameClsMap = new HashMap<String, DefaultStockType>();
        static {
            for (DefaultStockType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DefaultStockType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DefaultStockType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DefaultStockType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DefaultStockType) { return OptionalThing.of((DefaultStockType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DefaultStockType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DefaultStockType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DefaultStockType) { return (DefaultStockType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DefaultStockType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DefaultStockType> listAll() {
            return new ArrayList<DefaultStockType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DefaultStockType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DefaultStockType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DefaultStockType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DefaultStockType> clsList = new ArrayList<DefaultStockType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DefaultStockType> groupOf(String groupName) {
            return new ArrayList<DefaultStockType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 拠点送り区分(出荷元)
     */
    public enum DelivCenterFrom implements CDef {
        /** $C001: 草加物流センター */
        $C001("C001", "$C001", emptyStrings())
        ,
        /** $C003: 東北ミドリ */
        $C003("C003", "$C003", emptyStrings())
        ;
        private static final Map<String, DelivCenterFrom> _codeClsMap = new HashMap<String, DelivCenterFrom>();
        private static final Map<String, DelivCenterFrom> _nameClsMap = new HashMap<String, DelivCenterFrom>();
        static {
            for (DelivCenterFrom value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DelivCenterFrom(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DelivCenterFrom; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelivCenterFrom> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DelivCenterFrom) { return OptionalThing.of((DelivCenterFrom)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelivCenterFrom> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DelivCenterFrom codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DelivCenterFrom) { return (DelivCenterFrom)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DelivCenterFrom nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DelivCenterFrom> listAll() {
            return new ArrayList<DelivCenterFrom>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DelivCenterFrom> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DelivCenterFrom." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DelivCenterFrom> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DelivCenterFrom> clsList = new ArrayList<DelivCenterFrom>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DelivCenterFrom> groupOf(String groupName) {
            return new ArrayList<DelivCenterFrom>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 拠点送り区分(出荷先)
     */
    public enum DelivCenterTo implements CDef {
        /** $C001: 草加物流センター */
        $C001("C001", "$C001", emptyStrings())
        ,
        /** $C002: 越谷物流センター */
        $C002("C002", "$C002", emptyStrings())
        ,
        /** $C003: 東北ミドリ */
        $C003("C003", "$C003", emptyStrings())
        ,
        /** $C004: リテイル越谷 */
        $C004("C004", "$C004", emptyStrings())
        ,
        /** $C005: リテイル小菅 */
        $C005("C005", "$C005", emptyStrings())
        ;
        private static final Map<String, DelivCenterTo> _codeClsMap = new HashMap<String, DelivCenterTo>();
        private static final Map<String, DelivCenterTo> _nameClsMap = new HashMap<String, DelivCenterTo>();
        static {
            for (DelivCenterTo value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DelivCenterTo(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DelivCenterTo; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelivCenterTo> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DelivCenterTo) { return OptionalThing.of((DelivCenterTo)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DelivCenterTo> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DelivCenterTo codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DelivCenterTo) { return (DelivCenterTo)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DelivCenterTo nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DelivCenterTo> listAll() {
            return new ArrayList<DelivCenterTo>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DelivCenterTo> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DelivCenterTo." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DelivCenterTo> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DelivCenterTo> clsList = new ArrayList<DelivCenterTo>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DelivCenterTo> groupOf(String groupName) {
            return new ArrayList<DelivCenterTo>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 配達指定有無
     */
    public enum DeliveryDtUnspecified implements CDef {
        /** $0: 配達指定日無 */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, DeliveryDtUnspecified> _codeClsMap = new HashMap<String, DeliveryDtUnspecified>();
        private static final Map<String, DeliveryDtUnspecified> _nameClsMap = new HashMap<String, DeliveryDtUnspecified>();
        static {
            for (DeliveryDtUnspecified value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DeliveryDtUnspecified(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DeliveryDtUnspecified; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DeliveryDtUnspecified> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DeliveryDtUnspecified) { return OptionalThing.of((DeliveryDtUnspecified)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DeliveryDtUnspecified> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DeliveryDtUnspecified codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DeliveryDtUnspecified) { return (DeliveryDtUnspecified)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DeliveryDtUnspecified nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DeliveryDtUnspecified> listAll() {
            return new ArrayList<DeliveryDtUnspecified>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DeliveryDtUnspecified> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DeliveryDtUnspecified." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DeliveryDtUnspecified> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DeliveryDtUnspecified> clsList = new ArrayList<DeliveryDtUnspecified>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DeliveryDtUnspecified> groupOf(String groupName) {
            return new ArrayList<DeliveryDtUnspecified>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 配達時間帯
     */
    public enum DeliveryTimeZone implements CDef {
        /** $A: 午前中 */
        $A("A", "$A", emptyStrings())
        ,
        /** $B: 12時～14時 */
        $B("B", "$B", emptyStrings())
        ,
        /** $C: 14時～16時 */
        $C("C", "$C", emptyStrings())
        ,
        /** $D: 16時～18時 */
        $D("D", "$D", emptyStrings())
        ,
        /** $E: 18時～20時 */
        $E("E", "$E", emptyStrings())
        ,
        /** $F: 18時～21時 */
        $F("F", "$F", emptyStrings())
        ,
        /** $G: 19時～21時 */
        $G("G", "$G", emptyStrings())
        ,
        /** $H: 20時～21時 */
        $H("H", "$H", emptyStrings())
        ,
        /** $I: 午前10時まで */
        $I("I", "$I", emptyStrings())
        ,
        /** $J: 午後5時まで */
        $J("J", "$J", emptyStrings())
        ;
        private static final Map<String, DeliveryTimeZone> _codeClsMap = new HashMap<String, DeliveryTimeZone>();
        private static final Map<String, DeliveryTimeZone> _nameClsMap = new HashMap<String, DeliveryTimeZone>();
        static {
            for (DeliveryTimeZone value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DeliveryTimeZone(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DeliveryTimeZone; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DeliveryTimeZone> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DeliveryTimeZone) { return OptionalThing.of((DeliveryTimeZone)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DeliveryTimeZone> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DeliveryTimeZone codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DeliveryTimeZone) { return (DeliveryTimeZone)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DeliveryTimeZone nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DeliveryTimeZone> listAll() {
            return new ArrayList<DeliveryTimeZone>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DeliveryTimeZone> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DeliveryTimeZone." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DeliveryTimeZone> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DeliveryTimeZone> clsList = new ArrayList<DeliveryTimeZone>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DeliveryTimeZone> groupOf(String groupName) {
            return new ArrayList<DeliveryTimeZone>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 配送種別送信対象区分
     */
    public enum DeliveryTypeSendCls implements CDef {
        /** $2700: SGL柏SRC */
        $2700("2700", "$2700", emptyStrings())
        ;
        private static final Map<String, DeliveryTypeSendCls> _codeClsMap = new HashMap<String, DeliveryTypeSendCls>();
        private static final Map<String, DeliveryTypeSendCls> _nameClsMap = new HashMap<String, DeliveryTypeSendCls>();
        static {
            for (DeliveryTypeSendCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DeliveryTypeSendCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DeliveryTypeSendCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DeliveryTypeSendCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DeliveryTypeSendCls) { return OptionalThing.of((DeliveryTypeSendCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DeliveryTypeSendCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DeliveryTypeSendCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DeliveryTypeSendCls) { return (DeliveryTypeSendCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DeliveryTypeSendCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DeliveryTypeSendCls> listAll() {
            return new ArrayList<DeliveryTypeSendCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DeliveryTypeSendCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DeliveryTypeSendCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DeliveryTypeSendCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DeliveryTypeSendCls> clsList = new ArrayList<DeliveryTypeSendCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DeliveryTypeSendCls> groupOf(String groupName) {
            return new ArrayList<DeliveryTypeSendCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 預り品
     */
    public enum DepositItemFlg implements CDef {
        /** $1: 預り品 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DepositItemFlg> _codeClsMap = new HashMap<String, DepositItemFlg>();
        private static final Map<String, DepositItemFlg> _nameClsMap = new HashMap<String, DepositItemFlg>();
        static {
            for (DepositItemFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DepositItemFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DepositItemFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DepositItemFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DepositItemFlg) { return OptionalThing.of((DepositItemFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DepositItemFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DepositItemFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DepositItemFlg) { return (DepositItemFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DepositItemFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DepositItemFlg> listAll() {
            return new ArrayList<DepositItemFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DepositItemFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DepositItemFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DepositItemFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DepositItemFlg> clsList = new ArrayList<DepositItemFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DepositItemFlg> groupOf(String groupName) {
            return new ArrayList<DepositItemFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 取引区分
     */
    public enum DepositType implements CDef {
        /** $11: 店預かり */
        $11("11", "$11", emptyStrings())
        ,
        /** $39: ユーザ預かり */
        $39("39", "$39", emptyStrings())
        ,
        /** $49: ユーザ預かり */
        $49("49", "$49", emptyStrings())
        ;
        private static final Map<String, DepositType> _codeClsMap = new HashMap<String, DepositType>();
        private static final Map<String, DepositType> _nameClsMap = new HashMap<String, DepositType>();
        static {
            for (DepositType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DepositType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DepositType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DepositType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DepositType) { return OptionalThing.of((DepositType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DepositType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DepositType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DepositType) { return (DepositType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DepositType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DepositType> listAll() {
            return new ArrayList<DepositType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DepositType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DepositType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DepositType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DepositType> clsList = new ArrayList<DepositType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DepositType> groupOf(String groupName) {
            return new ArrayList<DepositType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 差異
     */
    public enum DiffCls implements CDef {
        /** $1: マイナスのみ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DiffCls> _codeClsMap = new HashMap<String, DiffCls>();
        private static final Map<String, DiffCls> _nameClsMap = new HashMap<String, DiffCls>();
        static {
            for (DiffCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DiffCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DiffCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DiffCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DiffCls) { return OptionalThing.of((DiffCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DiffCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DiffCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DiffCls) { return (DiffCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DiffCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DiffCls> listAll() {
            return new ArrayList<DiffCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DiffCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DiffCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DiffCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DiffCls> clsList = new ArrayList<DiffCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DiffCls> groupOf(String groupName) {
            return new ArrayList<DiffCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 直送区分
     */
    public enum DirectDeliveryTypeCd implements CDef {
        /** $1: 直送 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, DirectDeliveryTypeCd> _codeClsMap = new HashMap<String, DirectDeliveryTypeCd>();
        private static final Map<String, DirectDeliveryTypeCd> _nameClsMap = new HashMap<String, DirectDeliveryTypeCd>();
        static {
            for (DirectDeliveryTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DirectDeliveryTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DirectDeliveryTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DirectDeliveryTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DirectDeliveryTypeCd) { return OptionalThing.of((DirectDeliveryTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DirectDeliveryTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DirectDeliveryTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DirectDeliveryTypeCd) { return (DirectDeliveryTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DirectDeliveryTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DirectDeliveryTypeCd> listAll() {
            return new ArrayList<DirectDeliveryTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DirectDeliveryTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DirectDeliveryTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DirectDeliveryTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DirectDeliveryTypeCd> clsList = new ArrayList<DirectDeliveryTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DirectDeliveryTypeCd> groupOf(String groupName) {
            return new ArrayList<DirectDeliveryTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * EC受注
     */
    public enum EcOrder implements CDef {
        /** $ZBB7: EC受注 */
        $ZBB7("ZBB7", "$ZBB7", emptyStrings())
        ;
        private static final Map<String, EcOrder> _codeClsMap = new HashMap<String, EcOrder>();
        private static final Map<String, EcOrder> _nameClsMap = new HashMap<String, EcOrder>();
        static {
            for (EcOrder value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private EcOrder(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.EcOrder; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EcOrder> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof EcOrder) { return OptionalThing.of((EcOrder)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EcOrder> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static EcOrder codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof EcOrder) { return (EcOrder)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static EcOrder nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<EcOrder> listAll() {
            return new ArrayList<EcOrder>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<EcOrder> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: EcOrder." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<EcOrder> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<EcOrder> clsList = new ArrayList<EcOrder>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<EcOrder> groupOf(String groupName) {
            return new ArrayList<EcOrder>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * EC区分
     */
    public enum EcType implements CDef {
        /** $1: 通常計算 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ECユーザ */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, EcType> _codeClsMap = new HashMap<String, EcType>();
        private static final Map<String, EcType> _nameClsMap = new HashMap<String, EcType>();
        static {
            for (EcType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private EcType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.EcType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EcType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof EcType) { return OptionalThing.of((EcType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<EcType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static EcType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof EcType) { return (EcType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static EcType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<EcType> listAll() {
            return new ArrayList<EcType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<EcType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: EcType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<EcType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<EcType> clsList = new ArrayList<EcType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<EcType> groupOf(String groupName) {
            return new ArrayList<EcType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 実行ステータス
     */
    public enum ExecuteStatus implements CDef {
        /** $01: 実行中 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 正常終了 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 異常終了 */
        $03("03", "$03", emptyStrings())
        ;
        private static final Map<String, ExecuteStatus> _codeClsMap = new HashMap<String, ExecuteStatus>();
        private static final Map<String, ExecuteStatus> _nameClsMap = new HashMap<String, ExecuteStatus>();
        static {
            for (ExecuteStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ExecuteStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ExecuteStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ExecuteStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ExecuteStatus) { return OptionalThing.of((ExecuteStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ExecuteStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ExecuteStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ExecuteStatus) { return (ExecuteStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ExecuteStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ExecuteStatus> listAll() {
            return new ArrayList<ExecuteStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ExecuteStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ExecuteStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ExecuteStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ExecuteStatus> clsList = new ArrayList<ExecuteStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ExecuteStatus> groupOf(String groupName) {
            return new ArrayList<ExecuteStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 手数料
     */
    public enum Fee implements CDef {
        /** $BLDL350N: 540 */
        $BLDL350N("BLDL350N", "$BLDL350N", emptyStrings())
        ,
        /** $BLDL350K: 540 */
        $BLDL350K("BLDL350K", "$BLDL350K", emptyStrings())
        ,
        /** $BLDL6760: 500 */
        $BLDL6760("BLDL6760", "$BLDL6760", emptyStrings())
        ,
        /** $BLDL3350: 540 */
        $BLDL3350("BLDL3350", "$BLDL3350", emptyStrings())
        ,
        /** $BLDL3390: 300 */
        $BLDL3390("BLDL3390", "$BLDL3390", emptyStrings())
        ,
        /** $BLDL3310: 300 */
        $BLDL3310("BLDL3310", "$BLDL3310", emptyStrings())
        ;
        private static final Map<String, Fee> _codeClsMap = new HashMap<String, Fee>();
        private static final Map<String, Fee> _nameClsMap = new HashMap<String, Fee>();
        static {
            for (Fee value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Fee(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Fee; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Fee> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Fee) { return OptionalThing.of((Fee)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Fee> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Fee codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Fee) { return (Fee)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Fee nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Fee> listAll() {
            return new ArrayList<Fee>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Fee> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Fee." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Fee> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Fee> clsList = new ArrayList<Fee>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Fee> groupOf(String groupName) {
            return new ArrayList<Fee>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * フロア
     */
    public enum Floor implements CDef {
        /** $2002: 4F */
        $2002("2002", "$2002", emptyStrings())
        ,
        /** $2000: 3F */
        $2000("2000", "$2000", emptyStrings())
        ;
        private static final Map<String, Floor> _codeClsMap = new HashMap<String, Floor>();
        private static final Map<String, Floor> _nameClsMap = new HashMap<String, Floor>();
        static {
            for (Floor value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Floor(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Floor; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Floor> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Floor) { return OptionalThing.of((Floor)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Floor> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Floor codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Floor) { return (Floor)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Floor nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Floor> listAll() {
            return new ArrayList<Floor>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Floor> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Floor." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Floor> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Floor> clsList = new ArrayList<Floor>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Floor> groupOf(String groupName) {
            return new ArrayList<Floor>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * フロアCD
     */
    public enum FloorCd implements CDef {
        /** $01: 1F */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 2F */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 3F */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: 4F */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: 5F */
        $05("05", "$05", emptyStrings())
        ;
        private static final Map<String, FloorCd> _codeClsMap = new HashMap<String, FloorCd>();
        private static final Map<String, FloorCd> _nameClsMap = new HashMap<String, FloorCd>();
        static {
            for (FloorCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private FloorCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.FloorCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FloorCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof FloorCd) { return OptionalThing.of((FloorCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FloorCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static FloorCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof FloorCd) { return (FloorCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static FloorCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<FloorCd> listAll() {
            return new ArrayList<FloorCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<FloorCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: FloorCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<FloorCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<FloorCd> clsList = new ArrayList<FloorCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<FloorCd> groupOf(String groupName) {
            return new ArrayList<FloorCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * フロア完結
     */
    public enum FloorEndFlg implements CDef {
        /** $0: 完結しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 完結する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, FloorEndFlg> _codeClsMap = new HashMap<String, FloorEndFlg>();
        private static final Map<String, FloorEndFlg> _nameClsMap = new HashMap<String, FloorEndFlg>();
        static {
            for (FloorEndFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private FloorEndFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.FloorEndFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FloorEndFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof FloorEndFlg) { return OptionalThing.of((FloorEndFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FloorEndFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static FloorEndFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof FloorEndFlg) { return (FloorEndFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static FloorEndFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<FloorEndFlg> listAll() {
            return new ArrayList<FloorEndFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<FloorEndFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: FloorEndFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<FloorEndFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<FloorEndFlg> clsList = new ArrayList<FloorEndFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<FloorEndFlg> groupOf(String groupName) {
            return new ArrayList<FloorEndFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * フロア区分(保管場所区分)
     */
    public enum FloorTypeCd implements CDef {
        /** $1: 越谷３F */
        $1("1", "$1", emptyStrings())
        ,
        /** $3: 越谷ユニフォームステーション出荷で３F保管商品の場合 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 上記以外の場合 */
        $4("4", "$4", emptyStrings())
        ;
        private static final Map<String, FloorTypeCd> _codeClsMap = new HashMap<String, FloorTypeCd>();
        private static final Map<String, FloorTypeCd> _nameClsMap = new HashMap<String, FloorTypeCd>();
        static {
            for (FloorTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private FloorTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.FloorTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FloorTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof FloorTypeCd) { return OptionalThing.of((FloorTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<FloorTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static FloorTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof FloorTypeCd) { return (FloorTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static FloorTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<FloorTypeCd> listAll() {
            return new ArrayList<FloorTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<FloorTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: FloorTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<FloorTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<FloorTypeCd> clsList = new ArrayList<FloorTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<FloorTypeCd> groupOf(String groupName) {
            return new ArrayList<FloorTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 引き渡しステータス
     */
    public enum HandOverStatus implements CDef {
        /** $0: 引き渡し前 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 引き渡し済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 出荷送信済 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, HandOverStatus> _codeClsMap = new HashMap<String, HandOverStatus>();
        private static final Map<String, HandOverStatus> _nameClsMap = new HashMap<String, HandOverStatus>();
        static {
            for (HandOverStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private HandOverStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.HandOverStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HandOverStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof HandOverStatus) { return OptionalThing.of((HandOverStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HandOverStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static HandOverStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof HandOverStatus) { return (HandOverStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static HandOverStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<HandOverStatus> listAll() {
            return new ArrayList<HandOverStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<HandOverStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: HandOverStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<HandOverStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<HandOverStatus> clsList = new ArrayList<HandOverStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<HandOverStatus> groupOf(String groupName) {
            return new ArrayList<HandOverStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 取扱方法
     */
    public enum HandlingType implements CDef {
        /** $0: 直送 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 納品 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 緊急 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, HandlingType> _codeClsMap = new HashMap<String, HandlingType>();
        private static final Map<String, HandlingType> _nameClsMap = new HashMap<String, HandlingType>();
        static {
            for (HandlingType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private HandlingType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.HandlingType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HandlingType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof HandlingType) { return OptionalThing.of((HandlingType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HandlingType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static HandlingType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof HandlingType) { return (HandlingType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static HandlingType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<HandlingType> listAll() {
            return new ArrayList<HandlingType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<HandlingType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: HandlingType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<HandlingType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<HandlingType> clsList = new ArrayList<HandlingType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<HandlingType> groupOf(String groupName) {
            return new ArrayList<HandlingType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 重量フラグ
     */
    public enum HeavyItemFlg implements CDef {
        /** $0: 使用しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, HeavyItemFlg> _codeClsMap = new HashMap<String, HeavyItemFlg>();
        private static final Map<String, HeavyItemFlg> _nameClsMap = new HashMap<String, HeavyItemFlg>();
        static {
            for (HeavyItemFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private HeavyItemFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.HeavyItemFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HeavyItemFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof HeavyItemFlg) { return OptionalThing.of((HeavyItemFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HeavyItemFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static HeavyItemFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof HeavyItemFlg) { return (HeavyItemFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static HeavyItemFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<HeavyItemFlg> listAll() {
            return new ArrayList<HeavyItemFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<HeavyItemFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: HeavyItemFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<HeavyItemFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<HeavyItemFlg> clsList = new ArrayList<HeavyItemFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<HeavyItemFlg> groupOf(String groupName) {
            return new ArrayList<HeavyItemFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 重量取扱フラグ
     */
    public enum HeavyItemHadlingFlg implements CDef {
        /** $0: 使用しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, HeavyItemHadlingFlg> _codeClsMap = new HashMap<String, HeavyItemHadlingFlg>();
        private static final Map<String, HeavyItemHadlingFlg> _nameClsMap = new HashMap<String, HeavyItemHadlingFlg>();
        static {
            for (HeavyItemHadlingFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private HeavyItemHadlingFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.HeavyItemHadlingFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HeavyItemHadlingFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof HeavyItemHadlingFlg) { return OptionalThing.of((HeavyItemHadlingFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HeavyItemHadlingFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static HeavyItemHadlingFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof HeavyItemHadlingFlg) { return (HeavyItemHadlingFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static HeavyItemHadlingFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<HeavyItemHadlingFlg> listAll() {
            return new ArrayList<HeavyItemHadlingFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<HeavyItemHadlingFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: HeavyItemHadlingFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<HeavyItemHadlingFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<HeavyItemHadlingFlg> clsList = new ArrayList<HeavyItemHadlingFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<HeavyItemHadlingFlg> groupOf(String groupName) {
            return new ArrayList<HeavyItemHadlingFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 品目グループ
     */
    public enum HinmokuGroupCd implements CDef {
        /** $10: フットウエア(セフティ) */
        $10("10", "$10", emptyStrings())
        ,
        /** $20: フットウエア(ワーク) */
        $20("20", "$20", emptyStrings())
        ,
        /** $30: ユニフォーム */
        $30("30", "$30", emptyStrings())
        ,
        /** $40: セフティ＆ヘルス */
        $40("40", "$40", emptyStrings())
        ,
        /** $45: ヘルメット */
        $45("45", "$45", emptyStrings())
        ,
        /** $50: 電気計測 */
        $50("50", "$50", emptyStrings())
        ,
        /** $60: クリーンシステム */
        $60("60", "$60", emptyStrings())
        ,
        /** $70: メディカル */
        $70("70", "$70", emptyStrings())
        ;
        private static final Map<String, HinmokuGroupCd> _codeClsMap = new HashMap<String, HinmokuGroupCd>();
        private static final Map<String, HinmokuGroupCd> _nameClsMap = new HashMap<String, HinmokuGroupCd>();
        static {
            for (HinmokuGroupCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private HinmokuGroupCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.HinmokuGroupCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HinmokuGroupCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof HinmokuGroupCd) { return OptionalThing.of((HinmokuGroupCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HinmokuGroupCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static HinmokuGroupCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof HinmokuGroupCd) { return (HinmokuGroupCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static HinmokuGroupCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<HinmokuGroupCd> listAll() {
            return new ArrayList<HinmokuGroupCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<HinmokuGroupCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: HinmokuGroupCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<HinmokuGroupCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<HinmokuGroupCd> clsList = new ArrayList<HinmokuGroupCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<HinmokuGroupCd> groupOf(String groupName) {
            return new ArrayList<HinmokuGroupCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 休日
     */
    public enum HolidayFlg implements CDef {
        /** $0: 休日でない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 休日 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, HolidayFlg> _codeClsMap = new HashMap<String, HolidayFlg>();
        private static final Map<String, HolidayFlg> _nameClsMap = new HashMap<String, HolidayFlg>();
        static {
            for (HolidayFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private HolidayFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.HolidayFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HolidayFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof HolidayFlg) { return OptionalThing.of((HolidayFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HolidayFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static HolidayFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof HolidayFlg) { return (HolidayFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static HolidayFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<HolidayFlg> listAll() {
            return new ArrayList<HolidayFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<HolidayFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: HolidayFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<HolidayFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<HolidayFlg> clsList = new ArrayList<HolidayFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<HolidayFlg> groupOf(String groupName) {
            return new ArrayList<HolidayFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 個体管理廃止区分
     */
    public enum IdManagAbolitionTypeCd implements CDef {
        /** $Y: この出庫日での管理を廃止する */
        $Y("Y", "$Y", emptyStrings())
        ;
        private static final Map<String, IdManagAbolitionTypeCd> _codeClsMap = new HashMap<String, IdManagAbolitionTypeCd>();
        private static final Map<String, IdManagAbolitionTypeCd> _nameClsMap = new HashMap<String, IdManagAbolitionTypeCd>();
        static {
            for (IdManagAbolitionTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private IdManagAbolitionTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.IdManagAbolitionTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<IdManagAbolitionTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof IdManagAbolitionTypeCd) { return OptionalThing.of((IdManagAbolitionTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<IdManagAbolitionTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static IdManagAbolitionTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof IdManagAbolitionTypeCd) { return (IdManagAbolitionTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static IdManagAbolitionTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<IdManagAbolitionTypeCd> listAll() {
            return new ArrayList<IdManagAbolitionTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<IdManagAbolitionTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: IdManagAbolitionTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<IdManagAbolitionTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<IdManagAbolitionTypeCd> clsList = new ArrayList<IdManagAbolitionTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<IdManagAbolitionTypeCd> groupOf(String groupName) {
            return new ArrayList<IdManagAbolitionTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 保険品フラグ
     */
    public enum InsuranceFlg implements CDef {
        /** $0: 使用しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InsuranceFlg> _codeClsMap = new HashMap<String, InsuranceFlg>();
        private static final Map<String, InsuranceFlg> _nameClsMap = new HashMap<String, InsuranceFlg>();
        static {
            for (InsuranceFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InsuranceFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InsuranceFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsuranceFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InsuranceFlg) { return OptionalThing.of((InsuranceFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InsuranceFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InsuranceFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InsuranceFlg) { return (InsuranceFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InsuranceFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InsuranceFlg> listAll() {
            return new ArrayList<InsuranceFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InsuranceFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InsuranceFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InsuranceFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InsuranceFlg> clsList = new ArrayList<InsuranceFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InsuranceFlg> groupOf(String groupName) {
            return new ArrayList<InsuranceFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 棚卸データ状況
     */
    public enum InventoryDataStatus implements CDef {
        /** $00: 未作成 */
        $00("00", "$00", emptyStrings())
        ,
        /** $01: 作成済 */
        $01("01", "$01", emptyStrings())
        ;
        private static final Map<String, InventoryDataStatus> _codeClsMap = new HashMap<String, InventoryDataStatus>();
        private static final Map<String, InventoryDataStatus> _nameClsMap = new HashMap<String, InventoryDataStatus>();
        static {
            for (InventoryDataStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InventoryDataStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InventoryDataStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryDataStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InventoryDataStatus) { return OptionalThing.of((InventoryDataStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryDataStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InventoryDataStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InventoryDataStatus) { return (InventoryDataStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InventoryDataStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InventoryDataStatus> listAll() {
            return new ArrayList<InventoryDataStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InventoryDataStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InventoryDataStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InventoryDataStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InventoryDataStatus> clsList = new ArrayList<InventoryDataStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InventoryDataStatus> groupOf(String groupName) {
            return new ArrayList<InventoryDataStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 棚卸差異
     */
    public enum InventoryDiffCls implements CDef {
        /** $01: 差異ありのみ出力 */
        $01("01", "$01", emptyStrings())
        ;
        private static final Map<String, InventoryDiffCls> _codeClsMap = new HashMap<String, InventoryDiffCls>();
        private static final Map<String, InventoryDiffCls> _nameClsMap = new HashMap<String, InventoryDiffCls>();
        static {
            for (InventoryDiffCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InventoryDiffCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InventoryDiffCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryDiffCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InventoryDiffCls) { return OptionalThing.of((InventoryDiffCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryDiffCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InventoryDiffCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InventoryDiffCls) { return (InventoryDiffCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InventoryDiffCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InventoryDiffCls> listAll() {
            return new ArrayList<InventoryDiffCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InventoryDiffCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InventoryDiffCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InventoryDiffCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InventoryDiffCls> clsList = new ArrayList<InventoryDiffCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InventoryDiffCls> groupOf(String groupName) {
            return new ArrayList<InventoryDiffCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 棚卸入力有
     */
    public enum InventoryInputCls implements CDef {
        /** $0: 棚卸入力無のみ表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 棚卸入力有のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, InventoryInputCls> _codeClsMap = new HashMap<String, InventoryInputCls>();
        private static final Map<String, InventoryInputCls> _nameClsMap = new HashMap<String, InventoryInputCls>();
        static {
            for (InventoryInputCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InventoryInputCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InventoryInputCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryInputCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InventoryInputCls) { return OptionalThing.of((InventoryInputCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryInputCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InventoryInputCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InventoryInputCls) { return (InventoryInputCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InventoryInputCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InventoryInputCls> listAll() {
            return new ArrayList<InventoryInputCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InventoryInputCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InventoryInputCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InventoryInputCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InventoryInputCls> clsList = new ArrayList<InventoryInputCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InventoryInputCls> groupOf(String groupName) {
            return new ArrayList<InventoryInputCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 棚卸リスト発行区分
     */
    public enum InventoryListOutCls implements CDef {
        /** $01: 未出力のロケのみ出力 */
        $01("01", "$01", emptyStrings())
        ;
        private static final Map<String, InventoryListOutCls> _codeClsMap = new HashMap<String, InventoryListOutCls>();
        private static final Map<String, InventoryListOutCls> _nameClsMap = new HashMap<String, InventoryListOutCls>();
        static {
            for (InventoryListOutCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InventoryListOutCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InventoryListOutCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryListOutCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InventoryListOutCls) { return OptionalThing.of((InventoryListOutCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryListOutCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InventoryListOutCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InventoryListOutCls) { return (InventoryListOutCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InventoryListOutCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InventoryListOutCls> listAll() {
            return new ArrayList<InventoryListOutCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InventoryListOutCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InventoryListOutCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InventoryListOutCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InventoryListOutCls> clsList = new ArrayList<InventoryListOutCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InventoryListOutCls> groupOf(String groupName) {
            return new ArrayList<InventoryListOutCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 棚卸帳票発行区分
     */
    public enum InventoryListType implements CDef {
        /** $01: 棚卸在庫差異表 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 在庫差異確認表 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 商品別棚卸実績表兼差異表 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: 商品別棚卸実績表(LOC表示あり) */
        $04("04", "$04", emptyStrings())
        ;
        private static final Map<String, InventoryListType> _codeClsMap = new HashMap<String, InventoryListType>();
        private static final Map<String, InventoryListType> _nameClsMap = new HashMap<String, InventoryListType>();
        static {
            for (InventoryListType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private InventoryListType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.InventoryListType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryListType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof InventoryListType) { return OptionalThing.of((InventoryListType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<InventoryListType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static InventoryListType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof InventoryListType) { return (InventoryListType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static InventoryListType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<InventoryListType> listAll() {
            return new ArrayList<InventoryListType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<InventoryListType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: InventoryListType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<InventoryListType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<InventoryListType> clsList = new ArrayList<InventoryListType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<InventoryListType> groupOf(String groupName) {
            return new ArrayList<InventoryListType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 個体管理区分
     */
    public enum ItManagType implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 個体管理スキャン対象外（ズボン） */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 個体管理スキャン対象（上着） */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, ItManagType> _codeClsMap = new HashMap<String, ItManagType>();
        private static final Map<String, ItManagType> _nameClsMap = new HashMap<String, ItManagType>();
        static {
            for (ItManagType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ItManagType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ItManagType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ItManagType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ItManagType) { return OptionalThing.of((ItManagType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ItManagType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ItManagType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ItManagType) { return (ItManagType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ItManagType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ItManagType> listAll() {
            return new ArrayList<ItManagType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ItManagType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ItManagType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ItManagType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ItManagType> clsList = new ArrayList<ItManagType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ItManagType> groupOf(String groupName) {
            return new ArrayList<ItManagType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 日本電産
     */
    public enum ItemDensan implements CDef {
        /** $1: 32 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ItemDensan> _codeClsMap = new HashMap<String, ItemDensan>();
        private static final Map<String, ItemDensan> _nameClsMap = new HashMap<String, ItemDensan>();
        static {
            for (ItemDensan value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ItemDensan(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ItemDensan; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ItemDensan> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ItemDensan) { return OptionalThing.of((ItemDensan)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ItemDensan> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ItemDensan codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ItemDensan) { return (ItemDensan)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ItemDensan nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ItemDensan> listAll() {
            return new ArrayList<ItemDensan>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ItemDensan> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ItemDensan." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ItemDensan> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ItemDensan> clsList = new ArrayList<ItemDensan>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ItemDensan> groupOf(String groupName) {
            return new ArrayList<ItemDensan>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 大物フラグ
     */
    public enum LargeItemFlg implements CDef {
        /** $0: 使用しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LargeItemFlg> _codeClsMap = new HashMap<String, LargeItemFlg>();
        private static final Map<String, LargeItemFlg> _nameClsMap = new HashMap<String, LargeItemFlg>();
        static {
            for (LargeItemFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LargeItemFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LargeItemFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LargeItemFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LargeItemFlg) { return OptionalThing.of((LargeItemFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LargeItemFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LargeItemFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LargeItemFlg) { return (LargeItemFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LargeItemFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LargeItemFlg> listAll() {
            return new ArrayList<LargeItemFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LargeItemFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LargeItemFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LargeItemFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LargeItemFlg> clsList = new ArrayList<LargeItemFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LargeItemFlg> groupOf(String groupName) {
            return new ArrayList<LargeItemFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 期限日割れ区分
     */
    public enum LimitDtSplitTypeCd implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 確認対象 */
        $1("1", "$1", emptyStrings())
        ,
        /** $3: 禁止対象 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, LimitDtSplitTypeCd> _codeClsMap = new HashMap<String, LimitDtSplitTypeCd>();
        private static final Map<String, LimitDtSplitTypeCd> _nameClsMap = new HashMap<String, LimitDtSplitTypeCd>();
        static {
            for (LimitDtSplitTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LimitDtSplitTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LimitDtSplitTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitDtSplitTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LimitDtSplitTypeCd) { return OptionalThing.of((LimitDtSplitTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitDtSplitTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LimitDtSplitTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LimitDtSplitTypeCd) { return (LimitDtSplitTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LimitDtSplitTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LimitDtSplitTypeCd> listAll() {
            return new ArrayList<LimitDtSplitTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LimitDtSplitTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LimitDtSplitTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LimitDtSplitTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LimitDtSplitTypeCd> clsList = new ArrayList<LimitDtSplitTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LimitDtSplitTypeCd> groupOf(String groupName) {
            return new ArrayList<LimitDtSplitTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 期限日不一致区分
     */
    public enum LimitDtUnmatchTypeCd implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 確認対象 */
        $1("1", "$1", emptyStrings())
        ,
        /** $3: 禁止対象 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, LimitDtUnmatchTypeCd> _codeClsMap = new HashMap<String, LimitDtUnmatchTypeCd>();
        private static final Map<String, LimitDtUnmatchTypeCd> _nameClsMap = new HashMap<String, LimitDtUnmatchTypeCd>();
        static {
            for (LimitDtUnmatchTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LimitDtUnmatchTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LimitDtUnmatchTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitDtUnmatchTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LimitDtUnmatchTypeCd) { return OptionalThing.of((LimitDtUnmatchTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LimitDtUnmatchTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LimitDtUnmatchTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LimitDtUnmatchTypeCd) { return (LimitDtUnmatchTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LimitDtUnmatchTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LimitDtUnmatchTypeCd> listAll() {
            return new ArrayList<LimitDtUnmatchTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LimitDtUnmatchTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LimitDtUnmatchTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LimitDtUnmatchTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LimitDtUnmatchTypeCd> clsList = new ArrayList<LimitDtUnmatchTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LimitDtUnmatchTypeCd> groupOf(String groupName) {
            return new ArrayList<LimitDtUnmatchTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 物流注意区分
     */
    public enum LogiAttentionTypeCd implements CDef {
        /** $0: 使用しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LogiAttentionTypeCd> _codeClsMap = new HashMap<String, LogiAttentionTypeCd>();
        private static final Map<String, LogiAttentionTypeCd> _nameClsMap = new HashMap<String, LogiAttentionTypeCd>();
        static {
            for (LogiAttentionTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LogiAttentionTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LogiAttentionTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogiAttentionTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LogiAttentionTypeCd) { return OptionalThing.of((LogiAttentionTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogiAttentionTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LogiAttentionTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LogiAttentionTypeCd) { return (LogiAttentionTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LogiAttentionTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LogiAttentionTypeCd> listAll() {
            return new ArrayList<LogiAttentionTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LogiAttentionTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LogiAttentionTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LogiAttentionTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LogiAttentionTypeCd> clsList = new ArrayList<LogiAttentionTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LogiAttentionTypeCd> groupOf(String groupName) {
            return new ArrayList<LogiAttentionTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 物流特殊区分
     */
    public enum LogiSpecialTypeCd implements CDef {
        /** $1: JAN1点読み対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LogiSpecialTypeCd> _codeClsMap = new HashMap<String, LogiSpecialTypeCd>();
        private static final Map<String, LogiSpecialTypeCd> _nameClsMap = new HashMap<String, LogiSpecialTypeCd>();
        static {
            for (LogiSpecialTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LogiSpecialTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LogiSpecialTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogiSpecialTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LogiSpecialTypeCd) { return OptionalThing.of((LogiSpecialTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogiSpecialTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LogiSpecialTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LogiSpecialTypeCd) { return (LogiSpecialTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LogiSpecialTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LogiSpecialTypeCd> listAll() {
            return new ArrayList<LogiSpecialTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LogiSpecialTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LogiSpecialTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LogiSpecialTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LogiSpecialTypeCd> clsList = new ArrayList<LogiSpecialTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LogiSpecialTypeCd> groupOf(String groupName) {
            return new ArrayList<LogiSpecialTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 物流重量フラグ
     */
    public enum LogiWeightFlg implements CDef {
        /** $0: 使用しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LogiWeightFlg> _codeClsMap = new HashMap<String, LogiWeightFlg>();
        private static final Map<String, LogiWeightFlg> _nameClsMap = new HashMap<String, LogiWeightFlg>();
        static {
            for (LogiWeightFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LogiWeightFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LogiWeightFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogiWeightFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LogiWeightFlg) { return OptionalThing.of((LogiWeightFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LogiWeightFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LogiWeightFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LogiWeightFlg) { return (LogiWeightFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LogiWeightFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LogiWeightFlg> listAll() {
            return new ArrayList<LogiWeightFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LogiWeightFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LogiWeightFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LogiWeightFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LogiWeightFlg> clsList = new ArrayList<LogiWeightFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LogiWeightFlg> groupOf(String groupName) {
            return new ArrayList<LogiWeightFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ロット割れ区分
     */
    public enum LotSplitTypeCd implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 確認対象 */
        $1("1", "$1", emptyStrings())
        ,
        /** $3: 禁止対象 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, LotSplitTypeCd> _codeClsMap = new HashMap<String, LotSplitTypeCd>();
        private static final Map<String, LotSplitTypeCd> _nameClsMap = new HashMap<String, LotSplitTypeCd>();
        static {
            for (LotSplitTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LotSplitTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LotSplitTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LotSplitTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LotSplitTypeCd) { return OptionalThing.of((LotSplitTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LotSplitTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LotSplitTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LotSplitTypeCd) { return (LotSplitTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LotSplitTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LotSplitTypeCd> listAll() {
            return new ArrayList<LotSplitTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LotSplitTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LotSplitTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LotSplitTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LotSplitTypeCd> clsList = new ArrayList<LotSplitTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LotSplitTypeCd> groupOf(String groupName) {
            return new ArrayList<LotSplitTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ロット不一致区分
     */
    public enum LotUnmatchTypeCd implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 確認対象 */
        $1("1", "$1", emptyStrings())
        ,
        /** $3: 禁止対象 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, LotUnmatchTypeCd> _codeClsMap = new HashMap<String, LotUnmatchTypeCd>();
        private static final Map<String, LotUnmatchTypeCd> _nameClsMap = new HashMap<String, LotUnmatchTypeCd>();
        static {
            for (LotUnmatchTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LotUnmatchTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LotUnmatchTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LotUnmatchTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LotUnmatchTypeCd) { return OptionalThing.of((LotUnmatchTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LotUnmatchTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LotUnmatchTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LotUnmatchTypeCd) { return (LotUnmatchTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LotUnmatchTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LotUnmatchTypeCd> listAll() {
            return new ArrayList<LotUnmatchTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LotUnmatchTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LotUnmatchTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LotUnmatchTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LotUnmatchTypeCd> clsList = new ArrayList<LotUnmatchTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LotUnmatchTypeCd> groupOf(String groupName) {
            return new ArrayList<LotUnmatchTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 最大格納数商品荷姿
     */
    public enum MaxStoreShape implements CDef {
        /** $1: バラ */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ケース */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, MaxStoreShape> _codeClsMap = new HashMap<String, MaxStoreShape>();
        private static final Map<String, MaxStoreShape> _nameClsMap = new HashMap<String, MaxStoreShape>();
        static {
            for (MaxStoreShape value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MaxStoreShape(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MaxStoreShape; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MaxStoreShape> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MaxStoreShape) { return OptionalThing.of((MaxStoreShape)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MaxStoreShape> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MaxStoreShape codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MaxStoreShape) { return (MaxStoreShape)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MaxStoreShape nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MaxStoreShape> listAll() {
            return new ArrayList<MaxStoreShape>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MaxStoreShape> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MaxStoreShape." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MaxStoreShape> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MaxStoreShape> clsList = new ArrayList<MaxStoreShape>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MaxStoreShape> groupOf(String groupName) {
            return new ArrayList<MaxStoreShape>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 医療用管理フラグ
     */
    public enum MedicalManagFlg implements CDef {
        /** $0: 使用しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, MedicalManagFlg> _codeClsMap = new HashMap<String, MedicalManagFlg>();
        private static final Map<String, MedicalManagFlg> _nameClsMap = new HashMap<String, MedicalManagFlg>();
        static {
            for (MedicalManagFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MedicalManagFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MedicalManagFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MedicalManagFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MedicalManagFlg) { return OptionalThing.of((MedicalManagFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MedicalManagFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MedicalManagFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MedicalManagFlg) { return (MedicalManagFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MedicalManagFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MedicalManagFlg> listAll() {
            return new ArrayList<MedicalManagFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MedicalManagFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MedicalManagFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MedicalManagFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MedicalManagFlg> clsList = new ArrayList<MedicalManagFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MedicalManagFlg> groupOf(String groupName) {
            return new ArrayList<MedicalManagFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 移動方法
     */
    public enum MoveDirection implements CDef {
        /** $01: 外部倉庫から移動 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 外部倉庫へ移動 */
        $02("02", "$02", emptyStrings())
        ;
        private static final Map<String, MoveDirection> _codeClsMap = new HashMap<String, MoveDirection>();
        private static final Map<String, MoveDirection> _nameClsMap = new HashMap<String, MoveDirection>();
        static {
            for (MoveDirection value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private MoveDirection(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.MoveDirection; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MoveDirection> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof MoveDirection) { return OptionalThing.of((MoveDirection)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<MoveDirection> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static MoveDirection codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof MoveDirection) { return (MoveDirection)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static MoveDirection nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<MoveDirection> listAll() {
            return new ArrayList<MoveDirection>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<MoveDirection> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: MoveDirection." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<MoveDirection> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<MoveDirection> clsList = new ArrayList<MoveDirection>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<MoveDirection> groupOf(String groupName) {
            return new ArrayList<MoveDirection>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 祝日振替業者
     */
    public enum NationalHolidayCarrier implements CDef {
        /** $JP: 日本郵便 */
        $JP("JP", "$JP", emptyStrings())
        ,
        /** $YMT: ヤマト運輸 */
        $YMT("YMT", "$YMT", emptyStrings())
        ,
        /** $SGW: 佐川急便 */
        $SGW("SGW", "$SGW", emptyStrings())
        ;
        private static final Map<String, NationalHolidayCarrier> _codeClsMap = new HashMap<String, NationalHolidayCarrier>();
        private static final Map<String, NationalHolidayCarrier> _nameClsMap = new HashMap<String, NationalHolidayCarrier>();
        static {
            for (NationalHolidayCarrier value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NationalHolidayCarrier(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NationalHolidayCarrier; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NationalHolidayCarrier> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NationalHolidayCarrier) { return OptionalThing.of((NationalHolidayCarrier)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NationalHolidayCarrier> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NationalHolidayCarrier codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NationalHolidayCarrier) { return (NationalHolidayCarrier)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NationalHolidayCarrier nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NationalHolidayCarrier> listAll() {
            return new ArrayList<NationalHolidayCarrier>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NationalHolidayCarrier> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NationalHolidayCarrier." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NationalHolidayCarrier> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NationalHolidayCarrier> clsList = new ArrayList<NationalHolidayCarrier>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NationalHolidayCarrier> groupOf(String groupName) {
            return new ArrayList<NationalHolidayCarrier>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 祝日
     */
    public enum NationalHolidayFlg implements CDef {
        /** $0: 祝日でない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 祝日 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, NationalHolidayFlg> _codeClsMap = new HashMap<String, NationalHolidayFlg>();
        private static final Map<String, NationalHolidayFlg> _nameClsMap = new HashMap<String, NationalHolidayFlg>();
        static {
            for (NationalHolidayFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NationalHolidayFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NationalHolidayFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NationalHolidayFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NationalHolidayFlg) { return OptionalThing.of((NationalHolidayFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NationalHolidayFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NationalHolidayFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NationalHolidayFlg) { return (NationalHolidayFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NationalHolidayFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NationalHolidayFlg> listAll() {
            return new ArrayList<NationalHolidayFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NationalHolidayFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NationalHolidayFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NationalHolidayFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NationalHolidayFlg> clsList = new ArrayList<NationalHolidayFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NationalHolidayFlg> groupOf(String groupName) {
            return new ArrayList<NationalHolidayFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 荷揃処理ID(共通)
     */
    public enum NizoroeProcessId implements CDef {
        /** $A1: 出荷区分決定 */
        $A1("A1", "$A1", emptyStrings())
        ,
        /** $B1: 荷揃番号（出荷日等） */
        $B1("B1", "$B1", emptyStrings())
        ,
        /** $B2: 荷揃番号（オーダID） */
        $B2("B2", "$B2", emptyStrings())
        ,
        /** $C1: 帳簿引当 */
        $C1("C1", "$C1", emptyStrings())
        ,
        /** $D1: 運送業者出荷指示内判定 */
        $D1("D1", "$D1", emptyStrings())
        ,
        /** $D2: 運送業者マスタ判定 */
        $D2("D2", "$D2", emptyStrings())
        ,
        /** $D3: 運送業者（休日判定） */
        $D3("D3", "$D3", emptyStrings())
        ,
        /** $D4: 運送業者（大物重量物判定） */
        $D4("D4", "$D4", emptyStrings())
        ,
        /** $D5: 運送業者（保険品判定） */
        $D5("D5", "$D5", emptyStrings())
        ,
        /** $D6: 運送業者（沖縄空港便不可判定） */
        $D6("D6", "$D6", emptyStrings())
        ,
        /** $D7: 運送業者（配達不可地域判定） */
        $D7("D7", "$D7", emptyStrings())
        ,
        /** $E1: 荷揃番号再採番 */
        $E1("E1", "$E1", emptyStrings())
        ;
        private static final Map<String, NizoroeProcessId> _codeClsMap = new HashMap<String, NizoroeProcessId>();
        private static final Map<String, NizoroeProcessId> _nameClsMap = new HashMap<String, NizoroeProcessId>();
        static {
            for (NizoroeProcessId value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NizoroeProcessId(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NizoroeProcessId; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NizoroeProcessId> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NizoroeProcessId) { return OptionalThing.of((NizoroeProcessId)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NizoroeProcessId> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NizoroeProcessId codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NizoroeProcessId) { return (NizoroeProcessId)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NizoroeProcessId nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NizoroeProcessId> listAll() {
            return new ArrayList<NizoroeProcessId>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NizoroeProcessId> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NizoroeProcessId." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NizoroeProcessId> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NizoroeProcessId> clsList = new ArrayList<NizoroeProcessId>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NizoroeProcessId> groupOf(String groupName) {
            return new ArrayList<NizoroeProcessId>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 荷揃処理ID(WMS)
     */
    public enum NizoroeProcessIdWms implements CDef {
        /** $A1: ロケーション在庫引当 */
        $A1("A1", "$A1", emptyStrings())
        ,
        /** $B1: 運送業者再決定 */
        $B1("B1", "$B1", emptyStrings())
        ,
        /** $C1: ピッキングパターン決定 */
        $C1("C1", "$C1", emptyStrings())
        ,
        /** $C2: ピッキングパターン決定（得意先別） */
        $C2("C2", "$C2", emptyStrings())
        ,
        /** $C3: ピッキングパターン決定（強制バラ） */
        $C3("C3", "$C3", emptyStrings())
        ,
        /** $D1: 荷揃番号採番（ピックフロア） */
        $D1("D1", "$D1", emptyStrings())
        ,
        /** $D2: 荷揃番号採番（FW10足） */
        $D2("D2", "$D2", emptyStrings())
        ,
        /** $E1: 代表荷揃番号採番（得意先別） */
        $E1("E1", "$E1", emptyStrings())
        ,
        /** $E2: 代表荷揃番号採番（出荷区分） */
        $E2("E2", "$E2", emptyStrings())
        ;
        private static final Map<String, NizoroeProcessIdWms> _codeClsMap = new HashMap<String, NizoroeProcessIdWms>();
        private static final Map<String, NizoroeProcessIdWms> _nameClsMap = new HashMap<String, NizoroeProcessIdWms>();
        static {
            for (NizoroeProcessIdWms value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NizoroeProcessIdWms(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NizoroeProcessIdWms; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NizoroeProcessIdWms> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NizoroeProcessIdWms) { return OptionalThing.of((NizoroeProcessIdWms)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NizoroeProcessIdWms> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NizoroeProcessIdWms codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NizoroeProcessIdWms) { return (NizoroeProcessIdWms)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NizoroeProcessIdWms nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NizoroeProcessIdWms> listAll() {
            return new ArrayList<NizoroeProcessIdWms>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NizoroeProcessIdWms> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NizoroeProcessIdWms." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NizoroeProcessIdWms> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NizoroeProcessIdWms> clsList = new ArrayList<NizoroeProcessIdWms>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NizoroeProcessIdWms> groupOf(String groupName) {
            return new ArrayList<NizoroeProcessIdWms>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 荷揃処理時間
     */
    public enum NizoroeTime implements CDef {
        /** $1: 午前7時 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 午前10時 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 午前11時 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 午前12時 */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 午後3時 */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: 午後4時 */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, NizoroeTime> _codeClsMap = new HashMap<String, NizoroeTime>();
        private static final Map<String, NizoroeTime> _nameClsMap = new HashMap<String, NizoroeTime>();
        static {
            for (NizoroeTime value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NizoroeTime(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NizoroeTime; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NizoroeTime> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NizoroeTime) { return OptionalThing.of((NizoroeTime)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NizoroeTime> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NizoroeTime codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NizoroeTime) { return (NizoroeTime)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NizoroeTime nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NizoroeTime> listAll() {
            return new ArrayList<NizoroeTime>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NizoroeTime> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NizoroeTime." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NizoroeTime> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NizoroeTime> clsList = new ArrayList<NizoroeTime>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NizoroeTime> groupOf(String groupName) {
            return new ArrayList<NizoroeTime>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 荷揃区分(共通)
     */
    public enum NizoroeType implements CDef {
        /** $1: 出荷区分決定 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 荷揃番号採番 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 帳簿引手 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 運送業者決定 */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 荷揃番号再採番 */
        $5("5", "$5", emptyStrings())
        ;
        private static final Map<String, NizoroeType> _codeClsMap = new HashMap<String, NizoroeType>();
        private static final Map<String, NizoroeType> _nameClsMap = new HashMap<String, NizoroeType>();
        static {
            for (NizoroeType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NizoroeType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NizoroeType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NizoroeType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NizoroeType) { return OptionalThing.of((NizoroeType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NizoroeType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NizoroeType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NizoroeType) { return (NizoroeType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NizoroeType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NizoroeType> listAll() {
            return new ArrayList<NizoroeType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NizoroeType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NizoroeType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NizoroeType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NizoroeType> clsList = new ArrayList<NizoroeType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NizoroeType> groupOf(String groupName) {
            return new ArrayList<NizoroeType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 荷揃区分(WMS)
     */
    public enum NizoroeTypeWms implements CDef {
        /** $1: ロケーション在庫引当 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 運送業者再決定 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: ピッキングパターン決定 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 荷揃番号採番_WMS */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 代表荷揃番号採番 */
        $5("5", "$5", emptyStrings())
        ;
        private static final Map<String, NizoroeTypeWms> _codeClsMap = new HashMap<String, NizoroeTypeWms>();
        private static final Map<String, NizoroeTypeWms> _nameClsMap = new HashMap<String, NizoroeTypeWms>();
        static {
            for (NizoroeTypeWms value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NizoroeTypeWms(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NizoroeTypeWms; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NizoroeTypeWms> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NizoroeTypeWms) { return OptionalThing.of((NizoroeTypeWms)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NizoroeTypeWms> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NizoroeTypeWms codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NizoroeTypeWms) { return (NizoroeTypeWms)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NizoroeTypeWms nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NizoroeTypeWms> listAll() {
            return new ArrayList<NizoroeTypeWms>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NizoroeTypeWms> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NizoroeTypeWms." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NizoroeTypeWms> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NizoroeTypeWms> clsList = new ArrayList<NizoroeTypeWms>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NizoroeTypeWms> groupOf(String groupName) {
            return new ArrayList<NizoroeTypeWms>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 沖縄航空便不可フラグ
     */
    public enum NoOkinawaFlightFlg implements CDef {
        /** $0: 使用しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, NoOkinawaFlightFlg> _codeClsMap = new HashMap<String, NoOkinawaFlightFlg>();
        private static final Map<String, NoOkinawaFlightFlg> _nameClsMap = new HashMap<String, NoOkinawaFlightFlg>();
        static {
            for (NoOkinawaFlightFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private NoOkinawaFlightFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.NoOkinawaFlightFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoOkinawaFlightFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof NoOkinawaFlightFlg) { return OptionalThing.of((NoOkinawaFlightFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<NoOkinawaFlightFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static NoOkinawaFlightFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof NoOkinawaFlightFlg) { return (NoOkinawaFlightFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static NoOkinawaFlightFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<NoOkinawaFlightFlg> listAll() {
            return new ArrayList<NoOkinawaFlightFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<NoOkinawaFlightFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: NoOkinawaFlightFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<NoOkinawaFlightFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<NoOkinawaFlightFlg> clsList = new ArrayList<NoOkinawaFlightFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<NoOkinawaFlightFlg> groupOf(String groupName) {
            return new ArrayList<NoOkinawaFlightFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * OCR日付形式
     */
    public enum OcrDateFormat implements CDef {
        /** $1: YYYY/MM/DD */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: YY.MM.DD */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, OcrDateFormat> _codeClsMap = new HashMap<String, OcrDateFormat>();
        private static final Map<String, OcrDateFormat> _nameClsMap = new HashMap<String, OcrDateFormat>();
        static {
            for (OcrDateFormat value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private OcrDateFormat(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.OcrDateFormat; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OcrDateFormat> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof OcrDateFormat) { return OptionalThing.of((OcrDateFormat)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OcrDateFormat> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static OcrDateFormat codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof OcrDateFormat) { return (OcrDateFormat)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static OcrDateFormat nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<OcrDateFormat> listAll() {
            return new ArrayList<OcrDateFormat>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<OcrDateFormat> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: OcrDateFormat." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<OcrDateFormat> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<OcrDateFormat> clsList = new ArrayList<OcrDateFormat>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<OcrDateFormat> groupOf(String groupName) {
            return new ArrayList<OcrDateFormat>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出力帳票種別
     */
    public enum OutputListType implements CDef {
        /** $BLDL5050: 【通常分】出荷日別ﾋﾟｯｷﾝｸﾞ状況一覧表 */
        $BLDL5050("BLDL5050", "$BLDL5050", emptyStrings())
        ;
        private static final Map<String, OutputListType> _codeClsMap = new HashMap<String, OutputListType>();
        private static final Map<String, OutputListType> _nameClsMap = new HashMap<String, OutputListType>();
        static {
            for (OutputListType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private OutputListType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.OutputListType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OutputListType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof OutputListType) { return OptionalThing.of((OutputListType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OutputListType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static OutputListType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof OutputListType) { return (OutputListType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static OutputListType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<OutputListType> listAll() {
            return new ArrayList<OutputListType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<OutputListType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: OutputListType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<OutputListType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<OutputListType> clsList = new ArrayList<OutputListType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<OutputListType> groupOf(String groupName) {
            return new ArrayList<OutputListType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出力月
     */
    public enum OutputMonth implements CDef {
        /** $1: 1 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 2 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 3 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 4 */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 5 */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: 6 */
        $6("6", "$6", emptyStrings())
        ,
        /** $7: 7 */
        $7("7", "$7", emptyStrings())
        ,
        /** $8: 8 */
        $8("8", "$8", emptyStrings())
        ,
        /** $9: 9 */
        $9("9", "$9", emptyStrings())
        ,
        /** $10: 10 */
        $10("10", "$10", emptyStrings())
        ,
        /** $11: 11 */
        $11("11", "$11", emptyStrings())
        ,
        /** $12: 12 */
        $12("12", "$12", emptyStrings())
        ;
        private static final Map<String, OutputMonth> _codeClsMap = new HashMap<String, OutputMonth>();
        private static final Map<String, OutputMonth> _nameClsMap = new HashMap<String, OutputMonth>();
        static {
            for (OutputMonth value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private OutputMonth(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.OutputMonth; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OutputMonth> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof OutputMonth) { return OptionalThing.of((OutputMonth)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OutputMonth> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static OutputMonth codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof OutputMonth) { return (OutputMonth)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static OutputMonth nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<OutputMonth> listAll() {
            return new ArrayList<OutputMonth>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<OutputMonth> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: OutputMonth." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<OutputMonth> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<OutputMonth> clsList = new ArrayList<OutputMonth>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<OutputMonth> groupOf(String groupName) {
            return new ArrayList<OutputMonth>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出力状況
     */
    public enum OutputStatus implements CDef {
        /** $0: 未出力 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出力済 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 全て */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, OutputStatus> _codeClsMap = new HashMap<String, OutputStatus>();
        private static final Map<String, OutputStatus> _nameClsMap = new HashMap<String, OutputStatus>();
        static {
            for (OutputStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private OutputStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.OutputStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OutputStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof OutputStatus) { return OptionalThing.of((OutputStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OutputStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static OutputStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof OutputStatus) { return (OutputStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static OutputStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<OutputStatus> listAll() {
            return new ArrayList<OutputStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<OutputStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: OutputStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<OutputStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<OutputStatus> clsList = new ArrayList<OutputStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<OutputStatus> groupOf(String groupName) {
            return new ArrayList<OutputStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 決済区分
     */
    public enum PaymentTypeCd implements CDef {
        /** $1: 銀行振込 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 代金引換 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: ペイジー */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: モバイルSuica */
        $4("4", "$4", emptyStrings())
        ,
        /** $6: YPOINT利用 */
        $6("6", "$6", emptyStrings())
        ,
        /** $7: クレジットカード */
        $7("7", "$7", emptyStrings())
        ,
        /** $8: 前払い(コンビニ銀行郵便局) */
        $8("8", "$8", emptyStrings())
        ,
        /** $A: 後払い(コンビニ銀行郵便局与信3万?) */
        $A("A", "$A", emptyStrings())
        ,
        /** $B: 後払い(コンビニ銀行郵便局与信10万?) */
        $B("B", "$B", emptyStrings())
        ,
        /** $D: 電子マネー */
        $D("D", "$D", emptyStrings())
        ,
        /** $E: まとめてau支払い */
        $E("E", "$E", emptyStrings())
        ,
        /** $F: ドコモケータイ払い */
        $F("F", "$F", emptyStrings())
        ,
        /** $G: 銀行ネット決済 )、出荷の際の納品書に印字する決済方法 */
        $G("G", "$G", emptyStrings())
        ,
        /** $H: 簡易請求書決済 */
        $H("H", "$H", emptyStrings())
        ,
        /** $I: ＳＢケータイ払い */
        $I("I", "$I", emptyStrings())
        ,
        /** $J: 全額ａｕポイント支払 */
        $J("J", "$J", emptyStrings())
        ,
        /** $K: キャリア決済 */
        $K("K", "$K", emptyStrings())
        ,
        /** $Q: ＰａｙＰａｙ */
        $Q("Q", "$Q", emptyStrings())
        ;
        private static final Map<String, PaymentTypeCd> _codeClsMap = new HashMap<String, PaymentTypeCd>();
        private static final Map<String, PaymentTypeCd> _nameClsMap = new HashMap<String, PaymentTypeCd>();
        static {
            for (PaymentTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PaymentTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PaymentTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PaymentTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PaymentTypeCd) { return OptionalThing.of((PaymentTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PaymentTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PaymentTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PaymentTypeCd) { return (PaymentTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PaymentTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PaymentTypeCd> listAll() {
            return new ArrayList<PaymentTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PaymentTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PaymentTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PaymentTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PaymentTypeCd> clsList = new ArrayList<PaymentTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PaymentTypeCd> groupOf(String groupName) {
            return new ArrayList<PaymentTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ピッキングパターンCD
     */
    public enum PickingPatternCd implements CDef {
        /** $1: オーダーピッキング */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: トータルピッキング */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: ケースピッキング */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, PickingPatternCd> _codeClsMap = new HashMap<String, PickingPatternCd>();
        private static final Map<String, PickingPatternCd> _nameClsMap = new HashMap<String, PickingPatternCd>();
        static {
            for (PickingPatternCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PickingPatternCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PickingPatternCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingPatternCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PickingPatternCd) { return OptionalThing.of((PickingPatternCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PickingPatternCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PickingPatternCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PickingPatternCd) { return (PickingPatternCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PickingPatternCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PickingPatternCd> listAll() {
            return new ArrayList<PickingPatternCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PickingPatternCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PickingPatternCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PickingPatternCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PickingPatternCd> clsList = new ArrayList<PickingPatternCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PickingPatternCd> groupOf(String groupName) {
            return new ArrayList<PickingPatternCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 都道府県
     */
    public enum Prefecture implements CDef {
        /** $01: 北海道 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 青森県 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 岩手県 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: 宮城県 */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: 秋田県 */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: 山形県 */
        $06("06", "$06", emptyStrings())
        ,
        /** $07: 福島県 */
        $07("07", "$07", emptyStrings())
        ,
        /** $08: 茨城県 */
        $08("08", "$08", emptyStrings())
        ,
        /** $09: 栃木県 */
        $09("09", "$09", emptyStrings())
        ,
        /** $10: 群馬県 */
        $10("10", "$10", emptyStrings())
        ,
        /** $11: 埼玉県 */
        $11("11", "$11", emptyStrings())
        ,
        /** $12: 千葉県 */
        $12("12", "$12", emptyStrings())
        ,
        /** $13: 東京都 */
        $13("13", "$13", emptyStrings())
        ,
        /** $14: 神奈川県 */
        $14("14", "$14", emptyStrings())
        ,
        /** $15: 新潟県 */
        $15("15", "$15", emptyStrings())
        ,
        /** $16: 富山県 */
        $16("16", "$16", emptyStrings())
        ,
        /** $17: 石川県 */
        $17("17", "$17", emptyStrings())
        ,
        /** $18: 福井県 */
        $18("18", "$18", emptyStrings())
        ,
        /** $19: 山梨県 */
        $19("19", "$19", emptyStrings())
        ,
        /** $20: 長野県 */
        $20("20", "$20", emptyStrings())
        ,
        /** $21: 岐阜県 */
        $21("21", "$21", emptyStrings())
        ,
        /** $22: 静岡県 */
        $22("22", "$22", emptyStrings())
        ,
        /** $23: 愛知県 */
        $23("23", "$23", emptyStrings())
        ,
        /** $24: 三重県 */
        $24("24", "$24", emptyStrings())
        ,
        /** $25: 滋賀県 */
        $25("25", "$25", emptyStrings())
        ,
        /** $26: 京都府 */
        $26("26", "$26", emptyStrings())
        ,
        /** $27: 大阪府 */
        $27("27", "$27", emptyStrings())
        ,
        /** $28: 兵庫県 */
        $28("28", "$28", emptyStrings())
        ,
        /** $29: 奈良県 */
        $29("29", "$29", emptyStrings())
        ,
        /** $30: 和歌山県 */
        $30("30", "$30", emptyStrings())
        ,
        /** $31: 鳥取県 */
        $31("31", "$31", emptyStrings())
        ,
        /** $32: 島根県 */
        $32("32", "$32", emptyStrings())
        ,
        /** $33: 岡山県 */
        $33("33", "$33", emptyStrings())
        ,
        /** $34: 広島県 */
        $34("34", "$34", emptyStrings())
        ,
        /** $35: 山口県 */
        $35("35", "$35", emptyStrings())
        ,
        /** $36: 徳島県 */
        $36("36", "$36", emptyStrings())
        ,
        /** $37: 香川県 */
        $37("37", "$37", emptyStrings())
        ,
        /** $38: 愛媛県 */
        $38("38", "$38", emptyStrings())
        ,
        /** $39: 高知県 */
        $39("39", "$39", emptyStrings())
        ,
        /** $40: 福岡県 */
        $40("40", "$40", emptyStrings())
        ,
        /** $41: 佐賀県 */
        $41("41", "$41", emptyStrings())
        ,
        /** $42: 長崎県 */
        $42("42", "$42", emptyStrings())
        ,
        /** $43: 熊本県 */
        $43("43", "$43", emptyStrings())
        ,
        /** $44: 大分県 */
        $44("44", "$44", emptyStrings())
        ,
        /** $45: 宮崎県 */
        $45("45", "$45", emptyStrings())
        ,
        /** $46: 鹿児島県 */
        $46("46", "$46", emptyStrings())
        ,
        /** $47: 沖縄県 */
        $47("47", "$47", emptyStrings())
        ,
        /** $99: その他 */
        $99("99", "$99", emptyStrings())
        ;
        private static final Map<String, Prefecture> _codeClsMap = new HashMap<String, Prefecture>();
        private static final Map<String, Prefecture> _nameClsMap = new HashMap<String, Prefecture>();
        static {
            for (Prefecture value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private Prefecture(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.Prefecture; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Prefecture> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof Prefecture) { return OptionalThing.of((Prefecture)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<Prefecture> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static Prefecture codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof Prefecture) { return (Prefecture)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static Prefecture nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<Prefecture> listAll() {
            return new ArrayList<Prefecture>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<Prefecture> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: Prefecture." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<Prefecture> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<Prefecture> clsList = new ArrayList<Prefecture>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<Prefecture> groupOf(String groupName) {
            return new ArrayList<Prefecture>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 差異金額非表示
     */
    public enum PriceDiffHidden implements CDef {
        /** $01: 差異金額を非表示 */
        $01("01", "$01", emptyStrings())
        ;
        private static final Map<String, PriceDiffHidden> _codeClsMap = new HashMap<String, PriceDiffHidden>();
        private static final Map<String, PriceDiffHidden> _nameClsMap = new HashMap<String, PriceDiffHidden>();
        static {
            for (PriceDiffHidden value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PriceDiffHidden(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PriceDiffHidden; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PriceDiffHidden> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PriceDiffHidden) { return OptionalThing.of((PriceDiffHidden)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PriceDiffHidden> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PriceDiffHidden codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PriceDiffHidden) { return (PriceDiffHidden)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PriceDiffHidden nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PriceDiffHidden> listAll() {
            return new ArrayList<PriceDiffHidden>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PriceDiffHidden> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PriceDiffHidden." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PriceDiffHidden> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PriceDiffHidden> clsList = new ArrayList<PriceDiffHidden>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PriceDiffHidden> groupOf(String groupName) {
            return new ArrayList<PriceDiffHidden>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 製造日管理フラグ
     */
    public enum ProdDtManagFlg implements CDef {
        /** $0: 使用しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ProdDtManagFlg> _codeClsMap = new HashMap<String, ProdDtManagFlg>();
        private static final Map<String, ProdDtManagFlg> _nameClsMap = new HashMap<String, ProdDtManagFlg>();
        static {
            for (ProdDtManagFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProdDtManagFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProdDtManagFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProdDtManagFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProdDtManagFlg) { return OptionalThing.of((ProdDtManagFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProdDtManagFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProdDtManagFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProdDtManagFlg) { return (ProdDtManagFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProdDtManagFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProdDtManagFlg> listAll() {
            return new ArrayList<ProdDtManagFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProdDtManagFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProdDtManagFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProdDtManagFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProdDtManagFlg> clsList = new ArrayList<ProdDtManagFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProdDtManagFlg> groupOf(String groupName) {
            return new ArrayList<ProdDtManagFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 製造日割れ区分
     */
    public enum ProdDtSplitTypeCd implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 確認対象 */
        $1("1", "$1", emptyStrings())
        ,
        /** $3: 禁止対象 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, ProdDtSplitTypeCd> _codeClsMap = new HashMap<String, ProdDtSplitTypeCd>();
        private static final Map<String, ProdDtSplitTypeCd> _nameClsMap = new HashMap<String, ProdDtSplitTypeCd>();
        static {
            for (ProdDtSplitTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProdDtSplitTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProdDtSplitTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProdDtSplitTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProdDtSplitTypeCd) { return OptionalThing.of((ProdDtSplitTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProdDtSplitTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProdDtSplitTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProdDtSplitTypeCd) { return (ProdDtSplitTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProdDtSplitTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProdDtSplitTypeCd> listAll() {
            return new ArrayList<ProdDtSplitTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProdDtSplitTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProdDtSplitTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProdDtSplitTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProdDtSplitTypeCd> clsList = new ArrayList<ProdDtSplitTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProdDtSplitTypeCd> groupOf(String groupName) {
            return new ArrayList<ProdDtSplitTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 製造日不一致区分
     */
    public enum ProdDtUnmatchTypeCd implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 確認対象 */
        $1("1", "$1", emptyStrings())
        ,
        /** $3: 禁止対象 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, ProdDtUnmatchTypeCd> _codeClsMap = new HashMap<String, ProdDtUnmatchTypeCd>();
        private static final Map<String, ProdDtUnmatchTypeCd> _nameClsMap = new HashMap<String, ProdDtUnmatchTypeCd>();
        static {
            for (ProdDtUnmatchTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProdDtUnmatchTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProdDtUnmatchTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProdDtUnmatchTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProdDtUnmatchTypeCd) { return OptionalThing.of((ProdDtUnmatchTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProdDtUnmatchTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProdDtUnmatchTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProdDtUnmatchTypeCd) { return (ProdDtUnmatchTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProdDtUnmatchTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProdDtUnmatchTypeCd> listAll() {
            return new ArrayList<ProdDtUnmatchTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProdDtUnmatchTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProdDtUnmatchTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProdDtUnmatchTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProdDtUnmatchTypeCd> clsList = new ArrayList<ProdDtUnmatchTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProdDtUnmatchTypeCd> groupOf(String groupName) {
            return new ArrayList<ProdDtUnmatchTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 品種変換区分
     */
    public enum ProductCategoryConvertCls implements CDef {
        /** $10: 1 */
        $10("10", "$10", emptyStrings())
        ,
        /** $20: 1 */
        $20("20", "$20", emptyStrings())
        ,
        /** $30: 2 */
        $30("30", "$30", emptyStrings())
        ,
        /** $40: 3 */
        $40("40", "$40", emptyStrings())
        ,
        /** $45: 4 */
        $45("45", "$45", emptyStrings())
        ,
        /** $50: 5 */
        $50("50", "$50", emptyStrings())
        ,
        /** $60: 6 */
        $60("60", "$60", emptyStrings())
        ,
        /** $70: 7 */
        $70("70", "$70", emptyStrings())
        ;
        private static final Map<String, ProductCategoryConvertCls> _codeClsMap = new HashMap<String, ProductCategoryConvertCls>();
        private static final Map<String, ProductCategoryConvertCls> _nameClsMap = new HashMap<String, ProductCategoryConvertCls>();
        static {
            for (ProductCategoryConvertCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProductCategoryConvertCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProductCategoryConvertCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductCategoryConvertCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProductCategoryConvertCls) { return OptionalThing.of((ProductCategoryConvertCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductCategoryConvertCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProductCategoryConvertCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProductCategoryConvertCls) { return (ProductCategoryConvertCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProductCategoryConvertCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProductCategoryConvertCls> listAll() {
            return new ArrayList<ProductCategoryConvertCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProductCategoryConvertCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProductCategoryConvertCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProductCategoryConvertCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProductCategoryConvertCls> clsList = new ArrayList<ProductCategoryConvertCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProductCategoryConvertCls> groupOf(String groupName) {
            return new ArrayList<ProductCategoryConvertCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 品種区分変換
     */
    public enum ProductCategoryPlant implements CDef {
        /** $01: P135 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: P161 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: P801 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: P900 */
        $04("04", "$04", emptyStrings())
        ;
        private static final Map<String, ProductCategoryPlant> _codeClsMap = new HashMap<String, ProductCategoryPlant>();
        private static final Map<String, ProductCategoryPlant> _nameClsMap = new HashMap<String, ProductCategoryPlant>();
        static {
            for (ProductCategoryPlant value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProductCategoryPlant(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProductCategoryPlant; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductCategoryPlant> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProductCategoryPlant) { return OptionalThing.of((ProductCategoryPlant)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductCategoryPlant> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProductCategoryPlant codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProductCategoryPlant) { return (ProductCategoryPlant)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProductCategoryPlant nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProductCategoryPlant> listAll() {
            return new ArrayList<ProductCategoryPlant>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProductCategoryPlant> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProductCategoryPlant." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProductCategoryPlant> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProductCategoryPlant> clsList = new ArrayList<ProductCategoryPlant>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProductCategoryPlant> groupOf(String groupName) {
            return new ArrayList<ProductCategoryPlant>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 品種区分
     */
    public enum ProductCategoryType implements CDef {
        /** $01: FW */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: SH */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: UN */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: HM */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: DS */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: CS */
        $06("06", "$06", emptyStrings())
        ,
        /** $07: MD */
        $07("07", "$07", emptyStrings())
        ;
        private static final Map<String, ProductCategoryType> _codeClsMap = new HashMap<String, ProductCategoryType>();
        private static final Map<String, ProductCategoryType> _nameClsMap = new HashMap<String, ProductCategoryType>();
        static {
            for (ProductCategoryType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProductCategoryType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProductCategoryType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductCategoryType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProductCategoryType) { return OptionalThing.of((ProductCategoryType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductCategoryType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProductCategoryType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProductCategoryType) { return (ProductCategoryType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProductCategoryType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProductCategoryType> listAll() {
            return new ArrayList<ProductCategoryType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProductCategoryType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProductCategoryType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProductCategoryType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProductCategoryType> clsList = new ArrayList<ProductCategoryType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProductCategoryType> groupOf(String groupName) {
            return new ArrayList<ProductCategoryType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 商品別入庫ステータス
     */
    public enum ProductStoreStatus implements CDef {
        /** $01: 入荷済 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 格納済 */
        $02("02", "$02", emptyStrings())
        ;
        private static final Map<String, ProductStoreStatus> _codeClsMap = new HashMap<String, ProductStoreStatus>();
        private static final Map<String, ProductStoreStatus> _nameClsMap = new HashMap<String, ProductStoreStatus>();
        static {
            for (ProductStoreStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProductStoreStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProductStoreStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductStoreStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProductStoreStatus) { return OptionalThing.of((ProductStoreStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductStoreStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProductStoreStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProductStoreStatus) { return (ProductStoreStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProductStoreStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProductStoreStatus> listAll() {
            return new ArrayList<ProductStoreStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProductStoreStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProductStoreStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProductStoreStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProductStoreStatus> clsList = new ArrayList<ProductStoreStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProductStoreStatus> groupOf(String groupName) {
            return new ArrayList<ProductStoreStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 商品単位
     */
    public enum ProductUnitCls implements CDef {
        /** $0: 全て */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: ケース */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: バラ */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, ProductUnitCls> _codeClsMap = new HashMap<String, ProductUnitCls>();
        private static final Map<String, ProductUnitCls> _nameClsMap = new HashMap<String, ProductUnitCls>();
        static {
            for (ProductUnitCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProductUnitCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProductUnitCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductUnitCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProductUnitCls) { return OptionalThing.of((ProductUnitCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProductUnitCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProductUnitCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProductUnitCls) { return (ProductUnitCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProductUnitCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProductUnitCls> listAll() {
            return new ArrayList<ProductUnitCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProductUnitCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProductUnitCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProductUnitCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProductUnitCls> clsList = new ArrayList<ProductUnitCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProductUnitCls> groupOf(String groupName) {
            return new ArrayList<ProductUnitCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入荷発生事由
     */
    public enum ReceiveReason implements CDef {
        /** $1: 発注入荷 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 返品入荷 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 振替入荷 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 加工入荷 */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 転送入荷 */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: 預り品入荷 */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, ReceiveReason> _codeClsMap = new HashMap<String, ReceiveReason>();
        private static final Map<String, ReceiveReason> _nameClsMap = new HashMap<String, ReceiveReason>();
        static {
            for (ReceiveReason value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReceiveReason(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReceiveReason; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveReason> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReceiveReason) { return OptionalThing.of((ReceiveReason)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveReason> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReceiveReason codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReceiveReason) { return (ReceiveReason)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReceiveReason nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReceiveReason> listAll() {
            return new ArrayList<ReceiveReason>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReceiveReason> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReceiveReason." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReceiveReason> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReceiveReason> clsList = new ArrayList<ReceiveReason>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReceiveReason> groupOf(String groupName) {
            return new ArrayList<ReceiveReason>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入荷発生事由変換
     */
    public enum ReceiveReasonConvert implements CDef {
        /** $1: 01 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 02 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 03 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 04 */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 05 */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: 06 */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, ReceiveReasonConvert> _codeClsMap = new HashMap<String, ReceiveReasonConvert>();
        private static final Map<String, ReceiveReasonConvert> _nameClsMap = new HashMap<String, ReceiveReasonConvert>();
        static {
            for (ReceiveReasonConvert value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReceiveReasonConvert(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReceiveReasonConvert; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveReasonConvert> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReceiveReasonConvert) { return OptionalThing.of((ReceiveReasonConvert)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveReasonConvert> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReceiveReasonConvert codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReceiveReasonConvert) { return (ReceiveReasonConvert)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReceiveReasonConvert nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReceiveReasonConvert> listAll() {
            return new ArrayList<ReceiveReasonConvert>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReceiveReasonConvert> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReceiveReasonConvert." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReceiveReasonConvert> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReceiveReasonConvert> clsList = new ArrayList<ReceiveReasonConvert>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReceiveReasonConvert> groupOf(String groupName) {
            return new ArrayList<ReceiveReasonConvert>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入荷発生事由_預り品入荷
     */
    public enum ReceiveReasonDepositReceive implements CDef {
        /** $6: 預り品入荷 */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, ReceiveReasonDepositReceive> _codeClsMap = new HashMap<String, ReceiveReasonDepositReceive>();
        private static final Map<String, ReceiveReasonDepositReceive> _nameClsMap = new HashMap<String, ReceiveReasonDepositReceive>();
        static {
            for (ReceiveReasonDepositReceive value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReceiveReasonDepositReceive(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReceiveReasonDepositReceive; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveReasonDepositReceive> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReceiveReasonDepositReceive) { return OptionalThing.of((ReceiveReasonDepositReceive)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveReasonDepositReceive> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReceiveReasonDepositReceive codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReceiveReasonDepositReceive) { return (ReceiveReasonDepositReceive)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReceiveReasonDepositReceive nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReceiveReasonDepositReceive> listAll() {
            return new ArrayList<ReceiveReasonDepositReceive>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReceiveReasonDepositReceive> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReceiveReasonDepositReceive." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReceiveReasonDepositReceive> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReceiveReasonDepositReceive> clsList = new ArrayList<ReceiveReasonDepositReceive>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReceiveReasonDepositReceive> groupOf(String groupName) {
            return new ArrayList<ReceiveReasonDepositReceive>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入荷ステータス_未入荷
     */
    public enum ReceiveStatus01 implements CDef {
        /** $01: 未入荷 */
        $01("01", "$01", emptyStrings())
        ;
        private static final Map<String, ReceiveStatus01> _codeClsMap = new HashMap<String, ReceiveStatus01>();
        private static final Map<String, ReceiveStatus01> _nameClsMap = new HashMap<String, ReceiveStatus01>();
        static {
            for (ReceiveStatus01 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReceiveStatus01(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReceiveStatus01; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveStatus01> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReceiveStatus01) { return OptionalThing.of((ReceiveStatus01)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveStatus01> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReceiveStatus01 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReceiveStatus01) { return (ReceiveStatus01)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReceiveStatus01 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReceiveStatus01> listAll() {
            return new ArrayList<ReceiveStatus01>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReceiveStatus01> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReceiveStatus01." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReceiveStatus01> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReceiveStatus01> clsList = new ArrayList<ReceiveStatus01>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReceiveStatus01> groupOf(String groupName) {
            return new ArrayList<ReceiveStatus01>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 推奨ロケーション区分
     */
    public enum RecommendLocationTypeCd implements CDef {
        /** $1: マスタ設定値 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 前回ロケ */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, RecommendLocationTypeCd> _codeClsMap = new HashMap<String, RecommendLocationTypeCd>();
        private static final Map<String, RecommendLocationTypeCd> _nameClsMap = new HashMap<String, RecommendLocationTypeCd>();
        static {
            for (RecommendLocationTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private RecommendLocationTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.RecommendLocationTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RecommendLocationTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof RecommendLocationTypeCd) { return OptionalThing.of((RecommendLocationTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RecommendLocationTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static RecommendLocationTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof RecommendLocationTypeCd) { return (RecommendLocationTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static RecommendLocationTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<RecommendLocationTypeCd> listAll() {
            return new ArrayList<RecommendLocationTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<RecommendLocationTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: RecommendLocationTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<RecommendLocationTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<RecommendLocationTypeCd> clsList = new ArrayList<RecommendLocationTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<RecommendLocationTypeCd> groupOf(String groupName) {
            return new ArrayList<RecommendLocationTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 関連商品
     */
    public enum RelatedProducts implements CDef {
        /** $01: FW関連商品 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: SH関連商品 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: UN関連商品 */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: HM関連商品 */
        $04("04", "$04", emptyStrings())
        ;
        private static final Map<String, RelatedProducts> _codeClsMap = new HashMap<String, RelatedProducts>();
        private static final Map<String, RelatedProducts> _nameClsMap = new HashMap<String, RelatedProducts>();
        static {
            for (RelatedProducts value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private RelatedProducts(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.RelatedProducts; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RelatedProducts> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof RelatedProducts) { return OptionalThing.of((RelatedProducts)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RelatedProducts> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static RelatedProducts codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof RelatedProducts) { return (RelatedProducts)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static RelatedProducts nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<RelatedProducts> listAll() {
            return new ArrayList<RelatedProducts>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<RelatedProducts> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: RelatedProducts." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<RelatedProducts> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<RelatedProducts> clsList = new ArrayList<RelatedProducts>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<RelatedProducts> groupOf(String groupName) {
            return new ArrayList<RelatedProducts>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 残数有フラグ
     */
    public enum RemainFlg implements CDef {
        /** $0: 残数無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 残数有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, RemainFlg> _codeClsMap = new HashMap<String, RemainFlg>();
        private static final Map<String, RemainFlg> _nameClsMap = new HashMap<String, RemainFlg>();
        static {
            for (RemainFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private RemainFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.RemainFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RemainFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof RemainFlg) { return OptionalThing.of((RemainFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RemainFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static RemainFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof RemainFlg) { return (RemainFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static RemainFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<RemainFlg> listAll() {
            return new ArrayList<RemainFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<RemainFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: RemainFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<RemainFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<RemainFlg> clsList = new ArrayList<RemainFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<RemainFlg> groupOf(String groupName) {
            return new ArrayList<RemainFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 補充荷姿
     */
    public enum ReplenishShape implements CDef {
        /** $1: バラ */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ケース */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, ReplenishShape> _codeClsMap = new HashMap<String, ReplenishShape>();
        private static final Map<String, ReplenishShape> _nameClsMap = new HashMap<String, ReplenishShape>();
        static {
            for (ReplenishShape value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReplenishShape(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReplenishShape; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishShape> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReplenishShape) { return OptionalThing.of((ReplenishShape)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReplenishShape> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReplenishShape codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReplenishShape) { return (ReplenishShape)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReplenishShape nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReplenishShape> listAll() {
            return new ArrayList<ReplenishShape>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReplenishShape> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReplenishShape." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReplenishShape> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReplenishShape> clsList = new ArrayList<ReplenishShape>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReplenishShape> groupOf(String groupName) {
            return new ArrayList<ReplenishShape>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * サンプル区分
     */
    public enum SampleCls implements CDef {
        /** $1: サンプル品 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SampleCls> _codeClsMap = new HashMap<String, SampleCls>();
        private static final Map<String, SampleCls> _nameClsMap = new HashMap<String, SampleCls>();
        static {
            for (SampleCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SampleCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SampleCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SampleCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SampleCls) { return OptionalThing.of((SampleCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SampleCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SampleCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SampleCls) { return (SampleCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SampleCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SampleCls> listAll() {
            return new ArrayList<SampleCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SampleCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SampleCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SampleCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SampleCls> clsList = new ArrayList<SampleCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SampleCls> groupOf(String groupName) {
            return new ArrayList<SampleCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 検索基準日
     */
    public enum SearchReferenceDt implements CDef {
        /** $0: 出荷指示日 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 作業日 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 出荷日 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, SearchReferenceDt> _codeClsMap = new HashMap<String, SearchReferenceDt>();
        private static final Map<String, SearchReferenceDt> _nameClsMap = new HashMap<String, SearchReferenceDt>();
        static {
            for (SearchReferenceDt value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SearchReferenceDt(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SearchReferenceDt; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SearchReferenceDt> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SearchReferenceDt) { return OptionalThing.of((SearchReferenceDt)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SearchReferenceDt> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SearchReferenceDt codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SearchReferenceDt) { return (SearchReferenceDt)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SearchReferenceDt nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SearchReferenceDt> listAll() {
            return new ArrayList<SearchReferenceDt>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SearchReferenceDt> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SearchReferenceDt." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SearchReferenceDt> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SearchReferenceDt> clsList = new ArrayList<SearchReferenceDt>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SearchReferenceDt> groupOf(String groupName) {
            return new ArrayList<SearchReferenceDt>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * シリアル管理フラグ
     */
    public enum SerialManagFlg implements CDef {
        /** $0: 使用しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SerialManagFlg> _codeClsMap = new HashMap<String, SerialManagFlg>();
        private static final Map<String, SerialManagFlg> _nameClsMap = new HashMap<String, SerialManagFlg>();
        static {
            for (SerialManagFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SerialManagFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SerialManagFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SerialManagFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SerialManagFlg) { return OptionalThing.of((SerialManagFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SerialManagFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SerialManagFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SerialManagFlg) { return (SerialManagFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SerialManagFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SerialManagFlg> listAll() {
            return new ArrayList<SerialManagFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SerialManagFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SerialManagFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SerialManagFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SerialManagFlg> clsList = new ArrayList<SerialManagFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SerialManagFlg> groupOf(String groupName) {
            return new ArrayList<SerialManagFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 荷姿グループ区分
     */
    public enum ShapeGrpTypeCd implements CDef {
        /** $1: 通常 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: バラのみ */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, ShapeGrpTypeCd> _codeClsMap = new HashMap<String, ShapeGrpTypeCd>();
        private static final Map<String, ShapeGrpTypeCd> _nameClsMap = new HashMap<String, ShapeGrpTypeCd>();
        static {
            for (ShapeGrpTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShapeGrpTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShapeGrpTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShapeGrpTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShapeGrpTypeCd) { return OptionalThing.of((ShapeGrpTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShapeGrpTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShapeGrpTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShapeGrpTypeCd) { return (ShapeGrpTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShapeGrpTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShapeGrpTypeCd> listAll() {
            return new ArrayList<ShapeGrpTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShapeGrpTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShapeGrpTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShapeGrpTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShapeGrpTypeCd> clsList = new ArrayList<ShapeGrpTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShapeGrpTypeCd> groupOf(String groupName) {
            return new ArrayList<ShapeGrpTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 共有商品
     */
    public enum SharedProductTypeCd implements CDef {
        /** $Y: 共有商品 */
        $Y("Y", "$Y", emptyStrings())
        ;
        private static final Map<String, SharedProductTypeCd> _codeClsMap = new HashMap<String, SharedProductTypeCd>();
        private static final Map<String, SharedProductTypeCd> _nameClsMap = new HashMap<String, SharedProductTypeCd>();
        static {
            for (SharedProductTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SharedProductTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SharedProductTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SharedProductTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SharedProductTypeCd) { return OptionalThing.of((SharedProductTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SharedProductTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SharedProductTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SharedProductTypeCd) { return (SharedProductTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SharedProductTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SharedProductTypeCd> listAll() {
            return new ArrayList<SharedProductTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SharedProductTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SharedProductTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SharedProductTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SharedProductTypeCd> clsList = new ArrayList<SharedProductTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SharedProductTypeCd> groupOf(String groupName) {
            return new ArrayList<SharedProductTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷検品済非表示
     */
    public enum ShippingInspectionHidden implements CDef {
        /** $0: 出荷検品済を表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出荷検品済を非表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ShippingInspectionHidden> _codeClsMap = new HashMap<String, ShippingInspectionHidden>();
        private static final Map<String, ShippingInspectionHidden> _nameClsMap = new HashMap<String, ShippingInspectionHidden>();
        static {
            for (ShippingInspectionHidden value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingInspectionHidden(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingInspectionHidden; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingInspectionHidden> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingInspectionHidden) { return OptionalThing.of((ShippingInspectionHidden)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingInspectionHidden> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingInspectionHidden codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingInspectionHidden) { return (ShippingInspectionHidden)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingInspectionHidden nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingInspectionHidden> listAll() {
            return new ArrayList<ShippingInspectionHidden>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingInspectionHidden> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingInspectionHidden." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingInspectionHidden> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingInspectionHidden> clsList = new ArrayList<ShippingInspectionHidden>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingInspectionHidden> groupOf(String groupName) {
            return new ArrayList<ShippingInspectionHidden>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷検品ステータス
     */
    public enum ShippingInspectionStatus implements CDef {
        /** $01: 出荷未検品 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 出荷検品一部完了 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 出荷検品完了 */
        $03("03", "$03", emptyStrings())
        ;
        private static final Map<String, ShippingInspectionStatus> _codeClsMap = new HashMap<String, ShippingInspectionStatus>();
        private static final Map<String, ShippingInspectionStatus> _nameClsMap = new HashMap<String, ShippingInspectionStatus>();
        static {
            for (ShippingInspectionStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingInspectionStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingInspectionStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingInspectionStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingInspectionStatus) { return OptionalThing.of((ShippingInspectionStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingInspectionStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingInspectionStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingInspectionStatus) { return (ShippingInspectionStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingInspectionStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingInspectionStatus> listAll() {
            return new ArrayList<ShippingInspectionStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingInspectionStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingInspectionStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingInspectionStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingInspectionStatus> clsList = new ArrayList<ShippingInspectionStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingInspectionStatus> groupOf(String groupName) {
            return new ArrayList<ShippingInspectionStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷処理区分
     */
    public enum ShippingProcessType implements CDef {
        /** $1: 通常出荷 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 緊急出荷 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 商品振替渡し */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 加工渡し */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 転送出荷 */
        $5("5", "$5", emptyStrings())
        ;
        private static final Map<String, ShippingProcessType> _codeClsMap = new HashMap<String, ShippingProcessType>();
        private static final Map<String, ShippingProcessType> _nameClsMap = new HashMap<String, ShippingProcessType>();
        static {
            for (ShippingProcessType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingProcessType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingProcessType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingProcessType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingProcessType) { return OptionalThing.of((ShippingProcessType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingProcessType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingProcessType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingProcessType) { return (ShippingProcessType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingProcessType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingProcessType> listAll() {
            return new ArrayList<ShippingProcessType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingProcessType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingProcessType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingProcessType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingProcessType> clsList = new ArrayList<ShippingProcessType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingProcessType> groupOf(String groupName) {
            return new ArrayList<ShippingProcessType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷進捗ステータス
     */
    public enum ShippingProgress implements CDef {
        /** $01: 未出荷 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 出荷済 */
        $02("02", "$02", emptyStrings())
        ;
        private static final Map<String, ShippingProgress> _codeClsMap = new HashMap<String, ShippingProgress>();
        private static final Map<String, ShippingProgress> _nameClsMap = new HashMap<String, ShippingProgress>();
        static {
            for (ShippingProgress value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingProgress(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingProgress; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingProgress> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingProgress) { return OptionalThing.of((ShippingProgress)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingProgress> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingProgress codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingProgress) { return (ShippingProgress)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingProgress nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingProgress> listAll() {
            return new ArrayList<ShippingProgress>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingProgress> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingProgress." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingProgress> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingProgress> clsList = new ArrayList<ShippingProgress>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingProgress> groupOf(String groupName) {
            return new ArrayList<ShippingProgress>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷発生事由
     */
    public enum ShippingReason implements CDef {
        /** $1: 通常　 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 緊急 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 商品振替渡し */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 加工渡し */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 転送出荷 */
        $5("5", "$5", emptyStrings())
        ;
        private static final Map<String, ShippingReason> _codeClsMap = new HashMap<String, ShippingReason>();
        private static final Map<String, ShippingReason> _nameClsMap = new HashMap<String, ShippingReason>();
        static {
            for (ShippingReason value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingReason(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingReason; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingReason> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingReason) { return OptionalThing.of((ShippingReason)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingReason> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingReason codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingReason) { return (ShippingReason)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingReason nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingReason> listAll() {
            return new ArrayList<ShippingReason>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingReason> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingReason." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingReason> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingReason> clsList = new ArrayList<ShippingReason>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingReason> groupOf(String groupName) {
            return new ArrayList<ShippingReason>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷発生事由変換
     */
    public enum ShippingReasonConvert implements CDef {
        /** $1: 11 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: XX */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: XX */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: XX */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: XX */
        $5("5", "$5", emptyStrings())
        ;
        private static final Map<String, ShippingReasonConvert> _codeClsMap = new HashMap<String, ShippingReasonConvert>();
        private static final Map<String, ShippingReasonConvert> _nameClsMap = new HashMap<String, ShippingReasonConvert>();
        static {
            for (ShippingReasonConvert value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingReasonConvert(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingReasonConvert; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingReasonConvert> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingReasonConvert) { return OptionalThing.of((ShippingReasonConvert)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingReasonConvert> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingReasonConvert codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingReasonConvert) { return (ShippingReasonConvert)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingReasonConvert nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingReasonConvert> listAll() {
            return new ArrayList<ShippingReasonConvert>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingReasonConvert> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingReasonConvert." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingReasonConvert> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingReasonConvert> clsList = new ArrayList<ShippingReasonConvert>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingReasonConvert> groupOf(String groupName) {
            return new ArrayList<ShippingReasonConvert>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷帳票発行区分
     */
    public enum ShippingSlipType implements CDef {
        /** $01: バラ荷揃表 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: ケース荷揃表 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: バラトータル荷揃表(戸配) */
        $03("03", "$03", emptyStrings())
        ,
        /** $04: ケース荷揃表(戸配) */
        $04("04", "$04", emptyStrings())
        ,
        /** $05: バラトータル荷揃表 */
        $05("05", "$05", emptyStrings())
        ,
        /** $06: 摘み取りリスト */
        $06("06", "$06", emptyStrings())
        ,
        /** $07: 納品書 */
        $07("07", "$07", emptyStrings())
        ,
        /** $08: 荷札 */
        $08("08", "$08", emptyStrings())
        ,
        /** $09: 一体型伝票(荷札、納品書) */
        $09("09", "$09", emptyStrings())
        ,
        /** $10: 梱包明細 */
        $10("10", "$10", emptyStrings())
        ,
        /** $11: 個別貼り付けラベル */
        $11("11", "$11", emptyStrings())
        ,
        /** $12: 個人別支給明細 */
        $12("12", "$12", emptyStrings())
        ;
        private static final Map<String, ShippingSlipType> _codeClsMap = new HashMap<String, ShippingSlipType>();
        private static final Map<String, ShippingSlipType> _nameClsMap = new HashMap<String, ShippingSlipType>();
        static {
            for (ShippingSlipType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingSlipType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingSlipType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingSlipType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingSlipType) { return OptionalThing.of((ShippingSlipType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingSlipType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingSlipType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingSlipType) { return (ShippingSlipType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingSlipType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingSlipType> listAll() {
            return new ArrayList<ShippingSlipType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingSlipType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingSlipType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingSlipType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingSlipType> clsList = new ArrayList<ShippingSlipType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingSlipType> groupOf(String groupName) {
            return new ArrayList<ShippingSlipType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷区分
     */
    public enum ShippingType implements CDef {
        /** $01: 直送 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 戸配 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 店送り */
        $03("03", "$03", emptyStrings())
        ;
        private static final Map<String, ShippingType> _codeClsMap = new HashMap<String, ShippingType>();
        private static final Map<String, ShippingType> _nameClsMap = new HashMap<String, ShippingType>();
        static {
            for (ShippingType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingType) { return OptionalThing.of((ShippingType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingType) { return (ShippingType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingType> listAll() {
            return new ArrayList<ShippingType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingType> clsList = new ArrayList<ShippingType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingType> groupOf(String groupName) {
            return new ArrayList<ShippingType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 出荷作業区分
     */
    public enum ShippingWorkType implements CDef {
        /** $01: ピッキング */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 出荷検品 */
        $02("02", "$02", emptyStrings())
        ,
        /** $03: 棚卸 */
        $03("03", "$03", emptyStrings())
        ;
        private static final Map<String, ShippingWorkType> _codeClsMap = new HashMap<String, ShippingWorkType>();
        private static final Map<String, ShippingWorkType> _nameClsMap = new HashMap<String, ShippingWorkType>();
        static {
            for (ShippingWorkType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingWorkType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingWorkType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingWorkType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingWorkType) { return OptionalThing.of((ShippingWorkType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingWorkType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingWorkType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingWorkType) { return (ShippingWorkType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingWorkType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingWorkType> listAll() {
            return new ArrayList<ShippingWorkType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingWorkType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingWorkType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingWorkType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingWorkType> clsList = new ArrayList<ShippingWorkType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingWorkType> groupOf(String groupName) {
            return new ArrayList<ShippingWorkType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 伝票種別
     */
    public enum SlipType2 implements CDef {
        /** $P: 購買発注伝票（発注伝票タイプがZNB(標準購買発注)、ZUB(在庫転送オーダー)） */
        $P("P", "$P", emptyStrings())
        ,
        /** $D1: 出荷伝票（出荷伝票タイプがZCJ2(得意先返品)) */
        $D1("D1", "$D1", emptyStrings())
        ,
        /** $D2: 出荷伝票（出荷伝票タイプがZCJ5(在庫転送(返品))、ZCJ6(在庫転送(会社間返品))) */
        $D2("D2", "$D2", emptyStrings())
        ,
        /** $D3: 仕入返品用（入庫予定では未使用） */
        $D3("D3", "$D3", emptyStrings())
        ,
        /** $D4: 出荷伝票（受注伝票タイプがZBH2(預かり品入荷)の受注伝票を参照して登録された出荷伝票) */
        $D4("D4", "$D4", emptyStrings())
        ;
        private static final Map<String, SlipType2> _codeClsMap = new HashMap<String, SlipType2>();
        private static final Map<String, SlipType2> _nameClsMap = new HashMap<String, SlipType2>();
        static {
            for (SlipType2 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SlipType2(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SlipType2; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SlipType2> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SlipType2) { return OptionalThing.of((SlipType2)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SlipType2> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SlipType2 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SlipType2) { return (SlipType2)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SlipType2 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SlipType2> listAll() {
            return new ArrayList<SlipType2>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SlipType2> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SlipType2." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SlipType2> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SlipType2> clsList = new ArrayList<SlipType2>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SlipType2> groupOf(String groupName) {
            return new ArrayList<SlipType2>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 予備区分
     */
    public enum SpareTypeCd implements CDef {
        /** $Y: XXXX */
        $Y("Y", "$Y", emptyStrings())
        ;
        private static final Map<String, SpareTypeCd> _codeClsMap = new HashMap<String, SpareTypeCd>();
        private static final Map<String, SpareTypeCd> _nameClsMap = new HashMap<String, SpareTypeCd>();
        static {
            for (SpareTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SpareTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SpareTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SpareTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SpareTypeCd) { return OptionalThing.of((SpareTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SpareTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SpareTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SpareTypeCd) { return (SpareTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SpareTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SpareTypeCd> listAll() {
            return new ArrayList<SpareTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SpareTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SpareTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SpareTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SpareTypeCd> clsList = new ArrayList<SpareTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SpareTypeCd> groupOf(String groupName) {
            return new ArrayList<SpareTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 指定足数
     */
    public enum SpecifiedNumOfShoes implements CDef {
        /** $10: 運送業者再決定FW足数上限値 */
        $10("10", "$10", emptyStrings())
        ;
        private static final Map<String, SpecifiedNumOfShoes> _codeClsMap = new HashMap<String, SpecifiedNumOfShoes>();
        private static final Map<String, SpecifiedNumOfShoes> _nameClsMap = new HashMap<String, SpecifiedNumOfShoes>();
        static {
            for (SpecifiedNumOfShoes value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SpecifiedNumOfShoes(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SpecifiedNumOfShoes; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SpecifiedNumOfShoes> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SpecifiedNumOfShoes) { return OptionalThing.of((SpecifiedNumOfShoes)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SpecifiedNumOfShoes> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SpecifiedNumOfShoes codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SpecifiedNumOfShoes) { return (SpecifiedNumOfShoes)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SpecifiedNumOfShoes nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SpecifiedNumOfShoes> listAll() {
            return new ArrayList<SpecifiedNumOfShoes>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SpecifiedNumOfShoes> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SpecifiedNumOfShoes." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SpecifiedNumOfShoes> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SpecifiedNumOfShoes> clsList = new ArrayList<SpecifiedNumOfShoes>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SpecifiedNumOfShoes> groupOf(String groupName) {
            return new ArrayList<SpecifiedNumOfShoes>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 分納区分
     */
    public enum SplitDeliveryTypeCd implements CDef {
        /** $1: 不可 */
        $1("1", "$1", emptyStrings())
        ,
        /** $0: 可 */
        $0("0", "$0", emptyStrings())
        ;
        private static final Map<String, SplitDeliveryTypeCd> _codeClsMap = new HashMap<String, SplitDeliveryTypeCd>();
        private static final Map<String, SplitDeliveryTypeCd> _nameClsMap = new HashMap<String, SplitDeliveryTypeCd>();
        static {
            for (SplitDeliveryTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SplitDeliveryTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SplitDeliveryTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SplitDeliveryTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SplitDeliveryTypeCd) { return OptionalThing.of((SplitDeliveryTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SplitDeliveryTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SplitDeliveryTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SplitDeliveryTypeCd) { return (SplitDeliveryTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SplitDeliveryTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SplitDeliveryTypeCd> listAll() {
            return new ArrayList<SplitDeliveryTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SplitDeliveryTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SplitDeliveryTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SplitDeliveryTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SplitDeliveryTypeCd> clsList = new ArrayList<SplitDeliveryTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SplitDeliveryTypeCd> groupOf(String groupName) {
            return new ArrayList<SplitDeliveryTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫差異
     */
    public enum StockDifference implements CDef {
        /** $0: 差異無 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 差異有 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockDifference> _codeClsMap = new HashMap<String, StockDifference>();
        private static final Map<String, StockDifference> _nameClsMap = new HashMap<String, StockDifference>();
        static {
            for (StockDifference value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockDifference(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockDifference; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockDifference> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockDifference) { return OptionalThing.of((StockDifference)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockDifference> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockDifference codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockDifference) { return (StockDifference)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockDifference nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockDifference> listAll() {
            return new ArrayList<StockDifference>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockDifference> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockDifference." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockDifference> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockDifference> clsList = new ArrayList<StockDifference>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockDifference> groupOf(String groupName) {
            return new ArrayList<StockDifference>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫表示内容
     */
    public enum StockDisplayType implements CDef {
        /** $0: 商品順(日報なし) */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 商品順(日報あり) */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ロケーション順(日報なし) */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: ロケーション順(日報あり) */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, StockDisplayType> _codeClsMap = new HashMap<String, StockDisplayType>();
        private static final Map<String, StockDisplayType> _nameClsMap = new HashMap<String, StockDisplayType>();
        static {
            for (StockDisplayType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockDisplayType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockDisplayType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockDisplayType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockDisplayType) { return OptionalThing.of((StockDisplayType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockDisplayType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockDisplayType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockDisplayType) { return (StockDisplayType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockDisplayType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockDisplayType> listAll() {
            return new ArrayList<StockDisplayType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockDisplayType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockDisplayType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockDisplayType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockDisplayType> clsList = new ArrayList<StockDisplayType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockDisplayType> groupOf(String groupName) {
            return new ArrayList<StockDisplayType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 他ロケ在庫ありを表示
     */
    public enum StockExist implements CDef {
        /** $1: 在庫ありのみ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockExist> _codeClsMap = new HashMap<String, StockExist>();
        private static final Map<String, StockExist> _nameClsMap = new HashMap<String, StockExist>();
        static {
            for (StockExist value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockExist(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockExist; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockExist> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockExist) { return OptionalThing.of((StockExist)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockExist> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockExist codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockExist) { return (StockExist)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockExist nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockExist> listAll() {
            return new ArrayList<StockExist>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockExist> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockExist." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockExist> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockExist> clsList = new ArrayList<StockExist>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockExist> groupOf(String groupName) {
            return new ArrayList<StockExist>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫処理区分
     */
    public enum StockProcessType implements CDef {
        /** $01: 通常入荷 */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: 返品入荷 */
        $02("02", "$02", emptyStrings())
        ,
        /** $11: 通常出荷 */
        $11("11", "$11", emptyStrings())
        ,
        /** $12: 返品出荷 */
        $12("12", "$12", emptyStrings())
        ,
        /** $21: 移動 */
        $21("21", "$21", emptyStrings())
        ,
        /** $23: 調整(－) */
        $23("23", "$23", emptyStrings())
        ,
        /** $24: 調整(＋) */
        $24("24", "$24", emptyStrings())
        ,
        /** $25: 入庫格納 */
        $25("25", "$25", emptyStrings())
        ,
        /** $27: 入庫No分割 */
        $27("27", "$27", emptyStrings())
        ,
        /** $29: 強制移動 */
        $29("29", "$29", emptyStrings())
        ,
        /** $30: セット組指示 */
        $30("30", "$30", emptyStrings())
        ,
        /** $31: セット解除指示 */
        $31("31", "$31", emptyStrings())
        ,
        /** $32: 定期補充 */
        $32("32", "$32", emptyStrings())
        ,
        /** $33: 緊急補充他 */
        $33("33", "$33", emptyStrings())
        ;
        private static final Map<String, StockProcessType> _codeClsMap = new HashMap<String, StockProcessType>();
        private static final Map<String, StockProcessType> _nameClsMap = new HashMap<String, StockProcessType>();
        static {
            for (StockProcessType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockProcessType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockProcessType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockProcessType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockProcessType) { return OptionalThing.of((StockProcessType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockProcessType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockProcessType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockProcessType) { return (StockProcessType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockProcessType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockProcessType> listAll() {
            return new ArrayList<StockProcessType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockProcessType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockProcessType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockProcessType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockProcessType> clsList = new ArrayList<StockProcessType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockProcessType> groupOf(String groupName) {
            return new ArrayList<StockProcessType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * フロア基準在庫／ロケ基準在庫
     */
    public enum StockRefCls implements CDef {
        /** $1: フロア基準在庫 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ロケ基準在庫 */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, StockRefCls> _codeClsMap = new HashMap<String, StockRefCls>();
        private static final Map<String, StockRefCls> _nameClsMap = new HashMap<String, StockRefCls>();
        static {
            for (StockRefCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockRefCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockRefCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockRefCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockRefCls) { return OptionalThing.of((StockRefCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockRefCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockRefCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockRefCls) { return (StockRefCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockRefCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockRefCls> listAll() {
            return new ArrayList<StockRefCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockRefCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockRefCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockRefCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockRefCls> clsList = new ArrayList<StockRefCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockRefCls> groupOf(String groupName) {
            return new ArrayList<StockRefCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 棚卸進捗状況
     */
    public enum StockTakingStatus implements CDef {
        /** $10: 作業中 */
        $10("10", "$10", emptyStrings())
        ,
        /** $20: 確定済 */
        $20("20", "$20", emptyStrings())
        ,
        /** $30: 実績送信済 */
        $30("30", "$30", emptyStrings())
        ;
        private static final Map<String, StockTakingStatus> _codeClsMap = new HashMap<String, StockTakingStatus>();
        private static final Map<String, StockTakingStatus> _nameClsMap = new HashMap<String, StockTakingStatus>();
        static {
            for (StockTakingStatus value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockTakingStatus(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockTakingStatus; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockTakingStatus> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockTakingStatus) { return OptionalThing.of((StockTakingStatus)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockTakingStatus> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockTakingStatus codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockTakingStatus) { return (StockTakingStatus)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockTakingStatus nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockTakingStatus> listAll() {
            return new ArrayList<StockTakingStatus>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockTakingStatus> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockTakingStatus." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockTakingStatus> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockTakingStatus> clsList = new ArrayList<StockTakingStatus>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockTakingStatus> groupOf(String groupName) {
            return new ArrayList<StockTakingStatus>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 在庫数０表示
     */
    public enum StockZeroDisplay implements CDef {
        /** $0: 0表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 0非表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, StockZeroDisplay> _codeClsMap = new HashMap<String, StockZeroDisplay>();
        private static final Map<String, StockZeroDisplay> _nameClsMap = new HashMap<String, StockZeroDisplay>();
        static {
            for (StockZeroDisplay value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StockZeroDisplay(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StockZeroDisplay; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockZeroDisplay> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StockZeroDisplay) { return OptionalThing.of((StockZeroDisplay)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StockZeroDisplay> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StockZeroDisplay codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StockZeroDisplay) { return (StockZeroDisplay)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StockZeroDisplay nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StockZeroDisplay> listAll() {
            return new ArrayList<StockZeroDisplay>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StockZeroDisplay> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StockZeroDisplay." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StockZeroDisplay> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StockZeroDisplay> clsList = new ArrayList<StockZeroDisplay>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StockZeroDisplay> groupOf(String groupName) {
            return new ArrayList<StockZeroDisplay>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 用品
     */
    public enum SuppliesVarietyFlg implements CDef {
        /** $1: 特定品種 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SuppliesVarietyFlg> _codeClsMap = new HashMap<String, SuppliesVarietyFlg>();
        private static final Map<String, SuppliesVarietyFlg> _nameClsMap = new HashMap<String, SuppliesVarietyFlg>();
        static {
            for (SuppliesVarietyFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SuppliesVarietyFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SuppliesVarietyFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SuppliesVarietyFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SuppliesVarietyFlg) { return OptionalThing.of((SuppliesVarietyFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SuppliesVarietyFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SuppliesVarietyFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SuppliesVarietyFlg) { return (SuppliesVarietyFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SuppliesVarietyFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SuppliesVarietyFlg> listAll() {
            return new ArrayList<SuppliesVarietyFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SuppliesVarietyFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SuppliesVarietyFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SuppliesVarietyFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SuppliesVarietyFlg> clsList = new ArrayList<SuppliesVarietyFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SuppliesVarietyFlg> groupOf(String groupName) {
            return new ArrayList<SuppliesVarietyFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 対象拠点
     */
    public enum TargetBase implements CDef {
        /** $1: 00002000 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 00002300 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 00002100 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 00002700 */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: 00002200 */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: 00002600 */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, TargetBase> _codeClsMap = new HashMap<String, TargetBase>();
        private static final Map<String, TargetBase> _nameClsMap = new HashMap<String, TargetBase>();
        static {
            for (TargetBase value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TargetBase(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TargetBase; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TargetBase> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TargetBase) { return OptionalThing.of((TargetBase)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TargetBase> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TargetBase codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TargetBase) { return (TargetBase)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TargetBase nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TargetBase> listAll() {
            return new ArrayList<TargetBase>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TargetBase> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TargetBase." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TargetBase> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TargetBase> clsList = new ArrayList<TargetBase>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TargetBase> groupOf(String groupName) {
            return new ArrayList<TargetBase>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 対象商品
     */
    public enum TargetItemCd implements CDef {
        /** $1: XXXX */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: XXXX */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, TargetItemCd> _codeClsMap = new HashMap<String, TargetItemCd>();
        private static final Map<String, TargetItemCd> _nameClsMap = new HashMap<String, TargetItemCd>();
        static {
            for (TargetItemCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TargetItemCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TargetItemCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TargetItemCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TargetItemCd) { return OptionalThing.of((TargetItemCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TargetItemCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TargetItemCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TargetItemCd) { return (TargetItemCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TargetItemCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TargetItemCd> listAll() {
            return new ArrayList<TargetItemCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TargetItemCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TargetItemCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TargetItemCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TargetItemCd> clsList = new ArrayList<TargetItemCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TargetItemCd> groupOf(String groupName) {
            return new ArrayList<TargetItemCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 対象戸口契約先
     */
    public enum TargetKoguchiCd implements CDef {
        /** $BLDL3390: XXXX */
        $BLDL3390("BLDL3390", "$BLDL3390", emptyStrings())
        ;
        private static final Map<String, TargetKoguchiCd> _codeClsMap = new HashMap<String, TargetKoguchiCd>();
        private static final Map<String, TargetKoguchiCd> _nameClsMap = new HashMap<String, TargetKoguchiCd>();
        static {
            for (TargetKoguchiCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TargetKoguchiCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TargetKoguchiCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TargetKoguchiCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TargetKoguchiCd) { return OptionalThing.of((TargetKoguchiCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TargetKoguchiCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TargetKoguchiCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TargetKoguchiCd) { return (TargetKoguchiCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TargetKoguchiCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TargetKoguchiCd> listAll() {
            return new ArrayList<TargetKoguchiCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TargetKoguchiCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TargetKoguchiCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TargetKoguchiCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TargetKoguchiCd> clsList = new ArrayList<TargetKoguchiCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TargetKoguchiCd> groupOf(String groupName) {
            return new ArrayList<TargetKoguchiCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 対象販売組織
     */
    public enum TargetSalesCd implements CDef {
        /** $BLDL3390: XXXX */
        $BLDL3390("BLDL3390", "$BLDL3390", emptyStrings())
        ,
        /** $BLDL3350: 0090 */
        $BLDL3350("BLDL3350", "$BLDL3350", emptyStrings())
        ;
        private static final Map<String, TargetSalesCd> _codeClsMap = new HashMap<String, TargetSalesCd>();
        private static final Map<String, TargetSalesCd> _nameClsMap = new HashMap<String, TargetSalesCd>();
        static {
            for (TargetSalesCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private TargetSalesCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.TargetSalesCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TargetSalesCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof TargetSalesCd) { return OptionalThing.of((TargetSalesCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<TargetSalesCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static TargetSalesCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof TargetSalesCd) { return (TargetSalesCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static TargetSalesCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<TargetSalesCd> listAll() {
            return new ArrayList<TargetSalesCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<TargetSalesCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: TargetSalesCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<TargetSalesCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<TargetSalesCd> clsList = new ArrayList<TargetSalesCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<TargetSalesCd> groupOf(String groupName) {
            return new ArrayList<TargetSalesCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 単位区分
     */
    public enum UnitCls implements CDef {
        /** $01: バラ */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: ケース */
        $02("02", "$02", emptyStrings())
        ;
        private static final Map<String, UnitCls> _codeClsMap = new HashMap<String, UnitCls>();
        private static final Map<String, UnitCls> _nameClsMap = new HashMap<String, UnitCls>();
        static {
            for (UnitCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private UnitCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.UnitCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UnitCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof UnitCls) { return OptionalThing.of((UnitCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UnitCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static UnitCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof UnitCls) { return (UnitCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static UnitCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<UnitCls> listAll() {
            return new ArrayList<UnitCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<UnitCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: UnitCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<UnitCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<UnitCls> clsList = new ArrayList<UnitCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<UnitCls> groupOf(String groupName) {
            return new ArrayList<UnitCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 緊急出荷時間帯
     */
    public enum UrgentShippingTimeZone implements CDef {
        /** $0: 12:30 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 15:00 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, UrgentShippingTimeZone> _codeClsMap = new HashMap<String, UrgentShippingTimeZone>();
        private static final Map<String, UrgentShippingTimeZone> _nameClsMap = new HashMap<String, UrgentShippingTimeZone>();
        static {
            for (UrgentShippingTimeZone value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private UrgentShippingTimeZone(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.UrgentShippingTimeZone; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UrgentShippingTimeZone> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof UrgentShippingTimeZone) { return OptionalThing.of((UrgentShippingTimeZone)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<UrgentShippingTimeZone> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static UrgentShippingTimeZone codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof UrgentShippingTimeZone) { return (UrgentShippingTimeZone)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static UrgentShippingTimeZone nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<UrgentShippingTimeZone> listAll() {
            return new ArrayList<UrgentShippingTimeZone>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<UrgentShippingTimeZone> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: UrgentShippingTimeZone." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<UrgentShippingTimeZone> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<UrgentShippingTimeZone> clsList = new ArrayList<UrgentShippingTimeZone>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<UrgentShippingTimeZone> groupOf(String groupName) {
            return new ArrayList<UrgentShippingTimeZone>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 作業区分
     */
    public enum WorkType implements CDef {
        /** $1: 出荷 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 良品返却 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 廃棄返却 */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, WorkType> _codeClsMap = new HashMap<String, WorkType>();
        private static final Map<String, WorkType> _nameClsMap = new HashMap<String, WorkType>();
        static {
            for (WorkType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private WorkType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.WorkType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof WorkType) { return OptionalThing.of((WorkType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<WorkType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static WorkType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof WorkType) { return (WorkType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static WorkType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<WorkType> listAll() {
            return new ArrayList<WorkType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<WorkType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: WorkType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<WorkType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<WorkType> clsList = new ArrayList<WorkType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<WorkType> groupOf(String groupName) {
            return new ArrayList<WorkType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入荷ラベル使用フラグ
     */
    public enum ReceiveLabelFlg implements CDef {
        /** $0: 未使用 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ReceiveLabelFlg> _codeClsMap = new HashMap<String, ReceiveLabelFlg>();
        private static final Map<String, ReceiveLabelFlg> _nameClsMap = new HashMap<String, ReceiveLabelFlg>();
        static {
            for (ReceiveLabelFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReceiveLabelFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReceiveLabelFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveLabelFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReceiveLabelFlg) { return OptionalThing.of((ReceiveLabelFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveLabelFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReceiveLabelFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReceiveLabelFlg) { return (ReceiveLabelFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReceiveLabelFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReceiveLabelFlg> listAll() {
            return new ArrayList<ReceiveLabelFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReceiveLabelFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReceiveLabelFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReceiveLabelFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReceiveLabelFlg> clsList = new ArrayList<ReceiveLabelFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReceiveLabelFlg> groupOf(String groupName) {
            return new ArrayList<ReceiveLabelFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入荷日差異有
     */
    public enum ReceiveDtUnmatchFlg implements CDef {
        /** $0: 入荷日差異無のみ表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 入荷日差異有のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ReceiveDtUnmatchFlg> _codeClsMap = new HashMap<String, ReceiveDtUnmatchFlg>();
        private static final Map<String, ReceiveDtUnmatchFlg> _nameClsMap = new HashMap<String, ReceiveDtUnmatchFlg>();
        static {
            for (ReceiveDtUnmatchFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReceiveDtUnmatchFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReceiveDtUnmatchFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveDtUnmatchFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReceiveDtUnmatchFlg) { return OptionalThing.of((ReceiveDtUnmatchFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveDtUnmatchFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReceiveDtUnmatchFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReceiveDtUnmatchFlg) { return (ReceiveDtUnmatchFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReceiveDtUnmatchFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReceiveDtUnmatchFlg> listAll() {
            return new ArrayList<ReceiveDtUnmatchFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReceiveDtUnmatchFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReceiveDtUnmatchFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReceiveDtUnmatchFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReceiveDtUnmatchFlg> clsList = new ArrayList<ReceiveDtUnmatchFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReceiveDtUnmatchFlg> groupOf(String groupName) {
            return new ArrayList<ReceiveDtUnmatchFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 発行状況
     */
    public enum PrintFlg implements CDef {
        /** $0: 未発行 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 発行済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PrintFlg> _codeClsMap = new HashMap<String, PrintFlg>();
        private static final Map<String, PrintFlg> _nameClsMap = new HashMap<String, PrintFlg>();
        static {
            for (PrintFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PrintFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PrintFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PrintFlg) { return OptionalThing.of((PrintFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PrintFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PrintFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PrintFlg) { return (PrintFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PrintFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PrintFlg> listAll() {
            return new ArrayList<PrintFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PrintFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PrintFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PrintFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PrintFlg> clsList = new ArrayList<PrintFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PrintFlg> groupOf(String groupName) {
            return new ArrayList<PrintFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入荷残数有
     */
    public enum ReceiveRemainFlg implements CDef {
        /** $0: 残数無のみ表示 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 残数有のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ReceiveRemainFlg> _codeClsMap = new HashMap<String, ReceiveRemainFlg>();
        private static final Map<String, ReceiveRemainFlg> _nameClsMap = new HashMap<String, ReceiveRemainFlg>();
        static {
            for (ReceiveRemainFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ReceiveRemainFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ReceiveRemainFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveRemainFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ReceiveRemainFlg) { return OptionalThing.of((ReceiveRemainFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ReceiveRemainFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ReceiveRemainFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ReceiveRemainFlg) { return (ReceiveRemainFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ReceiveRemainFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ReceiveRemainFlg> listAll() {
            return new ArrayList<ReceiveRemainFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ReceiveRemainFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ReceiveRemainFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ReceiveRemainFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ReceiveRemainFlg> clsList = new ArrayList<ReceiveRemainFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ReceiveRemainFlg> groupOf(String groupName) {
            return new ArrayList<ReceiveRemainFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * ピッキング済非表示
     */
    public enum ShippingPickedHidden implements CDef {
        /** $1: ピッキング済を非表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ShippingPickedHidden> _codeClsMap = new HashMap<String, ShippingPickedHidden>();
        private static final Map<String, ShippingPickedHidden> _nameClsMap = new HashMap<String, ShippingPickedHidden>();
        static {
            for (ShippingPickedHidden value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ShippingPickedHidden(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ShippingPickedHidden; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingPickedHidden> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ShippingPickedHidden) { return OptionalThing.of((ShippingPickedHidden)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ShippingPickedHidden> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ShippingPickedHidden codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ShippingPickedHidden) { return (ShippingPickedHidden)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ShippingPickedHidden nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ShippingPickedHidden> listAll() {
            return new ArrayList<ShippingPickedHidden>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ShippingPickedHidden> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ShippingPickedHidden." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ShippingPickedHidden> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ShippingPickedHidden> clsList = new ArrayList<ShippingPickedHidden>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ShippingPickedHidden> groupOf(String groupName) {
            return new ArrayList<ShippingPickedHidden>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 運送業者データ出力フラグ
     */
    public enum CarrierDataOutFlg implements CDef {
        /** $0: 未出力 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出力済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CarrierDataOutFlg> _codeClsMap = new HashMap<String, CarrierDataOutFlg>();
        private static final Map<String, CarrierDataOutFlg> _nameClsMap = new HashMap<String, CarrierDataOutFlg>();
        static {
            for (CarrierDataOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CarrierDataOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CarrierDataOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CarrierDataOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CarrierDataOutFlg) { return OptionalThing.of((CarrierDataOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CarrierDataOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CarrierDataOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CarrierDataOutFlg) { return (CarrierDataOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CarrierDataOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CarrierDataOutFlg> listAll() {
            return new ArrayList<CarrierDataOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CarrierDataOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CarrierDataOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CarrierDataOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CarrierDataOutFlg> clsList = new ArrayList<CarrierDataOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CarrierDataOutFlg> groupOf(String groupName) {
            return new ArrayList<CarrierDataOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 梱包明細出力フラグ
     */
    public enum PllOutFlg implements CDef {
        /** $0: 未出力 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 出力済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, PllOutFlg> _codeClsMap = new HashMap<String, PllOutFlg>();
        private static final Map<String, PllOutFlg> _nameClsMap = new HashMap<String, PllOutFlg>();
        static {
            for (PllOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private PllOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.PllOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PllOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof PllOutFlg) { return OptionalThing.of((PllOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<PllOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static PllOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof PllOutFlg) { return (PllOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static PllOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<PllOutFlg> listAll() {
            return new ArrayList<PllOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<PllOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: PllOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<PllOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<PllOutFlg> clsList = new ArrayList<PllOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<PllOutFlg> groupOf(String groupName) {
            return new ArrayList<PllOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 所有者
     */
    public enum DepositorCls implements CDef {
        /** $P135: ＦＷ統括部 */
        $P135("P135", "$P135", emptyStrings())
        ,
        /** $P161: ヘルメット統括部 */
        $P161("P161", "$P161", emptyStrings())
        ,
        /** $P801: エムシーアパレル株式会社 */
        $P801("P801", "$P801", emptyStrings())
        ,
        /** $P900: ミドリ安全用品株式会社 */
        $P900("P900", "$P900", emptyStrings())
        ,
        /** $9999: 預り品 */
        $9999("9999", "$9999", emptyStrings())
        ;
        private static final Map<String, DepositorCls> _codeClsMap = new HashMap<String, DepositorCls>();
        private static final Map<String, DepositorCls> _nameClsMap = new HashMap<String, DepositorCls>();
        static {
            for (DepositorCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private DepositorCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.DepositorCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DepositorCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof DepositorCls) { return OptionalThing.of((DepositorCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<DepositorCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static DepositorCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof DepositorCls) { return (DepositorCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static DepositorCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<DepositorCls> listAll() {
            return new ArrayList<DepositorCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<DepositorCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: DepositorCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<DepositorCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<DepositorCls> clsList = new ArrayList<DepositorCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<DepositorCls> groupOf(String groupName) {
            return new ArrayList<DepositorCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 入荷予定リスト出力フラグ
     */
    public enum RplOutFlg implements CDef {
        /** $0: 未発行 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 発行済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, RplOutFlg> _codeClsMap = new HashMap<String, RplOutFlg>();
        private static final Map<String, RplOutFlg> _nameClsMap = new HashMap<String, RplOutFlg>();
        static {
            for (RplOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private RplOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.RplOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RplOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof RplOutFlg) { return OptionalThing.of((RplOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RplOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static RplOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof RplOutFlg) { return (RplOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static RplOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<RplOutFlg> listAll() {
            return new ArrayList<RplOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<RplOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: RplOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<RplOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<RplOutFlg> clsList = new ArrayList<RplOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<RplOutFlg> groupOf(String groupName) {
            return new ArrayList<RplOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 実績送信フラグ
     */
    public enum RecordSendFlg implements CDef {
        /** $0: 未送信 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 送信済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, RecordSendFlg> _codeClsMap = new HashMap<String, RecordSendFlg>();
        private static final Map<String, RecordSendFlg> _nameClsMap = new HashMap<String, RecordSendFlg>();
        static {
            for (RecordSendFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private RecordSendFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.RecordSendFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RecordSendFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof RecordSendFlg) { return OptionalThing.of((RecordSendFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<RecordSendFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static RecordSendFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof RecordSendFlg) { return (RecordSendFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static RecordSendFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<RecordSendFlg> listAll() {
            return new ArrayList<RecordSendFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<RecordSendFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: RecordSendFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<RecordSendFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<RecordSendFlg> clsList = new ArrayList<RecordSendFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<RecordSendFlg> groupOf(String groupName) {
            return new ArrayList<RecordSendFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 引き渡し済非表示
     */
    public enum HandOverHidden implements CDef {
        /** $1: 引き渡し前のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, HandOverHidden> _codeClsMap = new HashMap<String, HandOverHidden>();
        private static final Map<String, HandOverHidden> _nameClsMap = new HashMap<String, HandOverHidden>();
        static {
            for (HandOverHidden value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private HandOverHidden(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.HandOverHidden; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HandOverHidden> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof HandOverHidden) { return OptionalThing.of((HandOverHidden)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HandOverHidden> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static HandOverHidden codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof HandOverHidden) { return (HandOverHidden)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static HandOverHidden nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<HandOverHidden> listAll() {
            return new ArrayList<HandOverHidden>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<HandOverHidden> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: HandOverHidden." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<HandOverHidden> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<HandOverHidden> clsList = new ArrayList<HandOverHidden>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<HandOverHidden> groupOf(String groupName) {
            return new ArrayList<HandOverHidden>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 外部倉庫フラグ
     */
    public enum ExternalWarehouseFlg implements CDef {
        /** $0: 通常倉庫 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 外部倉庫 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ExternalWarehouseFlg> _codeClsMap = new HashMap<String, ExternalWarehouseFlg>();
        private static final Map<String, ExternalWarehouseFlg> _nameClsMap = new HashMap<String, ExternalWarehouseFlg>();
        static {
            for (ExternalWarehouseFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ExternalWarehouseFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ExternalWarehouseFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ExternalWarehouseFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ExternalWarehouseFlg) { return OptionalThing.of((ExternalWarehouseFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ExternalWarehouseFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ExternalWarehouseFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ExternalWarehouseFlg) { return (ExternalWarehouseFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ExternalWarehouseFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ExternalWarehouseFlg> listAll() {
            return new ArrayList<ExternalWarehouseFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ExternalWarehouseFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ExternalWarehouseFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ExternalWarehouseFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ExternalWarehouseFlg> clsList = new ArrayList<ExternalWarehouseFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ExternalWarehouseFlg> groupOf(String groupName) {
            return new ArrayList<ExternalWarehouseFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 通常品プラント
     */
    public enum StandardPlantCls implements CDef {
        /** $P135: ＦＷ統括部 */
        $P135("P135", "$P135", emptyStrings())
        ,
        /** $P161: ヘルメット統括部 */
        $P161("P161", "$P161", emptyStrings())
        ,
        /** $P801: エムシーアパレル株式会社 */
        $P801("P801", "$P801", emptyStrings())
        ,
        /** $P900: ミドリ安全用品株式会社 */
        $P900("P900", "$P900", emptyStrings())
        ;
        private static final Map<String, StandardPlantCls> _codeClsMap = new HashMap<String, StandardPlantCls>();
        private static final Map<String, StandardPlantCls> _nameClsMap = new HashMap<String, StandardPlantCls>();
        static {
            for (StandardPlantCls value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private StandardPlantCls(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.StandardPlantCls; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StandardPlantCls> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof StandardPlantCls) { return OptionalThing.of((StandardPlantCls)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<StandardPlantCls> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static StandardPlantCls codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof StandardPlantCls) { return (StandardPlantCls)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static StandardPlantCls nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<StandardPlantCls> listAll() {
            return new ArrayList<StandardPlantCls>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<StandardPlantCls> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: StandardPlantCls." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<StandardPlantCls> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<StandardPlantCls> clsList = new ArrayList<StandardPlantCls>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<StandardPlantCls> groupOf(String groupName) {
            return new ArrayList<StandardPlantCls>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 大物取扱フラグ
     */
    public enum LargeItemHadlingFlg implements CDef {
        /** $0: 使用しない */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 使用する */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, LargeItemHadlingFlg> _codeClsMap = new HashMap<String, LargeItemHadlingFlg>();
        private static final Map<String, LargeItemHadlingFlg> _nameClsMap = new HashMap<String, LargeItemHadlingFlg>();
        static {
            for (LargeItemHadlingFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private LargeItemHadlingFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.LargeItemHadlingFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LargeItemHadlingFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof LargeItemHadlingFlg) { return OptionalThing.of((LargeItemHadlingFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<LargeItemHadlingFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static LargeItemHadlingFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof LargeItemHadlingFlg) { return (LargeItemHadlingFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static LargeItemHadlingFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<LargeItemHadlingFlg> listAll() {
            return new ArrayList<LargeItemHadlingFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<LargeItemHadlingFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: LargeItemHadlingFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<LargeItemHadlingFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<LargeItemHadlingFlg> clsList = new ArrayList<LargeItemHadlingFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<LargeItemHadlingFlg> groupOf(String groupName) {
            return new ArrayList<LargeItemHadlingFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 休日振替運送業者フラグ
     */
    public enum HolidayCarrierFlg implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, HolidayCarrierFlg> _codeClsMap = new HashMap<String, HolidayCarrierFlg>();
        private static final Map<String, HolidayCarrierFlg> _nameClsMap = new HashMap<String, HolidayCarrierFlg>();
        static {
            for (HolidayCarrierFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private HolidayCarrierFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.HolidayCarrierFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HolidayCarrierFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof HolidayCarrierFlg) { return OptionalThing.of((HolidayCarrierFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<HolidayCarrierFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static HolidayCarrierFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof HolidayCarrierFlg) { return (HolidayCarrierFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static HolidayCarrierFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<HolidayCarrierFlg> listAll() {
            return new ArrayList<HolidayCarrierFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<HolidayCarrierFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: HolidayCarrierFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<HolidayCarrierFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<HolidayCarrierFlg> clsList = new ArrayList<HolidayCarrierFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<HolidayCarrierFlg> groupOf(String groupName) {
            return new ArrayList<HolidayCarrierFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 沖縄航空便振替フラグ
     */
    public enum OkinawaFlightFlg implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, OkinawaFlightFlg> _codeClsMap = new HashMap<String, OkinawaFlightFlg>();
        private static final Map<String, OkinawaFlightFlg> _nameClsMap = new HashMap<String, OkinawaFlightFlg>();
        static {
            for (OkinawaFlightFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private OkinawaFlightFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.OkinawaFlightFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OkinawaFlightFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof OkinawaFlightFlg) { return OptionalThing.of((OkinawaFlightFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<OkinawaFlightFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static OkinawaFlightFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof OkinawaFlightFlg) { return (OkinawaFlightFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static OkinawaFlightFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<OkinawaFlightFlg> listAll() {
            return new ArrayList<OkinawaFlightFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<OkinawaFlightFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: OkinawaFlightFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<OkinawaFlightFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<OkinawaFlightFlg> clsList = new ArrayList<OkinawaFlightFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<OkinawaFlightFlg> groupOf(String groupName) {
            return new ArrayList<OkinawaFlightFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 拠点デフォルト運送業者フラグ
     */
    public enum BaseDefaultCarrierFlg implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, BaseDefaultCarrierFlg> _codeClsMap = new HashMap<String, BaseDefaultCarrierFlg>();
        private static final Map<String, BaseDefaultCarrierFlg> _nameClsMap = new HashMap<String, BaseDefaultCarrierFlg>();
        static {
            for (BaseDefaultCarrierFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private BaseDefaultCarrierFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.BaseDefaultCarrierFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BaseDefaultCarrierFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof BaseDefaultCarrierFlg) { return OptionalThing.of((BaseDefaultCarrierFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<BaseDefaultCarrierFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static BaseDefaultCarrierFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof BaseDefaultCarrierFlg) { return (BaseDefaultCarrierFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static BaseDefaultCarrierFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<BaseDefaultCarrierFlg> listAll() {
            return new ArrayList<BaseDefaultCarrierFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<BaseDefaultCarrierFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: BaseDefaultCarrierFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<BaseDefaultCarrierFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<BaseDefaultCarrierFlg> clsList = new ArrayList<BaseDefaultCarrierFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<BaseDefaultCarrierFlg> groupOf(String groupName) {
            return new ArrayList<BaseDefaultCarrierFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 受渡表区分
     */
    public enum SlipTypeCd implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, SlipTypeCd> _codeClsMap = new HashMap<String, SlipTypeCd>();
        private static final Map<String, SlipTypeCd> _nameClsMap = new HashMap<String, SlipTypeCd>();
        static {
            for (SlipTypeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private SlipTypeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.SlipTypeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SlipTypeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof SlipTypeCd) { return OptionalThing.of((SlipTypeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<SlipTypeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static SlipTypeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof SlipTypeCd) { return (SlipTypeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static SlipTypeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<SlipTypeCd> listAll() {
            return new ArrayList<SlipTypeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<SlipTypeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: SlipTypeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<SlipTypeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<SlipTypeCd> clsList = new ArrayList<SlipTypeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<SlipTypeCd> groupOf(String groupName) {
            return new ArrayList<SlipTypeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 正規フラグ
     */
    public enum ProperFlg implements CDef {
        /** $0: 対象外 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 対象 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, ProperFlg> _codeClsMap = new HashMap<String, ProperFlg>();
        private static final Map<String, ProperFlg> _nameClsMap = new HashMap<String, ProperFlg>();
        static {
            for (ProperFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ProperFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ProperFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProperFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ProperFlg) { return OptionalThing.of((ProperFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ProperFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ProperFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ProperFlg) { return (ProperFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ProperFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ProperFlg> listAll() {
            return new ArrayList<ProperFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ProperFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ProperFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ProperFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ProperFlg> clsList = new ArrayList<ProperFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ProperFlg> groupOf(String groupName) {
            return new ArrayList<ProperFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 運送業者引き渡し票出力フラ
     */
    public enum CdlOutFlg implements CDef {
        /** $0: 未発行 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 発行済 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CdlOutFlg> _codeClsMap = new HashMap<String, CdlOutFlg>();
        private static final Map<String, CdlOutFlg> _nameClsMap = new HashMap<String, CdlOutFlg>();
        static {
            for (CdlOutFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CdlOutFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CdlOutFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CdlOutFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CdlOutFlg) { return OptionalThing.of((CdlOutFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CdlOutFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CdlOutFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CdlOutFlg) { return (CdlOutFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CdlOutFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CdlOutFlg> listAll() {
            return new ArrayList<CdlOutFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CdlOutFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CdlOutFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CdlOutFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CdlOutFlg> clsList = new ArrayList<CdlOutFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CdlOutFlg> groupOf(String groupName) {
            return new ArrayList<CdlOutFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * エラー件数
     */
    public enum ErrorNum implements CDef {
        /** $20: 20 */
        $20("20", "$20", emptyStrings())
        ;
        private static final Map<String, ErrorNum> _codeClsMap = new HashMap<String, ErrorNum>();
        private static final Map<String, ErrorNum> _nameClsMap = new HashMap<String, ErrorNum>();
        static {
            for (ErrorNum value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private ErrorNum(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.ErrorNum; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ErrorNum> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof ErrorNum) { return OptionalThing.of((ErrorNum)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<ErrorNum> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static ErrorNum codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof ErrorNum) { return (ErrorNum)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static ErrorNum nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<ErrorNum> listAll() {
            return new ArrayList<ErrorNum>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<ErrorNum> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: ErrorNum." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<ErrorNum> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<ErrorNum> clsList = new ArrayList<ErrorNum>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<ErrorNum> groupOf(String groupName) {
            return new ArrayList<ErrorNum>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 一次ピッキングリスト
     */
    public enum CenterPicListCls1 implements CDef {
        /** $0: オーダーピッキングリスト */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: トータルピッキングリスト */
        $1("1", "$1", emptyStrings())
        ,
        /** $4: ケースピッキングリスト */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: マルチピッキングリスト */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: 単行ピッキングリスト */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, CenterPicListCls1> _codeClsMap = new HashMap<String, CenterPicListCls1>();
        private static final Map<String, CenterPicListCls1> _nameClsMap = new HashMap<String, CenterPicListCls1>();
        static {
            for (CenterPicListCls1 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterPicListCls1(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterPicListCls1; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPicListCls1> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterPicListCls1) { return OptionalThing.of((CenterPicListCls1)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPicListCls1> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterPicListCls1 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterPicListCls1) { return (CenterPicListCls1)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterPicListCls1 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterPicListCls1> listAll() {
            return new ArrayList<CenterPicListCls1>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterPicListCls1> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterPicListCls1." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterPicListCls1> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterPicListCls1> clsList = new ArrayList<CenterPicListCls1>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterPicListCls1> groupOf(String groupName) {
            return new ArrayList<CenterPicListCls1>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 二次ピッキングリスト
     */
    public enum CenterPicListCls2 implements CDef {
        /** $2: 摘み取りリスト */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 種蒔きリスト */
        $3("3", "$3", emptyStrings())
        ;
        private static final Map<String, CenterPicListCls2> _codeClsMap = new HashMap<String, CenterPicListCls2>();
        private static final Map<String, CenterPicListCls2> _nameClsMap = new HashMap<String, CenterPicListCls2>();
        static {
            for (CenterPicListCls2 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterPicListCls2(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterPicListCls2; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPicListCls2> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterPicListCls2) { return OptionalThing.of((CenterPicListCls2)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPicListCls2> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterPicListCls2 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterPicListCls2) { return (CenterPicListCls2)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterPicListCls2 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterPicListCls2> listAll() {
            return new ArrayList<CenterPicListCls2>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterPicListCls2> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterPicListCls2." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterPicListCls2> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterPicListCls2> clsList = new ArrayList<CenterPicListCls2>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterPicListCls2> groupOf(String groupName) {
            return new ArrayList<CenterPicListCls2>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送り状・荷札
     */
    public enum CenterPicListCls3 implements CDef {
        /** $1: 送り状＋バラ・ケース荷札 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: 送り状＋バラ荷札 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: 送り状＋ケース荷札 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 送り状 */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: バラ・ケース荷札 */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: バラ荷札 */
        $6("6", "$6", emptyStrings())
        ,
        /** $7: ケース荷札 */
        $7("7", "$7", emptyStrings())
        ;
        private static final Map<String, CenterPicListCls3> _codeClsMap = new HashMap<String, CenterPicListCls3>();
        private static final Map<String, CenterPicListCls3> _nameClsMap = new HashMap<String, CenterPicListCls3>();
        static {
            for (CenterPicListCls3 value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterPicListCls3(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterPicListCls3; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPicListCls3> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterPicListCls3) { return OptionalThing.of((CenterPicListCls3)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPicListCls3> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterPicListCls3 codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterPicListCls3) { return (CenterPicListCls3)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterPicListCls3 nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterPicListCls3> listAll() {
            return new ArrayList<CenterPicListCls3>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterPicListCls3> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterPicListCls3." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterPicListCls3> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterPicListCls3> clsList = new ArrayList<CenterPicListCls3>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterPicListCls3> groupOf(String groupName) {
            return new ArrayList<CenterPicListCls3>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 佐川配達時間帯
     */
    public enum CenterSagawaDelivTz implements CDef {
        /** $01: 午前中 */
        $01("01", "$01", emptyStrings())
        ,
        /** $04: 18時～21時 */
        $04("04", "$04", emptyStrings())
        ,
        /** $12: 12時～14時 */
        $12("12", "$12", emptyStrings())
        ,
        /** $14: 14時～16時 */
        $14("14", "$14", emptyStrings())
        ,
        /** $16: 16時～18時 */
        $16("16", "$16", emptyStrings())
        ,
        /** $18: 18時～20時 */
        $18("18", "$18", emptyStrings())
        ,
        /** $19: 19時～21時 */
        $19("19", "$19", emptyStrings())
        ;
        private static final Map<String, CenterSagawaDelivTz> _codeClsMap = new HashMap<String, CenterSagawaDelivTz>();
        private static final Map<String, CenterSagawaDelivTz> _nameClsMap = new HashMap<String, CenterSagawaDelivTz>();
        static {
            for (CenterSagawaDelivTz value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterSagawaDelivTz(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterSagawaDelivTz; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterSagawaDelivTz> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterSagawaDelivTz) { return OptionalThing.of((CenterSagawaDelivTz)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterSagawaDelivTz> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterSagawaDelivTz codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterSagawaDelivTz) { return (CenterSagawaDelivTz)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterSagawaDelivTz nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterSagawaDelivTz> listAll() {
            return new ArrayList<CenterSagawaDelivTz>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterSagawaDelivTz> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterSagawaDelivTz." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterSagawaDelivTz> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterSagawaDelivTz> clsList = new ArrayList<CenterSagawaDelivTz>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterSagawaDelivTz> groupOf(String groupName) {
            return new ArrayList<CenterSagawaDelivTz>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 便種(商品)
     */
    public enum CenterTransportTypeItem implements CDef {
        /** $001: 指定なし */
        $001("001", "$001", emptyStrings())
        ,
        /** $002: 飛脚クール便(冷蔵) */
        $002("002", "$002", emptyStrings())
        ,
        /** $003: 飛脚クール便(冷凍) */
        $003("003", "$003", emptyStrings())
        ;
        private static final Map<String, CenterTransportTypeItem> _codeClsMap = new HashMap<String, CenterTransportTypeItem>();
        private static final Map<String, CenterTransportTypeItem> _nameClsMap = new HashMap<String, CenterTransportTypeItem>();
        static {
            for (CenterTransportTypeItem value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterTransportTypeItem(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterTransportTypeItem; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTransportTypeItem> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterTransportTypeItem) { return OptionalThing.of((CenterTransportTypeItem)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTransportTypeItem> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterTransportTypeItem codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterTransportTypeItem) { return (CenterTransportTypeItem)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterTransportTypeItem nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterTransportTypeItem> listAll() {
            return new ArrayList<CenterTransportTypeItem>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterTransportTypeItem> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterTransportTypeItem." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterTransportTypeItem> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterTransportTypeItem> clsList = new ArrayList<CenterTransportTypeItem>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterTransportTypeItem> groupOf(String groupName) {
            return new ArrayList<CenterTransportTypeItem>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 荷姿コード
     */
    public enum CenterSlipShapeCd implements CDef {
        /** $001: 箱類 */
        $001("001", "$001", emptyStrings())
        ,
        /** $002: バッグ類 */
        $002("002", "$002", emptyStrings())
        ,
        /** $003: スーツケース */
        $003("003", "$003", emptyStrings())
        ,
        /** $004: 封筒類 */
        $004("004", "$004", emptyStrings())
        ,
        /** $005: ゴルフバッグ */
        $005("005", "$005", emptyStrings())
        ,
        /** $006: スキー */
        $006("006", "$006", emptyStrings())
        ,
        /** $007: スノーボード */
        $007("007", "$007", emptyStrings())
        ,
        /** $008: その他 */
        $008("008", "$008", emptyStrings())
        ;
        private static final Map<String, CenterSlipShapeCd> _codeClsMap = new HashMap<String, CenterSlipShapeCd>();
        private static final Map<String, CenterSlipShapeCd> _nameClsMap = new HashMap<String, CenterSlipShapeCd>();
        static {
            for (CenterSlipShapeCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterSlipShapeCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterSlipShapeCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterSlipShapeCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterSlipShapeCd) { return OptionalThing.of((CenterSlipShapeCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterSlipShapeCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterSlipShapeCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterSlipShapeCd) { return (CenterSlipShapeCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterSlipShapeCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterSlipShapeCd> listAll() {
            return new ArrayList<CenterSlipShapeCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterSlipShapeCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterSlipShapeCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterSlipShapeCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterSlipShapeCd> clsList = new ArrayList<CenterSlipShapeCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterSlipShapeCd> groupOf(String groupName) {
            return new ArrayList<CenterSlipShapeCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 便種(スピードで選択)
     */
    public enum CenterTransportTypeSpeed implements CDef {
        /** $000: 飛脚宅配便 */
        $000("000", "$000", emptyStrings())
        ,
        /** $001: 飛脚スーパー便 */
        $001("001", "$001", emptyStrings())
        ,
        /** $002: 飛脚即配便 */
        $002("002", "$002", emptyStrings())
        ,
        /** $003: 飛脚航空便(翌日中配達) */
        $003("003", "$003", emptyStrings())
        ,
        /** $004: 飛脚航空便(翌日午前中配達) */
        $004("004", "$004", emptyStrings())
        ,
        /** $005: 飛脚ジャストタイム便 */
        $005("005", "$005", emptyStrings())
        ;
        private static final Map<String, CenterTransportTypeSpeed> _codeClsMap = new HashMap<String, CenterTransportTypeSpeed>();
        private static final Map<String, CenterTransportTypeSpeed> _nameClsMap = new HashMap<String, CenterTransportTypeSpeed>();
        static {
            for (CenterTransportTypeSpeed value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterTransportTypeSpeed(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterTransportTypeSpeed; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTransportTypeSpeed> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterTransportTypeSpeed) { return OptionalThing.of((CenterTransportTypeSpeed)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTransportTypeSpeed> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterTransportTypeSpeed codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterTransportTypeSpeed) { return (CenterTransportTypeSpeed)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterTransportTypeSpeed nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterTransportTypeSpeed> listAll() {
            return new ArrayList<CenterTransportTypeSpeed>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterTransportTypeSpeed> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterTransportTypeSpeed." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterTransportTypeSpeed> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterTransportTypeSpeed> clsList = new ArrayList<CenterTransportTypeSpeed>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterTransportTypeSpeed> groupOf(String groupName) {
            return new ArrayList<CenterTransportTypeSpeed>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 指定シール
     */
    public enum CenterSealType implements CDef {
        /** $001: 飛脚クール便(冷蔵) */
        $001("001", "$001", emptyStrings())
        ,
        /** $002: 飛脚クール便(冷凍) */
        $002("002", "$002", emptyStrings())
        ,
        /** $003: 飛脚スーパー便 */
        $003("003", "$003", emptyStrings())
        ,
        /** $004: 営止めサービス */
        $004("004", "$004", emptyStrings())
        ,
        /** $005: 配達指定日 */
        $005("005", "$005", emptyStrings())
        ,
        /** $007: 時間帯指定(５時間帯) */
        $007("007", "$007", emptyStrings())
        ,
        /** $008: eコレクト(現金決済) */
        $008("008", "$008", emptyStrings())
        ,
        /** $009: eコレクト(デビット／クレジット決済) */
        $009("009", "$009", emptyStrings())
        ,
        /** $010: eコレクト(なんでも決済) */
        $010("010", "$010", emptyStrings())
        ,
        /** $011: 取扱注意 */
        $011("011", "$011", emptyStrings())
        ,
        /** $012: 貴重品 */
        $012("012", "$012", emptyStrings())
        ,
        /** $013: 天地無用 */
        $013("013", "$013", emptyStrings())
        ,
        /** $014: 飛脚即配便 */
        $014("014", "$014", emptyStrings())
        ,
        /** $016: 時間帯指定(午前中) */
        $016("016", "$016", emptyStrings())
        ,
        /** $017: 飛脚航空便 */
        $017("017", "$017", emptyStrings())
        ,
        /** $018: 飛脚ジャストタイム便 */
        $018("018", "$018", emptyStrings())
        ,
        /** $019: 時間帯指定(６時間帯(オプション) */
        $019("019", "$019", emptyStrings())
        ;
        private static final Map<String, CenterSealType> _codeClsMap = new HashMap<String, CenterSealType>();
        private static final Map<String, CenterSealType> _nameClsMap = new HashMap<String, CenterSealType>();
        static {
            for (CenterSealType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterSealType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterSealType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterSealType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterSealType) { return OptionalThing.of((CenterSealType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterSealType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterSealType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterSealType) { return (CenterSealType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterSealType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterSealType> listAll() {
            return new ArrayList<CenterSealType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterSealType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterSealType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterSealType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterSealType> clsList = new ArrayList<CenterSealType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterSealType> groupOf(String groupName) {
            return new ArrayList<CenterSealType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * データ種別
     */
    public enum CenterTagClass implements CDef {
        /** $01: ヤマト(通常) */
        $01("01", "$01", emptyStrings())
        ,
        /** $02: ヤマト(保冷・・・冷蔵) */
        $02("02", "$02", emptyStrings())
        ,
        /** $11: 佐川(通常) */
        $11("11", "$11", emptyStrings())
        ,
        /** $12: 佐川(保冷・・・冷蔵) */
        $12("12", "$12", emptyStrings())
        ,
        /** $21: ゆうパック(通常) */
        $21("21", "$21", emptyStrings())
        ,
        /** $22: ゆうパック(保冷・・・冷蔵) */
        $22("22", "$22", emptyStrings())
        ;
        private static final Map<String, CenterTagClass> _codeClsMap = new HashMap<String, CenterTagClass>();
        private static final Map<String, CenterTagClass> _nameClsMap = new HashMap<String, CenterTagClass>();
        static {
            for (CenterTagClass value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterTagClass(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterTagClass; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagClass> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterTagClass) { return OptionalThing.of((CenterTagClass)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagClass> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterTagClass codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterTagClass) { return (CenterTagClass)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterTagClass nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterTagClass> listAll() {
            return new ArrayList<CenterTagClass>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterTagClass> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterTagClass." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterTagClass> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterTagClass> clsList = new ArrayList<CenterTagClass>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterTagClass> groupOf(String groupName) {
            return new ArrayList<CenterTagClass>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送り状データ種別
     */
    public enum CenterTagDataType implements CDef {
        /** $1: B2 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: E飛伝2 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: E飛伝Pro */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: ゆうパックプリントR(発送予定) */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: ゆうパックプリントR(発送履歴) */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: 発送確定データフォーマット */
        $6("6", "$6", emptyStrings())
        ,
        /** $7: 大口FDデータフォーマット */
        $7("7", "$7", emptyStrings())
        ;
        private static final Map<String, CenterTagDataType> _codeClsMap = new HashMap<String, CenterTagDataType>();
        private static final Map<String, CenterTagDataType> _nameClsMap = new HashMap<String, CenterTagDataType>();
        static {
            for (CenterTagDataType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterTagDataType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterTagDataType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagDataType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterTagDataType) { return OptionalThing.of((CenterTagDataType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagDataType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterTagDataType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterTagDataType) { return (CenterTagDataType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterTagDataType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterTagDataType> listAll() {
            return new ArrayList<CenterTagDataType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterTagDataType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterTagDataType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterTagDataType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterTagDataType> clsList = new ArrayList<CenterTagDataType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterTagDataType> groupOf(String groupName) {
            return new ArrayList<CenterTagDataType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送り状種別
     */
    public enum CenterTagType implements CDef {
        /** $1: 汎用荷札 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ヤマト宅急便(発払)荷札 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: ヤマト宅急便(コレクト)荷札 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 佐川荷札(WebAPI) */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: ゆうパック荷札 */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: ゆうパケット荷札 */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, CenterTagType> _codeClsMap = new HashMap<String, CenterTagType>();
        private static final Map<String, CenterTagType> _nameClsMap = new HashMap<String, CenterTagType>();
        static {
            for (CenterTagType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterTagType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterTagType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterTagType) { return OptionalThing.of((CenterTagType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterTagType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterTagType) { return (CenterTagType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterTagType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterTagType> listAll() {
            return new ArrayList<CenterTagType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterTagType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterTagType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterTagType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterTagType> clsList = new ArrayList<CenterTagType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterTagType> groupOf(String groupName) {
            return new ArrayList<CenterTagType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 送り状種別(代引時、2枚目以降)
     */
    public enum CenterTagTypeAfter implements CDef {
        /** $1: 汎用荷札 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: ヤマト宅急便(発払)荷札 */
        $2("2", "$2", emptyStrings())
        ,
        /** $3: ヤマト宅急便(コレクト)荷札 */
        $3("3", "$3", emptyStrings())
        ,
        /** $4: 佐川荷札(WebAPI) */
        $4("4", "$4", emptyStrings())
        ,
        /** $5: ゆうパック荷札 */
        $5("5", "$5", emptyStrings())
        ,
        /** $6: ゆうパケット荷札 */
        $6("6", "$6", emptyStrings())
        ;
        private static final Map<String, CenterTagTypeAfter> _codeClsMap = new HashMap<String, CenterTagTypeAfter>();
        private static final Map<String, CenterTagTypeAfter> _nameClsMap = new HashMap<String, CenterTagTypeAfter>();
        static {
            for (CenterTagTypeAfter value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterTagTypeAfter(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterTagTypeAfter; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagTypeAfter> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterTagTypeAfter) { return OptionalThing.of((CenterTagTypeAfter)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterTagTypeAfter> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterTagTypeAfter codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterTagTypeAfter) { return (CenterTagTypeAfter)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterTagTypeAfter nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterTagTypeAfter> listAll() {
            return new ArrayList<CenterTagTypeAfter>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterTagTypeAfter> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterTagTypeAfter." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterTagTypeAfter> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterTagTypeAfter> clsList = new ArrayList<CenterTagTypeAfter>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterTagTypeAfter> groupOf(String groupName) {
            return new ArrayList<CenterTagTypeAfter>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * WebAPI便種コード
     */
    public enum CenterApiBinsyuCode implements CDef {
        /** $000: 陸便 */
        $000("000", "$000", emptyStrings())
        ,
        /** $030: 航空便 */
        $030("030", "$030", emptyStrings())
        ,
        /** $140: クール冷蔵 */
        $140("140", "$140", emptyStrings())
        ,
        /** $141: クール冷蔵(航空便) */
        $141("141", "$141", emptyStrings())
        ,
        /** $150: クール冷凍 */
        $150("150", "$150", emptyStrings())
        ,
        /** $151: クール冷凍(航空便) */
        $151("151", "$151", emptyStrings())
        ;
        private static final Map<String, CenterApiBinsyuCode> _codeClsMap = new HashMap<String, CenterApiBinsyuCode>();
        private static final Map<String, CenterApiBinsyuCode> _nameClsMap = new HashMap<String, CenterApiBinsyuCode>();
        static {
            for (CenterApiBinsyuCode value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterApiBinsyuCode(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterApiBinsyuCode; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiBinsyuCode> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterApiBinsyuCode) { return OptionalThing.of((CenterApiBinsyuCode)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiBinsyuCode> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterApiBinsyuCode codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterApiBinsyuCode) { return (CenterApiBinsyuCode)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterApiBinsyuCode nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterApiBinsyuCode> listAll() {
            return new ArrayList<CenterApiBinsyuCode>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterApiBinsyuCode> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterApiBinsyuCode." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterApiBinsyuCode> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterApiBinsyuCode> clsList = new ArrayList<CenterApiBinsyuCode>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterApiBinsyuCode> groupOf(String groupName) {
            return new ArrayList<CenterApiBinsyuCode>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * WebAPI代引フラグ
     */
    public enum CenterApiDaibikiFlg implements CDef {
        /** $0: 通常の送り状を発行 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 代金引換の送り状を発行 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CenterApiDaibikiFlg> _codeClsMap = new HashMap<String, CenterApiDaibikiFlg>();
        private static final Map<String, CenterApiDaibikiFlg> _nameClsMap = new HashMap<String, CenterApiDaibikiFlg>();
        static {
            for (CenterApiDaibikiFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterApiDaibikiFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterApiDaibikiFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiDaibikiFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterApiDaibikiFlg) { return OptionalThing.of((CenterApiDaibikiFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiDaibikiFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterApiDaibikiFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterApiDaibikiFlg) { return (CenterApiDaibikiFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterApiDaibikiFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterApiDaibikiFlg> listAll() {
            return new ArrayList<CenterApiDaibikiFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterApiDaibikiFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterApiDaibikiFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterApiDaibikiFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterApiDaibikiFlg> clsList = new ArrayList<CenterApiDaibikiFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterApiDaibikiFlg> groupOf(String groupName) {
            return new ArrayList<CenterApiDaibikiFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * WebAPI代引支払方法区分
     */
    public enum CenterApiDaibikiType implements CDef {
        /** $0: なんでも決済 */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 現金 */
        $1("1", "$1", emptyStrings())
        ,
        /** $2: クレジットカード・デビットカード */
        $2("2", "$2", emptyStrings())
        ;
        private static final Map<String, CenterApiDaibikiType> _codeClsMap = new HashMap<String, CenterApiDaibikiType>();
        private static final Map<String, CenterApiDaibikiType> _nameClsMap = new HashMap<String, CenterApiDaibikiType>();
        static {
            for (CenterApiDaibikiType value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterApiDaibikiType(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterApiDaibikiType; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiDaibikiType> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterApiDaibikiType) { return OptionalThing.of((CenterApiDaibikiType)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiDaibikiType> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterApiDaibikiType codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterApiDaibikiType) { return (CenterApiDaibikiType)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterApiDaibikiType nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterApiDaibikiType> listAll() {
            return new ArrayList<CenterApiDaibikiType>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterApiDaibikiType> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterApiDaibikiType." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterApiDaibikiType> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterApiDaibikiType> clsList = new ArrayList<CenterApiDaibikiType>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterApiDaibikiType> groupOf(String groupName) {
            return new ArrayList<CenterApiDaibikiType>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * WebAPI営止フラグ
     */
    public enum CenterApiEidomeFlg implements CDef {
        /** $0: 営業所止めを行いません */
        $0("0", "$0", emptyStrings())
        ,
        /** $1: 営業所止めにします */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CenterApiEidomeFlg> _codeClsMap = new HashMap<String, CenterApiEidomeFlg>();
        private static final Map<String, CenterApiEidomeFlg> _nameClsMap = new HashMap<String, CenterApiEidomeFlg>();
        static {
            for (CenterApiEidomeFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterApiEidomeFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterApiEidomeFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiEidomeFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterApiEidomeFlg) { return OptionalThing.of((CenterApiEidomeFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiEidomeFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterApiEidomeFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterApiEidomeFlg) { return (CenterApiEidomeFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterApiEidomeFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterApiEidomeFlg> listAll() {
            return new ArrayList<CenterApiEidomeFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterApiEidomeFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterApiEidomeFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterApiEidomeFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterApiEidomeFlg> clsList = new ArrayList<CenterApiEidomeFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterApiEidomeFlg> groupOf(String groupName) {
            return new ArrayList<CenterApiEidomeFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * WebAPI重量コード
     */
    public enum CenterApiWeightCd implements CDef {
        /** $60: 2Kg(サイズ60) */
        $60("60", "$60", emptyStrings())
        ,
        /** $80: 5Kg(サイズ80) */
        $80("80", "$80", emptyStrings())
        ,
        /** $100: 10Kg(サイズ100) */
        $100("100", "$100", emptyStrings())
        ,
        /** $140: 20Kg(サイズ140) */
        $140("140", "$140", emptyStrings())
        ,
        /** $160: 30Kg(サイズ160) */
        $160("160", "$160", emptyStrings())
        ;
        private static final Map<String, CenterApiWeightCd> _codeClsMap = new HashMap<String, CenterApiWeightCd>();
        private static final Map<String, CenterApiWeightCd> _nameClsMap = new HashMap<String, CenterApiWeightCd>();
        static {
            for (CenterApiWeightCd value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterApiWeightCd(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterApiWeightCd; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiWeightCd> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterApiWeightCd) { return OptionalThing.of((CenterApiWeightCd)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterApiWeightCd> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterApiWeightCd codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterApiWeightCd) { return (CenterApiWeightCd)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterApiWeightCd nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterApiWeightCd> listAll() {
            return new ArrayList<CenterApiWeightCd>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterApiWeightCd> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterApiWeightCd." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterApiWeightCd> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterApiWeightCd> clsList = new ArrayList<CenterApiWeightCd>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterApiWeightCd> groupOf(String groupName) {
            return new ArrayList<CenterApiWeightCd>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 発行対象のみ表示
     */
    public enum CenterOutputTargetFlg implements CDef {
        /** $1: 発行対象のみ */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CenterOutputTargetFlg> _codeClsMap = new HashMap<String, CenterOutputTargetFlg>();
        private static final Map<String, CenterOutputTargetFlg> _nameClsMap = new HashMap<String, CenterOutputTargetFlg>();
        static {
            for (CenterOutputTargetFlg value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterOutputTargetFlg(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterOutputTargetFlg; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterOutputTargetFlg> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterOutputTargetFlg) { return OptionalThing.of((CenterOutputTargetFlg)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterOutputTargetFlg> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterOutputTargetFlg codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterOutputTargetFlg) { return (CenterOutputTargetFlg)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterOutputTargetFlg nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterOutputTargetFlg> listAll() {
            return new ArrayList<CenterOutputTargetFlg>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterOutputTargetFlg> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterOutputTargetFlg." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterOutputTargetFlg> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterOutputTargetFlg> clsList = new ArrayList<CenterOutputTargetFlg>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterOutputTargetFlg> groupOf(String groupName) {
            return new ArrayList<CenterOutputTargetFlg>(4);
        }

        @Override public String toString() { return code(); }
    }

    /**
     * 未発行のみ表示
     */
    public enum CenterPrintCondition implements CDef {
        /** $1: 未発行のみ表示 */
        $1("1", "$1", emptyStrings())
        ;
        private static final Map<String, CenterPrintCondition> _codeClsMap = new HashMap<String, CenterPrintCondition>();
        private static final Map<String, CenterPrintCondition> _nameClsMap = new HashMap<String, CenterPrintCondition>();
        static {
            for (CenterPrintCondition value : values()) {
                _codeClsMap.put(value.code().toLowerCase(), value);
                for (String sister : value.sisterSet()) { _codeClsMap.put(sister.toLowerCase(), value); }
                _nameClsMap.put(value.name().toLowerCase(), value);
            }
        }
        private String _code; private String _alias; private Set<String> _sisterSet;
        private CenterPrintCondition(String code, String alias, String[] sisters)
        { _code = code; _alias = alias; _sisterSet = Collections.unmodifiableSet(new LinkedHashSet<String>(Arrays.asList(sisters))); }
        public String code() { return _code; } public String alias() { return _alias; }
        public Set<String> sisterSet() { return _sisterSet; }
        public Map<String, Object> subItemMap() { return Collections.emptyMap(); }
        public ClassificationMeta meta() { return CDef.DefMeta.CenterPrintCondition; }

        public boolean inGroup(String groupName) {
            return false;
        }

        /**
         * Get the classification of the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns empty)
         * @return The optional classification corresponding to the code. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPrintCondition> of(Object code) {
            if (code == null) { return OptionalThing.ofNullable(null, () -> { throw new ClassificationNotFoundException("null code specified"); }); }
            if (code instanceof CenterPrintCondition) { return OptionalThing.of((CenterPrintCondition)code); }
            if (code instanceof OptionalThing<?>) { return of(((OptionalThing<?>)code).orElse(null)); }
            return OptionalThing.ofNullable(_codeClsMap.get(code.toString().toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification code: " + code);
            });
        }

        /**
         * Find the classification by the name. (CaseInsensitive)
         * @param name The string of name, which is case-insensitive. (NotNull)
         * @return The optional classification corresponding to the name. (NotNull, EmptyAllowed: if not found, returns empty)
         */
        public static OptionalThing<CenterPrintCondition> byName(String name) {
            if (name == null) { throw new IllegalArgumentException("The argument 'name' should not be null."); }
            return OptionalThing.ofNullable(_nameClsMap.get(name.toLowerCase()), () ->{
                throw new ClassificationNotFoundException("Unknown classification name: " + name);
            });
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use of(code).</span> <br>
         * Get the classification by the code. (CaseInsensitive)
         * @param code The value of code, which is case-insensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the code. (NullAllowed: if not found, returns null)
         */
        public static CenterPrintCondition codeOf(Object code) {
            if (code == null) { return null; }
            if (code instanceof CenterPrintCondition) { return (CenterPrintCondition)code; }
            return _codeClsMap.get(code.toString().toLowerCase());
        }

        /**
         * <span style="color: #AD4747; font-size: 120%">Old style so use byName(name).</span> <br>
         * Get the classification by the name (also called 'value' in ENUM world).
         * @param name The string of name, which is case-sensitive. (NullAllowed: if null, returns null)
         * @return The instance of the corresponding classification to the name. (NullAllowed: if not found, returns null)
         */
        public static CenterPrintCondition nameOf(String name) {
            if (name == null) { return null; }
            try { return valueOf(name); } catch (RuntimeException ignored) { return null; }
        }

        /**
         * Get the list of all classification elements. (returns new copied list)
         * @return The snapshot list of all classification elements. (NotNull)
         */
        public static List<CenterPrintCondition> listAll() {
            return new ArrayList<CenterPrintCondition>(Arrays.asList(values()));
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if not found, throws exception)
         */
        public static List<CenterPrintCondition> listByGroup(String groupName) {
            if (groupName == null) { throw new IllegalArgumentException("The argument 'groupName' should not be null."); }
            throw new ClassificationNotFoundException("Unknown classification group: CenterPrintCondition." + groupName);
        }

        /**
         * Get the list of classification elements corresponding to the specified codes. (returns new copied list) <br>
         * @param codeList The list of plain code, which is case-insensitive. (NotNull)
         * @return The snapshot list of classification elements in the code list. (NotNull, EmptyAllowed: when empty specified)
         */
        public static List<CenterPrintCondition> listOf(Collection<String> codeList) {
            if (codeList == null) { throw new IllegalArgumentException("The argument 'codeList' should not be null."); }
            List<CenterPrintCondition> clsList = new ArrayList<CenterPrintCondition>(codeList.size());
            for (String code : codeList) { clsList.add(of(code).get()); }
            return clsList;
        }

        /**
         * Get the list of classification elements in the specified group. (returns new copied list) <br>
         * @param groupName The string of group name, which is case-sensitive. (NullAllowed: if null, returns empty list)
         * @return The snapshot list of classification elements in the group. (NotNull, EmptyAllowed: if the group is not found)
         */
        public static List<CenterPrintCondition> groupOf(String groupName) {
            return new ArrayList<CenterPrintCondition>(4);
        }

        @Override public String toString() { return code(); }
    }

    public enum DefMeta implements ClassificationMeta {
        /** 処理区分マスタの処理区分CD */
        ProcessTypeCd
        ,
        /** 検品後納品明細出力対象 */
        AfterDelivSlipOutTgt
        ,
        /** 検品後荷札出力フラグ */
        AfterTagOutFlg
        ,
        /** 全数出庫フラグ */
        AllShippingFlg
        ,
        /** 引当不可フラグ表示 */
        AllcNgDisplay
        ,
        /** 引当禁止フラグ */
        AllcNgFlg
        ,
        /** 引当ソートキー */
        AllocSortKey
        ,
        /** 着店CDフォーマット */
        ArrivalStoreFormat
        ,
        /** 自動緊急フラグ設定フラグ */
        AutoEmgSetFlg
        ,
        /** 自動緊急フラグ判断対象 */
        AutoEmgSetTgt
        ,
        /** 自動印刷対象フラグ */
        AutoPrintTargetFlg
        ,
        /** 自動出庫指示フラグ */
        AutoShipInstFlg
        ,
        /** バーコード種別 */
        BarcodeType
        ,
        /** バッチ処理中フラグ */
        BatchProgressFlg
        ,
        /** 荷材選択スキップ */
        BoxSelectSkip
        ,
        /** キャンセルデータ表示 */
        CancelDataDisplay
        ,
        /** ケースピッキングフラグ */
        CasePicFlg
        ,
        /** センタ・荷主区分 */
        CenterClientCls
        ,
        /** センタ間移動フラグ */
        CenterTransitFlg
        ,
        /** 文字コード */
        CharacterCd
        ,
        /** 引当可能数0非表示 */
        ChargeQty0Display
        ,
        /** チェックディジット */
        CheckDigit
        ,
        /** 元着区分 */
        CodCls
        ,
        /** 元／着払／代引文字 */
        CodType
        ,
        /** 複数番号の有無 */
        CodeFlg
        ,
        /** 個別番号の種別 */
        CodeType
        ,
        /** 列型 */
        ColType
        ,
        /** コメント1有無 */
        CommentFlg
        ,
        /** 大口事業所フラグ */
        CompanyFlg
        ,
        /** クール区分 */
        CoolCls
        ,
        /** 保冷種別 */
        CoolType
        ,
        /** 赤黒区分 */
        CorrectType
        ,
        /** コミット区分 */
        DataInputCommitType
        ,
        /** 処理区分 */
        DataInputOperationType
        ,
        /** 処理区分 */
        DataInputProcessType
        ,
        /** 取込対象 */
        DataInputRange
        ,
        /** 取込種類 */
        DataInputType
        ,
        /** データ型 */
        DataType
        ,
        /** デフォルト */
        Default
        ,
        /** デフォルトフラグ */
        DefaultFlg
        ,
        /** 削除フラグ */
        DelFlg
        ,
        /** 削除データ表示 */
        DeleteDataDisplay
        ,
        /** 送付先一致フラグ */
        DelivMatchFlg
        ,
        /** 納品時間帯 */
        DelivTz
        ,
        /** 納品先フラグ */
        DeliveryFlg
        ,
        /** 預託先フラグ */
        DepositFlg
        ,
        /** 表示必須 */
        DisplayRequired
        ,
        /** 日付区分 */
        DtCls
        ,
        /** 編集可否 */
        Editable
        ,
        /** 緊急表示区分 */
        EmergencyDisplay
        ,
        /** 緊急フラグ */
        EmergencyFlg
        ,
        /** エラーフラグ */
        ErrorFlg
        ,
        /** エラー処理方法 */
        ErrorProcessMet
        ,
        /** 定点切れ */
        FixedPoint
        ,
        /** 強制確定フラグ */
        ForceFixedFlg
        ,
        /** 外貨フラグ */
        ForeignFlg
        ,
        /** ギフトフラグ */
        GiftFlg
        ,
        /** ギフト用納品書種別 */
        GiftStatementType
        ,
        /** HT文字認識使用フラグ */
        HtCharReadFlg
        ,
        /** 取込みフラグ */
        ImportFlg
        ,
        /** 終了したお知らせの表示 */
        InfoFlg
        ,
        /** 入出庫区分 */
        InoutType
        ,
        /** 入力区分 */
        InputType
        ,
        /** 検品フラグ */
        InspectionFlg
        ,
        /** 比較条件差異 */
        InventoryLocationProduct
        ,
        /** 送り状データ出力フラグ */
        InvoiceCreateFlg
        ,
        /** 項目型 */
        ItemType
        ,
        /** 最新フラグ */
        LastFlg
        ,
        /** 期限日管理フラグ */
        LimitDtManagFlg
        ,
        /** 期限日逆転防止フラグ */
        LimitDtReverseFlg
        ,
        /** 制限メッセージCD */
        LimitMessageCd
        ,
        /** 改行コード */
        LineFeedCd
        ,
        /** リスト発行フラグ */
        ListOutFlg
        ,
        /** 発行区分 */
        ListOutKbn
        ,
        /** リスト発行フラグ(一覧表示用) */
        ListOutFlgDisp
        ,
        /** 積込フラグ */
        LoadingFlg
        ,
        /** ロケーション種別 */
        LocationType
        ,
        /** ロックアウト */
        Lockout
        ,
        /** ログ明細ステータス */
        LogDtlStatus
        ,
        /** ログ明細種別 */
        LogDtlType
        ,
        /** ログステータス */
        LogStatus
        ,
        /** ロット管理フラグ */
        LotManagFlg
        ,
        /** ロット逆転防止フラグ */
        LotReverseFlg
        ,
        /** 入庫No.マージ区分 */
        MergeCls
        ,
        /** 名寄せ有無 */
        MergeFlg
        ,
        /** 属性 */
        MessageType
        ,
        /** 混載フラグ */
        MixedFlg
        ,
        /** 在庫移動指示ステータス */
        MoveInstStatus
        ,
        /** マルチピック計算区分 */
        MultiPicCls
        ,
        /** マルチピック計算フラグ */
        MultiPicFlg
        ,
        /** 必須 */
        Necessary
        ,
        /** 未出庫全件表示区分 */
        NoAllcDisplayFlg
        ,
        /** 未確定のみ表示 */
        NoConfirmedFlg
        ,
        /** 下積み厳禁区分 */
        NoStockCls
        ,
        /** 欠品無のみ表示 */
        NoStockOutFlg
        ,
        /** 逆さま厳禁区分 */
        NoUpsideDownCls
        ,
        /** 未完了のみ表示 */
        NotCompletedFlg
        ,
        /** ワンタイムフラグ */
        OnetimeFlg
        ,
        /** HT/SD過入荷可フラグ */
        OverStoreNumFlg
        ,
        /** 梱包計算処理区分 */
        PackingCalCls
        ,
        /** 梱包方法 */
        PackingProcessCls
        ,
        /** 個数口表示フラグ */
        PackingShowFlg
        ,
        /** 梱包ステータス */
        PackingStatus
        ,
        /** パスワードリセット */
        PasswordReset
        ,
        /** HT/SD過去日入力可フラグ */
        PastStoreDtFlg
        ,
        /** 削除 */
        PhysicalDelete
        ,
        /** ピッキング方法 */
        PicCls
        ,
        /** 最適ピック提案ブレイクキー */
        PicMthdRcmdBreakKey
        ,
        /** 最適ピック提案フラグ */
        PicMthdRcmdFlg
        ,
        /** 最適ピックリスト出力フラグ */
        PicMthdRcmdListOut
        ,
        /** 出庫フラグ */
        PickingFlg
        ,
        /** ピックロケフラグ */
        PickingLocationFlg
        ,
        /** 出庫ステータス */
        PickingStatus
        ,
        /** ピッキング種別 */
        PickingType
        ,
        /** 郵便種別 */
        PostType
        ,
        /** 印刷データタイプ */
        PrintDataType
        ,
        /** エラーのみ */
        PrintErrorFlg
        ,
        /** 印刷キューステータス */
        PrintQueueStatus
        ,
        /** 印刷結果区分 */
        PrintResultClass
        ,
        /** 印刷サービスステータス */
        PrintServiceStatus
        ,
        /** 印刷ステータス */
        PrintStatus
        ,
        /** 再印刷有無 */
        PrintedFlg
        ,
        /** 優先フラグ */
        PriorityFlg
        ,
        /** 商品ラベルソースCDバーコード種別 */
        ProductLabelJanBarcode
        ,
        /** 商品ラベル出力単位 */
        ProductLabelOutUnit
        ,
        /** 商品ラベル商品CDバーコード種別 */
        ProductLabelProdBarcode
        ,
        /** 商品毎別梱包 */
        ProductPartPacking
        ,
        /** 商品種別コード */
        ProductTypeCode
        ,
        /** 0非表示 */
        Qty0Display
        ,
        /** 変更理由 */
        ReasonType
        ,
        /** 入荷納品ステータス */
        ReceiveDeliveryStatus
        ,
        /** 入荷フラグ */
        ReceiveFlg
        ,
        /** 入荷ステータス */
        ReceiveStatus
        ,
        /** 補充ロケ割付区分 */
        ReplenishAllocCls
        ,
        /** 補充商品CD未設定 */
        ReplenishProductCdUnset
        ,
        /** 補充点検索区分 */
        ReplenishSearchCls
        ,
        /** 補充単位区分 */
        ReplenishUnitCls
        ,
        /** 項目型 */
        ReportLayoutItemType
        ,
        /** 補充種別 */
        RestockType
        ,
        /** 実績入力後入庫/商品ラベル出力 */
        ResultAfterProductLabel
        ,
        /** 期限日出荷制限フラグ */
        ReverseValidFlg
        ,
        /** 選択 */
        Select
        ,
        /** 印刷サービスステータス */
        SelectPrintServiceStatus
        ,
        /** 処理区分 */
        SerialOperationType
        ,
        /** ターゲットウインドウ */
        TargetWindow
        ,
        /** 決済種別 */
        SettlementType
        ,
        /** 単行出荷検品荷札/納品明細出力区分 */
        SglRowInspAfterOutCls
        ,
        /** 単行ピックフラグ */
        SglRowPicFlg
        ,
        /** 部単位印刷要否 */
        SheetCollate
        ,
        /** 出荷フラグ */
        ShippingFlg
        ,
        /** 出荷ステータス */
        ShippingStatus
        ,
        /** 出荷停止フラグ */
        ShippingStopFlg
        ,
        /** 欠品表示区分 */
        ShortStockDisplay
        ,
        /** 出荷検品区分 */
        ShpCheckCls
        ,
        /** 未検品表示区分 */
        ShpCheckDisplay
        ,
        /** 送り状種別 */
        SlipType
        ,
        /** 操作音再生フラグ */
        SoundPlayFlg
        ,
        /** 在庫調整フラグ */
        StockAdjustFlg
        ,
        /** 在庫表示内容 */
        StockDisplayFld
        ,
        /** 在庫有のみフラグ */
        StockExistOnlyFlg
        ,
        /** 在庫調整フラグ */
        StockMoveFlg
        ,
        /** 在庫数 0非表示 */
        StockNum0Display
        ,
        /** 欠品時引当区分 */
        StockOutAllocCls
        ,
        /** 欠品時自動出庫指示フラグ */
        StockOutAutoInstFlg
        ,
        /** 欠品フラグ */
        StockOutFlg
        ,
        /** 欠品時出庫指示取消フラグ */
        StockOutInstCxlFlg
        ,
        /** 欠品時出荷指示分離フラグ */
        StockOutInstSplitFlg
        ,
        /** 在庫数表示 */
        StockQtyDisplay
        ,
        /** 棚卸データ有 */
        StockTakingInput
        ,
        /** 在庫対象 */
        StockTarget
        ,
        /** 入庫日管理フラグ */
        StoreDtFlg
        ,
        /** 格納フラグ */
        StoreFlg
        ,
        /** 入庫No.分割表示 */
        StoreNoDivideDisplay
        ,
        /** 入庫No.管理フラグ */
        StoreNoFlg
        ,
        /** 入庫No.マージフラグ */
        StoreNoMergeFlg
        ,
        /** システムログステータス */
        SystemLogStatus
        ,
        /** システムログ種別 */
        SystemLogType
        ,
        /** システム種別 */
        SystemType
        ,
        /** 荷札納品書在中出力フラグ */
        TagDeliveryOutFlg
        ,
        /** 作業日/出荷日/納品日区分 */
        TakingShippingDtFlg
        ,
        /** 作業日/出荷日区分 */
        TakingShippingFlg
        ,
        /** 表示位置 */
        TextAlign
        ,
        /** トータルピックフラグ */
        TotalPicFlg
        ,
        /** 追跡番号採番単位 */
        TrackingNumberingUnit
        ,
        /** 積送中在庫のみ表示 */
        TransitDisplay
        ,
        /** アンマッチ有 */
        Unmatch
        ,
        /** 修正コード */
        UpdCd
        ,
        /** 更新区分 */
        UpdType
        ,
        /** 更新可否 */
        Updatable
        ,
        /** アップロードテーブル名 */
        UploadTableNm
        ,
        /** HT/SDケースピック使用フラグ */
        UseHtShipFlg
        ,
        /** ユーザ編集可否 */
        UserEditable
        ,
        /** 仕入先フラグ */
        VendorFlg
        ,
        /** 表示可否 */
        Visible
        ,
        /** 処理済フラグ */
        WorkFlg
        ,
        /** 作業メッセージ有無 */
        WorkMessageFlg
        ,
        /** ヤマト配達時間帯 */
        YamatoDelivTz
        ,
        /** ゆうパック配達時間帯 */
        YupackDelivTz
        ,
        /** 郵便番号フラグ */
        ZipFlg
        ,
        /** 実績入力後入庫/商品ラベル出力対象 */
        ResultAfterProductTarget
        ,
        /** コピー対象テーブル */
        CopyTargetTable
        ,
        /** 検品ラベル出力 */
        InspectionLabelOutFlg
        ,
        /** 小数管理商品梱包単位 */
        DecimalProductPacking
        ,
        /** 小数有無フラグ */
        DecimalExistFlg
        ,
        /** ケースピッキング対象 */
        CasePickFlg
        ,
        /** 緊急補充ゾーン補充荷姿 */
        EmReplenishShapeFlg
        ,
        /** 作業ステータス */
        WorkStatus
        ,
        /** 作業実績出力フラグ */
        WorkLogOutFlg
        ,
        /** 権限制御区分 */
        RoleControlClass
        ,
        /** Bill of Lading出力フラグ */
        BolOutFlg
        ,
        /** Bill of Lading出力対象フラグ */
        BolOutputTargetFlg
        ,
        /** Payment Term */
        PaymentTerm
        ,
        /** CES連携フラグ */
        CesIntegrationFlg
        ,
        /** 納品明細書自動発行フラグ */
        PackingSlipAutoOutputFlg
        ,
        /** Freight Class */
        FreightCls
        ,
        /** Saturday Delivery フラグCD */
        SatDeliveryFlg
        ,
        /** Residential Delivery フラグCD */
        ResidentialDeliveryFlg
        ,
        /** Collect On Delivery フラグCD */
        CodFlg
        ,
        /** Signature Required フラグCD */
        SignatureRequiredFlg
        ,
        /** Signature ReleaseフラグCD */
        SignatureReleaseFlg
        ,
        /** Call Before Delivery フラグCD */
        CallBeforeDeliveryFlg
        ,
        /** Freezable Protection フラグCD */
        FreezableProtectionFlg
        ,
        /** Guaranteed Plus フラグCD */
        GuaranteedPlusFlg
        ,
        /** Residential Pickup フラグCD */
        ResidentialPickupFlg
        ,
        /** Do Not Stack Pallets フラグCD */
        DoNotStackStackFlg
        ,
        /** Limited Access Delivery フラグCD */
        LimitedAccessDeliveryFlg
        ,
        /** Limited Access Pickup フラグCD */
        LimitedAccessPickupFlg
        ,
        /** Over-Sized/Extreme Length フラグCD */
        OverSizedFlg
        ,
        /** Poison フラグCD */
        PoisonFlg
        ,
        /** Food フラグCD */
        FoogFlg
        ,
        /** Liftgate at delivery フラグCD (Prepaid) */
        LiftgateDeliveryPrepaidFlg
        ,
        /** Liftgate at delivery フラグCD (Collect) */
        LiftgateDeliveryCollectFlg
        ,
        /** Liftgate at pickup フラグCD (Prepaid) */
        LiftgatePickupPrepaidFlg
        ,
        /** Liftgate at pickup フラグCD (Collect) */
        LiftgatePickupCollectFlg
        ,
        /** Inside Delivery フラグCD (Prepaid) */
        InsideDeliveryPrepaidFlg
        ,
        /** Inside Delivery フラグCD (Collect) */
        InsideDeliveryCollectFlg
        ,
        /** Inside Pickup フラグCD (Prepaid) */
        InsidePickupPrepaidFlg
        ,
        /** Inside Pickup フラグCD (Collect) */
        InsidePickupCollectFlg
        ,
        /** 提案ピッキング方法 */
        RcmdPickingCls
        ,
        /** 単行ピッキング対象 */
        SglRowPicTarget
        ,
        /** ケースピッキング対象 */
        CasePicTarget
        ,
        /** 出退勤・休憩 */
        AttendanceLeavingRest
        ,
        /** 郵便番号種別 */
        UploadZipType
        ,
        /** FW */
        FwType
        ,
        /** MCA */
        McaType
        ,
        /** 得意先フラグ */
        AccountFlg
        ,
        /** アラーム区分 */
        AlarmReasonCls
        ,
        /** アラーム種別 */
        AlarmType
        ,
        /** エリア */
        AreaCls
        ,
        /** 仕分状態 */
        AssortStatus
        ,
        /** 拠点区分 */
        BaseCls
        ,
        /** 荷材 */
        BoxType
        ,
        /** 運送業者 */
        CarrierType
        ,
        /** 運送会社区分 */
        CarrierTypeCd
        ,
        /** ケース区分 */
        CaseTypeCd
        ,
        /** 締め日 */
        ClosingDt
        ,
        /** 完了非表示 */
        CompletedHidden
        ,
        /** 出力条件 */
        Condition
        ,
        /** 建設支店 */
        Constract
        ,
        /** ケース／バラ区分 */
        CsPsType
        ,
        /** 在庫区分 */
        DefaultStockType
        ,
        /** 拠点送り区分(出荷元) */
        DelivCenterFrom
        ,
        /** 拠点送り区分(出荷先) */
        DelivCenterTo
        ,
        /** 配達指定有無 */
        DeliveryDtUnspecified
        ,
        /** 配達時間帯 */
        DeliveryTimeZone
        ,
        /** 配送種別送信対象区分 */
        DeliveryTypeSendCls
        ,
        /** 預り品 */
        DepositItemFlg
        ,
        /** 取引区分 */
        DepositType
        ,
        /** 差異 */
        DiffCls
        ,
        /** 直送区分 */
        DirectDeliveryTypeCd
        ,
        /** EC受注 */
        EcOrder
        ,
        /** EC区分 */
        EcType
        ,
        /** 実行ステータス */
        ExecuteStatus
        ,
        /** 手数料 */
        Fee
        ,
        /** フロア */
        Floor
        ,
        /** フロアCD */
        FloorCd
        ,
        /** フロア完結 */
        FloorEndFlg
        ,
        /** フロア区分(保管場所区分) */
        FloorTypeCd
        ,
        /** 引き渡しステータス */
        HandOverStatus
        ,
        /** 取扱方法 */
        HandlingType
        ,
        /** 重量フラグ */
        HeavyItemFlg
        ,
        /** 重量取扱フラグ */
        HeavyItemHadlingFlg
        ,
        /** 品目グループ */
        HinmokuGroupCd
        ,
        /** 休日 */
        HolidayFlg
        ,
        /** 個体管理廃止区分 */
        IdManagAbolitionTypeCd
        ,
        /** 保険品フラグ */
        InsuranceFlg
        ,
        /** 棚卸データ状況 */
        InventoryDataStatus
        ,
        /** 棚卸差異 */
        InventoryDiffCls
        ,
        /** 棚卸入力有 */
        InventoryInputCls
        ,
        /** 棚卸リスト発行区分 */
        InventoryListOutCls
        ,
        /** 棚卸帳票発行区分 */
        InventoryListType
        ,
        /** 個体管理区分 */
        ItManagType
        ,
        /** 日本電産 */
        ItemDensan
        ,
        /** 大物フラグ */
        LargeItemFlg
        ,
        /** 期限日割れ区分 */
        LimitDtSplitTypeCd
        ,
        /** 期限日不一致区分 */
        LimitDtUnmatchTypeCd
        ,
        /** 物流注意区分 */
        LogiAttentionTypeCd
        ,
        /** 物流特殊区分 */
        LogiSpecialTypeCd
        ,
        /** 物流重量フラグ */
        LogiWeightFlg
        ,
        /** ロット割れ区分 */
        LotSplitTypeCd
        ,
        /** ロット不一致区分 */
        LotUnmatchTypeCd
        ,
        /** 最大格納数商品荷姿 */
        MaxStoreShape
        ,
        /** 医療用管理フラグ */
        MedicalManagFlg
        ,
        /** 移動方法 */
        MoveDirection
        ,
        /** 祝日振替業者 */
        NationalHolidayCarrier
        ,
        /** 祝日 */
        NationalHolidayFlg
        ,
        /** 荷揃処理ID(共通) */
        NizoroeProcessId
        ,
        /** 荷揃処理ID(WMS) */
        NizoroeProcessIdWms
        ,
        /** 荷揃処理時間 */
        NizoroeTime
        ,
        /** 荷揃区分(共通) */
        NizoroeType
        ,
        /** 荷揃区分(WMS) */
        NizoroeTypeWms
        ,
        /** 沖縄航空便不可フラグ */
        NoOkinawaFlightFlg
        ,
        /** OCR日付形式 */
        OcrDateFormat
        ,
        /** 出力帳票種別 */
        OutputListType
        ,
        /** 出力月 */
        OutputMonth
        ,
        /** 出力状況 */
        OutputStatus
        ,
        /** 決済区分 */
        PaymentTypeCd
        ,
        /** ピッキングパターンCD */
        PickingPatternCd
        ,
        /** 都道府県 */
        Prefecture
        ,
        /** 差異金額非表示 */
        PriceDiffHidden
        ,
        /** 製造日管理フラグ */
        ProdDtManagFlg
        ,
        /** 製造日割れ区分 */
        ProdDtSplitTypeCd
        ,
        /** 製造日不一致区分 */
        ProdDtUnmatchTypeCd
        ,
        /** 品種変換区分 */
        ProductCategoryConvertCls
        ,
        /** 品種区分変換 */
        ProductCategoryPlant
        ,
        /** 品種区分 */
        ProductCategoryType
        ,
        /** 商品別入庫ステータス */
        ProductStoreStatus
        ,
        /** 商品単位 */
        ProductUnitCls
        ,
        /** 入荷発生事由 */
        ReceiveReason
        ,
        /** 入荷発生事由変換 */
        ReceiveReasonConvert
        ,
        /** 入荷発生事由_預り品入荷 */
        ReceiveReasonDepositReceive
        ,
        /** 入荷ステータス_未入荷 */
        ReceiveStatus01
        ,
        /** 推奨ロケーション区分 */
        RecommendLocationTypeCd
        ,
        /** 関連商品 */
        RelatedProducts
        ,
        /** 残数有フラグ */
        RemainFlg
        ,
        /** 補充荷姿 */
        ReplenishShape
        ,
        /** サンプル区分 */
        SampleCls
        ,
        /** 検索基準日 */
        SearchReferenceDt
        ,
        /** シリアル管理フラグ */
        SerialManagFlg
        ,
        /** 荷姿グループ区分 */
        ShapeGrpTypeCd
        ,
        /** 共有商品 */
        SharedProductTypeCd
        ,
        /** 出荷検品済非表示 */
        ShippingInspectionHidden
        ,
        /** 出荷検品ステータス */
        ShippingInspectionStatus
        ,
        /** 出荷処理区分 */
        ShippingProcessType
        ,
        /** 出荷進捗ステータス */
        ShippingProgress
        ,
        /** 出荷発生事由 */
        ShippingReason
        ,
        /** 出荷発生事由変換 */
        ShippingReasonConvert
        ,
        /** 出荷帳票発行区分 */
        ShippingSlipType
        ,
        /** 出荷区分 */
        ShippingType
        ,
        /** 出荷作業区分 */
        ShippingWorkType
        ,
        /** 伝票種別 */
        SlipType2
        ,
        /** 予備区分 */
        SpareTypeCd
        ,
        /** 指定足数 */
        SpecifiedNumOfShoes
        ,
        /** 分納区分 */
        SplitDeliveryTypeCd
        ,
        /** 在庫差異 */
        StockDifference
        ,
        /** 在庫表示内容 */
        StockDisplayType
        ,
        /** 他ロケ在庫ありを表示 */
        StockExist
        ,
        /** 在庫処理区分 */
        StockProcessType
        ,
        /** フロア基準在庫／ロケ基準在庫 */
        StockRefCls
        ,
        /** 棚卸進捗状況 */
        StockTakingStatus
        ,
        /** 在庫数０表示 */
        StockZeroDisplay
        ,
        /** 用品 */
        SuppliesVarietyFlg
        ,
        /** 対象拠点 */
        TargetBase
        ,
        /** 対象商品 */
        TargetItemCd
        ,
        /** 対象戸口契約先 */
        TargetKoguchiCd
        ,
        /** 対象販売組織 */
        TargetSalesCd
        ,
        /** 単位区分 */
        UnitCls
        ,
        /** 緊急出荷時間帯 */
        UrgentShippingTimeZone
        ,
        /** 作業区分 */
        WorkType
        ,
        /** 入荷ラベル使用フラグ */
        ReceiveLabelFlg
        ,
        /** 入荷日差異有 */
        ReceiveDtUnmatchFlg
        ,
        /** 発行状況 */
        PrintFlg
        ,
        /** 入荷残数有 */
        ReceiveRemainFlg
        ,
        /** ピッキング済非表示 */
        ShippingPickedHidden
        ,
        /** 運送業者データ出力フラグ */
        CarrierDataOutFlg
        ,
        /** 梱包明細出力フラグ */
        PllOutFlg
        ,
        /** 所有者 */
        DepositorCls
        ,
        /** 入荷予定リスト出力フラグ */
        RplOutFlg
        ,
        /** 実績送信フラグ */
        RecordSendFlg
        ,
        /** 引き渡し済非表示 */
        HandOverHidden
        ,
        /** 外部倉庫フラグ */
        ExternalWarehouseFlg
        ,
        /** 通常品プラント */
        StandardPlantCls
        ,
        /** 大物取扱フラグ */
        LargeItemHadlingFlg
        ,
        /** 休日振替運送業者フラグ */
        HolidayCarrierFlg
        ,
        /** 沖縄航空便振替フラグ */
        OkinawaFlightFlg
        ,
        /** 拠点デフォルト運送業者フラグ */
        BaseDefaultCarrierFlg
        ,
        /** 受渡表区分 */
        SlipTypeCd
        ,
        /** 正規フラグ */
        ProperFlg
        ,
        /** 運送業者引き渡し票出力フラ */
        CdlOutFlg
        ,
        /** エラー件数 */
        ErrorNum
        ,
        /** 一次ピッキングリスト */
        CenterPicListCls1
        ,
        /** 二次ピッキングリスト */
        CenterPicListCls2
        ,
        /** 送り状・荷札 */
        CenterPicListCls3
        ,
        /** 佐川配達時間帯 */
        CenterSagawaDelivTz
        ,
        /** 便種(商品) */
        CenterTransportTypeItem
        ,
        /** 荷姿コード */
        CenterSlipShapeCd
        ,
        /** 便種(スピードで選択) */
        CenterTransportTypeSpeed
        ,
        /** 指定シール */
        CenterSealType
        ,
        /** データ種別 */
        CenterTagClass
        ,
        /** 送り状データ種別 */
        CenterTagDataType
        ,
        /** 送り状種別 */
        CenterTagType
        ,
        /** 送り状種別(代引時、2枚目以降) */
        CenterTagTypeAfter
        ,
        /** WebAPI便種コード */
        CenterApiBinsyuCode
        ,
        /** WebAPI代引フラグ */
        CenterApiDaibikiFlg
        ,
        /** WebAPI代引支払方法区分 */
        CenterApiDaibikiType
        ,
        /** WebAPI営止フラグ */
        CenterApiEidomeFlg
        ,
        /** WebAPI重量コード */
        CenterApiWeightCd
        ,
        /** 発行対象のみ表示 */
        CenterOutputTargetFlg
        ,
        /** 未発行のみ表示 */
        CenterPrintCondition
        ;
        public String classificationName() {
            return name(); // same as definition name
        }

        public OptionalThing<? extends Classification> of(Object code) {
            if (ProcessTypeCd.name().equals(name())) { return CDef.ProcessTypeCd.of(code); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return CDef.AfterDelivSlipOutTgt.of(code); }
            if (AfterTagOutFlg.name().equals(name())) { return CDef.AfterTagOutFlg.of(code); }
            if (AllShippingFlg.name().equals(name())) { return CDef.AllShippingFlg.of(code); }
            if (AllcNgDisplay.name().equals(name())) { return CDef.AllcNgDisplay.of(code); }
            if (AllcNgFlg.name().equals(name())) { return CDef.AllcNgFlg.of(code); }
            if (AllocSortKey.name().equals(name())) { return CDef.AllocSortKey.of(code); }
            if (ArrivalStoreFormat.name().equals(name())) { return CDef.ArrivalStoreFormat.of(code); }
            if (AutoEmgSetFlg.name().equals(name())) { return CDef.AutoEmgSetFlg.of(code); }
            if (AutoEmgSetTgt.name().equals(name())) { return CDef.AutoEmgSetTgt.of(code); }
            if (AutoPrintTargetFlg.name().equals(name())) { return CDef.AutoPrintTargetFlg.of(code); }
            if (AutoShipInstFlg.name().equals(name())) { return CDef.AutoShipInstFlg.of(code); }
            if (BarcodeType.name().equals(name())) { return CDef.BarcodeType.of(code); }
            if (BatchProgressFlg.name().equals(name())) { return CDef.BatchProgressFlg.of(code); }
            if (BoxSelectSkip.name().equals(name())) { return CDef.BoxSelectSkip.of(code); }
            if (CancelDataDisplay.name().equals(name())) { return CDef.CancelDataDisplay.of(code); }
            if (CasePicFlg.name().equals(name())) { return CDef.CasePicFlg.of(code); }
            if (CenterClientCls.name().equals(name())) { return CDef.CenterClientCls.of(code); }
            if (CenterTransitFlg.name().equals(name())) { return CDef.CenterTransitFlg.of(code); }
            if (CharacterCd.name().equals(name())) { return CDef.CharacterCd.of(code); }
            if (ChargeQty0Display.name().equals(name())) { return CDef.ChargeQty0Display.of(code); }
            if (CheckDigit.name().equals(name())) { return CDef.CheckDigit.of(code); }
            if (CodCls.name().equals(name())) { return CDef.CodCls.of(code); }
            if (CodType.name().equals(name())) { return CDef.CodType.of(code); }
            if (CodeFlg.name().equals(name())) { return CDef.CodeFlg.of(code); }
            if (CodeType.name().equals(name())) { return CDef.CodeType.of(code); }
            if (ColType.name().equals(name())) { return CDef.ColType.of(code); }
            if (CommentFlg.name().equals(name())) { return CDef.CommentFlg.of(code); }
            if (CompanyFlg.name().equals(name())) { return CDef.CompanyFlg.of(code); }
            if (CoolCls.name().equals(name())) { return CDef.CoolCls.of(code); }
            if (CoolType.name().equals(name())) { return CDef.CoolType.of(code); }
            if (CorrectType.name().equals(name())) { return CDef.CorrectType.of(code); }
            if (DataInputCommitType.name().equals(name())) { return CDef.DataInputCommitType.of(code); }
            if (DataInputOperationType.name().equals(name())) { return CDef.DataInputOperationType.of(code); }
            if (DataInputProcessType.name().equals(name())) { return CDef.DataInputProcessType.of(code); }
            if (DataInputRange.name().equals(name())) { return CDef.DataInputRange.of(code); }
            if (DataInputType.name().equals(name())) { return CDef.DataInputType.of(code); }
            if (DataType.name().equals(name())) { return CDef.DataType.of(code); }
            if (Default.name().equals(name())) { return CDef.Default.of(code); }
            if (DefaultFlg.name().equals(name())) { return CDef.DefaultFlg.of(code); }
            if (DelFlg.name().equals(name())) { return CDef.DelFlg.of(code); }
            if (DeleteDataDisplay.name().equals(name())) { return CDef.DeleteDataDisplay.of(code); }
            if (DelivMatchFlg.name().equals(name())) { return CDef.DelivMatchFlg.of(code); }
            if (DelivTz.name().equals(name())) { return CDef.DelivTz.of(code); }
            if (DeliveryFlg.name().equals(name())) { return CDef.DeliveryFlg.of(code); }
            if (DepositFlg.name().equals(name())) { return CDef.DepositFlg.of(code); }
            if (DisplayRequired.name().equals(name())) { return CDef.DisplayRequired.of(code); }
            if (DtCls.name().equals(name())) { return CDef.DtCls.of(code); }
            if (Editable.name().equals(name())) { return CDef.Editable.of(code); }
            if (EmergencyDisplay.name().equals(name())) { return CDef.EmergencyDisplay.of(code); }
            if (EmergencyFlg.name().equals(name())) { return CDef.EmergencyFlg.of(code); }
            if (ErrorFlg.name().equals(name())) { return CDef.ErrorFlg.of(code); }
            if (ErrorProcessMet.name().equals(name())) { return CDef.ErrorProcessMet.of(code); }
            if (FixedPoint.name().equals(name())) { return CDef.FixedPoint.of(code); }
            if (ForceFixedFlg.name().equals(name())) { return CDef.ForceFixedFlg.of(code); }
            if (ForeignFlg.name().equals(name())) { return CDef.ForeignFlg.of(code); }
            if (GiftFlg.name().equals(name())) { return CDef.GiftFlg.of(code); }
            if (GiftStatementType.name().equals(name())) { return CDef.GiftStatementType.of(code); }
            if (HtCharReadFlg.name().equals(name())) { return CDef.HtCharReadFlg.of(code); }
            if (ImportFlg.name().equals(name())) { return CDef.ImportFlg.of(code); }
            if (InfoFlg.name().equals(name())) { return CDef.InfoFlg.of(code); }
            if (InoutType.name().equals(name())) { return CDef.InoutType.of(code); }
            if (InputType.name().equals(name())) { return CDef.InputType.of(code); }
            if (InspectionFlg.name().equals(name())) { return CDef.InspectionFlg.of(code); }
            if (InventoryLocationProduct.name().equals(name())) { return CDef.InventoryLocationProduct.of(code); }
            if (InvoiceCreateFlg.name().equals(name())) { return CDef.InvoiceCreateFlg.of(code); }
            if (ItemType.name().equals(name())) { return CDef.ItemType.of(code); }
            if (LastFlg.name().equals(name())) { return CDef.LastFlg.of(code); }
            if (LimitDtManagFlg.name().equals(name())) { return CDef.LimitDtManagFlg.of(code); }
            if (LimitDtReverseFlg.name().equals(name())) { return CDef.LimitDtReverseFlg.of(code); }
            if (LimitMessageCd.name().equals(name())) { return CDef.LimitMessageCd.of(code); }
            if (LineFeedCd.name().equals(name())) { return CDef.LineFeedCd.of(code); }
            if (ListOutFlg.name().equals(name())) { return CDef.ListOutFlg.of(code); }
            if (ListOutKbn.name().equals(name())) { return CDef.ListOutKbn.of(code); }
            if (ListOutFlgDisp.name().equals(name())) { return CDef.ListOutFlgDisp.of(code); }
            if (LoadingFlg.name().equals(name())) { return CDef.LoadingFlg.of(code); }
            if (LocationType.name().equals(name())) { return CDef.LocationType.of(code); }
            if (Lockout.name().equals(name())) { return CDef.Lockout.of(code); }
            if (LogDtlStatus.name().equals(name())) { return CDef.LogDtlStatus.of(code); }
            if (LogDtlType.name().equals(name())) { return CDef.LogDtlType.of(code); }
            if (LogStatus.name().equals(name())) { return CDef.LogStatus.of(code); }
            if (LotManagFlg.name().equals(name())) { return CDef.LotManagFlg.of(code); }
            if (LotReverseFlg.name().equals(name())) { return CDef.LotReverseFlg.of(code); }
            if (MergeCls.name().equals(name())) { return CDef.MergeCls.of(code); }
            if (MergeFlg.name().equals(name())) { return CDef.MergeFlg.of(code); }
            if (MessageType.name().equals(name())) { return CDef.MessageType.of(code); }
            if (MixedFlg.name().equals(name())) { return CDef.MixedFlg.of(code); }
            if (MoveInstStatus.name().equals(name())) { return CDef.MoveInstStatus.of(code); }
            if (MultiPicCls.name().equals(name())) { return CDef.MultiPicCls.of(code); }
            if (MultiPicFlg.name().equals(name())) { return CDef.MultiPicFlg.of(code); }
            if (Necessary.name().equals(name())) { return CDef.Necessary.of(code); }
            if (NoAllcDisplayFlg.name().equals(name())) { return CDef.NoAllcDisplayFlg.of(code); }
            if (NoConfirmedFlg.name().equals(name())) { return CDef.NoConfirmedFlg.of(code); }
            if (NoStockCls.name().equals(name())) { return CDef.NoStockCls.of(code); }
            if (NoStockOutFlg.name().equals(name())) { return CDef.NoStockOutFlg.of(code); }
            if (NoUpsideDownCls.name().equals(name())) { return CDef.NoUpsideDownCls.of(code); }
            if (NotCompletedFlg.name().equals(name())) { return CDef.NotCompletedFlg.of(code); }
            if (OnetimeFlg.name().equals(name())) { return CDef.OnetimeFlg.of(code); }
            if (OverStoreNumFlg.name().equals(name())) { return CDef.OverStoreNumFlg.of(code); }
            if (PackingCalCls.name().equals(name())) { return CDef.PackingCalCls.of(code); }
            if (PackingProcessCls.name().equals(name())) { return CDef.PackingProcessCls.of(code); }
            if (PackingShowFlg.name().equals(name())) { return CDef.PackingShowFlg.of(code); }
            if (PackingStatus.name().equals(name())) { return CDef.PackingStatus.of(code); }
            if (PasswordReset.name().equals(name())) { return CDef.PasswordReset.of(code); }
            if (PastStoreDtFlg.name().equals(name())) { return CDef.PastStoreDtFlg.of(code); }
            if (PhysicalDelete.name().equals(name())) { return CDef.PhysicalDelete.of(code); }
            if (PicCls.name().equals(name())) { return CDef.PicCls.of(code); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return CDef.PicMthdRcmdBreakKey.of(code); }
            if (PicMthdRcmdFlg.name().equals(name())) { return CDef.PicMthdRcmdFlg.of(code); }
            if (PicMthdRcmdListOut.name().equals(name())) { return CDef.PicMthdRcmdListOut.of(code); }
            if (PickingFlg.name().equals(name())) { return CDef.PickingFlg.of(code); }
            if (PickingLocationFlg.name().equals(name())) { return CDef.PickingLocationFlg.of(code); }
            if (PickingStatus.name().equals(name())) { return CDef.PickingStatus.of(code); }
            if (PickingType.name().equals(name())) { return CDef.PickingType.of(code); }
            if (PostType.name().equals(name())) { return CDef.PostType.of(code); }
            if (PrintDataType.name().equals(name())) { return CDef.PrintDataType.of(code); }
            if (PrintErrorFlg.name().equals(name())) { return CDef.PrintErrorFlg.of(code); }
            if (PrintQueueStatus.name().equals(name())) { return CDef.PrintQueueStatus.of(code); }
            if (PrintResultClass.name().equals(name())) { return CDef.PrintResultClass.of(code); }
            if (PrintServiceStatus.name().equals(name())) { return CDef.PrintServiceStatus.of(code); }
            if (PrintStatus.name().equals(name())) { return CDef.PrintStatus.of(code); }
            if (PrintedFlg.name().equals(name())) { return CDef.PrintedFlg.of(code); }
            if (PriorityFlg.name().equals(name())) { return CDef.PriorityFlg.of(code); }
            if (ProductLabelJanBarcode.name().equals(name())) { return CDef.ProductLabelJanBarcode.of(code); }
            if (ProductLabelOutUnit.name().equals(name())) { return CDef.ProductLabelOutUnit.of(code); }
            if (ProductLabelProdBarcode.name().equals(name())) { return CDef.ProductLabelProdBarcode.of(code); }
            if (ProductPartPacking.name().equals(name())) { return CDef.ProductPartPacking.of(code); }
            if (ProductTypeCode.name().equals(name())) { return CDef.ProductTypeCode.of(code); }
            if (Qty0Display.name().equals(name())) { return CDef.Qty0Display.of(code); }
            if (ReasonType.name().equals(name())) { return CDef.ReasonType.of(code); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return CDef.ReceiveDeliveryStatus.of(code); }
            if (ReceiveFlg.name().equals(name())) { return CDef.ReceiveFlg.of(code); }
            if (ReceiveStatus.name().equals(name())) { return CDef.ReceiveStatus.of(code); }
            if (ReplenishAllocCls.name().equals(name())) { return CDef.ReplenishAllocCls.of(code); }
            if (ReplenishProductCdUnset.name().equals(name())) { return CDef.ReplenishProductCdUnset.of(code); }
            if (ReplenishSearchCls.name().equals(name())) { return CDef.ReplenishSearchCls.of(code); }
            if (ReplenishUnitCls.name().equals(name())) { return CDef.ReplenishUnitCls.of(code); }
            if (ReportLayoutItemType.name().equals(name())) { return CDef.ReportLayoutItemType.of(code); }
            if (RestockType.name().equals(name())) { return CDef.RestockType.of(code); }
            if (ResultAfterProductLabel.name().equals(name())) { return CDef.ResultAfterProductLabel.of(code); }
            if (ReverseValidFlg.name().equals(name())) { return CDef.ReverseValidFlg.of(code); }
            if (Select.name().equals(name())) { return CDef.Select.of(code); }
            if (SelectPrintServiceStatus.name().equals(name())) { return CDef.SelectPrintServiceStatus.of(code); }
            if (SerialOperationType.name().equals(name())) { return CDef.SerialOperationType.of(code); }
            if (TargetWindow.name().equals(name())) { return CDef.TargetWindow.of(code); }
            if (SettlementType.name().equals(name())) { return CDef.SettlementType.of(code); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return CDef.SglRowInspAfterOutCls.of(code); }
            if (SglRowPicFlg.name().equals(name())) { return CDef.SglRowPicFlg.of(code); }
            if (SheetCollate.name().equals(name())) { return CDef.SheetCollate.of(code); }
            if (ShippingFlg.name().equals(name())) { return CDef.ShippingFlg.of(code); }
            if (ShippingStatus.name().equals(name())) { return CDef.ShippingStatus.of(code); }
            if (ShippingStopFlg.name().equals(name())) { return CDef.ShippingStopFlg.of(code); }
            if (ShortStockDisplay.name().equals(name())) { return CDef.ShortStockDisplay.of(code); }
            if (ShpCheckCls.name().equals(name())) { return CDef.ShpCheckCls.of(code); }
            if (ShpCheckDisplay.name().equals(name())) { return CDef.ShpCheckDisplay.of(code); }
            if (SlipType.name().equals(name())) { return CDef.SlipType.of(code); }
            if (SoundPlayFlg.name().equals(name())) { return CDef.SoundPlayFlg.of(code); }
            if (StockAdjustFlg.name().equals(name())) { return CDef.StockAdjustFlg.of(code); }
            if (StockDisplayFld.name().equals(name())) { return CDef.StockDisplayFld.of(code); }
            if (StockExistOnlyFlg.name().equals(name())) { return CDef.StockExistOnlyFlg.of(code); }
            if (StockMoveFlg.name().equals(name())) { return CDef.StockMoveFlg.of(code); }
            if (StockNum0Display.name().equals(name())) { return CDef.StockNum0Display.of(code); }
            if (StockOutAllocCls.name().equals(name())) { return CDef.StockOutAllocCls.of(code); }
            if (StockOutAutoInstFlg.name().equals(name())) { return CDef.StockOutAutoInstFlg.of(code); }
            if (StockOutFlg.name().equals(name())) { return CDef.StockOutFlg.of(code); }
            if (StockOutInstCxlFlg.name().equals(name())) { return CDef.StockOutInstCxlFlg.of(code); }
            if (StockOutInstSplitFlg.name().equals(name())) { return CDef.StockOutInstSplitFlg.of(code); }
            if (StockQtyDisplay.name().equals(name())) { return CDef.StockQtyDisplay.of(code); }
            if (StockTakingInput.name().equals(name())) { return CDef.StockTakingInput.of(code); }
            if (StockTarget.name().equals(name())) { return CDef.StockTarget.of(code); }
            if (StoreDtFlg.name().equals(name())) { return CDef.StoreDtFlg.of(code); }
            if (StoreFlg.name().equals(name())) { return CDef.StoreFlg.of(code); }
            if (StoreNoDivideDisplay.name().equals(name())) { return CDef.StoreNoDivideDisplay.of(code); }
            if (StoreNoFlg.name().equals(name())) { return CDef.StoreNoFlg.of(code); }
            if (StoreNoMergeFlg.name().equals(name())) { return CDef.StoreNoMergeFlg.of(code); }
            if (SystemLogStatus.name().equals(name())) { return CDef.SystemLogStatus.of(code); }
            if (SystemLogType.name().equals(name())) { return CDef.SystemLogType.of(code); }
            if (SystemType.name().equals(name())) { return CDef.SystemType.of(code); }
            if (TagDeliveryOutFlg.name().equals(name())) { return CDef.TagDeliveryOutFlg.of(code); }
            if (TakingShippingDtFlg.name().equals(name())) { return CDef.TakingShippingDtFlg.of(code); }
            if (TakingShippingFlg.name().equals(name())) { return CDef.TakingShippingFlg.of(code); }
            if (TextAlign.name().equals(name())) { return CDef.TextAlign.of(code); }
            if (TotalPicFlg.name().equals(name())) { return CDef.TotalPicFlg.of(code); }
            if (TrackingNumberingUnit.name().equals(name())) { return CDef.TrackingNumberingUnit.of(code); }
            if (TransitDisplay.name().equals(name())) { return CDef.TransitDisplay.of(code); }
            if (Unmatch.name().equals(name())) { return CDef.Unmatch.of(code); }
            if (UpdCd.name().equals(name())) { return CDef.UpdCd.of(code); }
            if (UpdType.name().equals(name())) { return CDef.UpdType.of(code); }
            if (Updatable.name().equals(name())) { return CDef.Updatable.of(code); }
            if (UploadTableNm.name().equals(name())) { return CDef.UploadTableNm.of(code); }
            if (UseHtShipFlg.name().equals(name())) { return CDef.UseHtShipFlg.of(code); }
            if (UserEditable.name().equals(name())) { return CDef.UserEditable.of(code); }
            if (VendorFlg.name().equals(name())) { return CDef.VendorFlg.of(code); }
            if (Visible.name().equals(name())) { return CDef.Visible.of(code); }
            if (WorkFlg.name().equals(name())) { return CDef.WorkFlg.of(code); }
            if (WorkMessageFlg.name().equals(name())) { return CDef.WorkMessageFlg.of(code); }
            if (YamatoDelivTz.name().equals(name())) { return CDef.YamatoDelivTz.of(code); }
            if (YupackDelivTz.name().equals(name())) { return CDef.YupackDelivTz.of(code); }
            if (ZipFlg.name().equals(name())) { return CDef.ZipFlg.of(code); }
            if (ResultAfterProductTarget.name().equals(name())) { return CDef.ResultAfterProductTarget.of(code); }
            if (CopyTargetTable.name().equals(name())) { return CDef.CopyTargetTable.of(code); }
            if (InspectionLabelOutFlg.name().equals(name())) { return CDef.InspectionLabelOutFlg.of(code); }
            if (DecimalProductPacking.name().equals(name())) { return CDef.DecimalProductPacking.of(code); }
            if (DecimalExistFlg.name().equals(name())) { return CDef.DecimalExistFlg.of(code); }
            if (CasePickFlg.name().equals(name())) { return CDef.CasePickFlg.of(code); }
            if (EmReplenishShapeFlg.name().equals(name())) { return CDef.EmReplenishShapeFlg.of(code); }
            if (WorkStatus.name().equals(name())) { return CDef.WorkStatus.of(code); }
            if (WorkLogOutFlg.name().equals(name())) { return CDef.WorkLogOutFlg.of(code); }
            if (RoleControlClass.name().equals(name())) { return CDef.RoleControlClass.of(code); }
            if (BolOutFlg.name().equals(name())) { return CDef.BolOutFlg.of(code); }
            if (BolOutputTargetFlg.name().equals(name())) { return CDef.BolOutputTargetFlg.of(code); }
            if (PaymentTerm.name().equals(name())) { return CDef.PaymentTerm.of(code); }
            if (CesIntegrationFlg.name().equals(name())) { return CDef.CesIntegrationFlg.of(code); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return CDef.PackingSlipAutoOutputFlg.of(code); }
            if (FreightCls.name().equals(name())) { return CDef.FreightCls.of(code); }
            if (SatDeliveryFlg.name().equals(name())) { return CDef.SatDeliveryFlg.of(code); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return CDef.ResidentialDeliveryFlg.of(code); }
            if (CodFlg.name().equals(name())) { return CDef.CodFlg.of(code); }
            if (SignatureRequiredFlg.name().equals(name())) { return CDef.SignatureRequiredFlg.of(code); }
            if (SignatureReleaseFlg.name().equals(name())) { return CDef.SignatureReleaseFlg.of(code); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return CDef.CallBeforeDeliveryFlg.of(code); }
            if (FreezableProtectionFlg.name().equals(name())) { return CDef.FreezableProtectionFlg.of(code); }
            if (GuaranteedPlusFlg.name().equals(name())) { return CDef.GuaranteedPlusFlg.of(code); }
            if (ResidentialPickupFlg.name().equals(name())) { return CDef.ResidentialPickupFlg.of(code); }
            if (DoNotStackStackFlg.name().equals(name())) { return CDef.DoNotStackStackFlg.of(code); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return CDef.LimitedAccessDeliveryFlg.of(code); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return CDef.LimitedAccessPickupFlg.of(code); }
            if (OverSizedFlg.name().equals(name())) { return CDef.OverSizedFlg.of(code); }
            if (PoisonFlg.name().equals(name())) { return CDef.PoisonFlg.of(code); }
            if (FoogFlg.name().equals(name())) { return CDef.FoogFlg.of(code); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return CDef.LiftgateDeliveryPrepaidFlg.of(code); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return CDef.LiftgateDeliveryCollectFlg.of(code); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return CDef.LiftgatePickupPrepaidFlg.of(code); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return CDef.LiftgatePickupCollectFlg.of(code); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return CDef.InsideDeliveryPrepaidFlg.of(code); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return CDef.InsideDeliveryCollectFlg.of(code); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return CDef.InsidePickupPrepaidFlg.of(code); }
            if (InsidePickupCollectFlg.name().equals(name())) { return CDef.InsidePickupCollectFlg.of(code); }
            if (RcmdPickingCls.name().equals(name())) { return CDef.RcmdPickingCls.of(code); }
            if (SglRowPicTarget.name().equals(name())) { return CDef.SglRowPicTarget.of(code); }
            if (CasePicTarget.name().equals(name())) { return CDef.CasePicTarget.of(code); }
            if (AttendanceLeavingRest.name().equals(name())) { return CDef.AttendanceLeavingRest.of(code); }
            if (UploadZipType.name().equals(name())) { return CDef.UploadZipType.of(code); }
            if (FwType.name().equals(name())) { return CDef.FwType.of(code); }
            if (McaType.name().equals(name())) { return CDef.McaType.of(code); }
            if (AccountFlg.name().equals(name())) { return CDef.AccountFlg.of(code); }
            if (AlarmReasonCls.name().equals(name())) { return CDef.AlarmReasonCls.of(code); }
            if (AlarmType.name().equals(name())) { return CDef.AlarmType.of(code); }
            if (AreaCls.name().equals(name())) { return CDef.AreaCls.of(code); }
            if (AssortStatus.name().equals(name())) { return CDef.AssortStatus.of(code); }
            if (BaseCls.name().equals(name())) { return CDef.BaseCls.of(code); }
            if (BoxType.name().equals(name())) { return CDef.BoxType.of(code); }
            if (CarrierType.name().equals(name())) { return CDef.CarrierType.of(code); }
            if (CarrierTypeCd.name().equals(name())) { return CDef.CarrierTypeCd.of(code); }
            if (CaseTypeCd.name().equals(name())) { return CDef.CaseTypeCd.of(code); }
            if (ClosingDt.name().equals(name())) { return CDef.ClosingDt.of(code); }
            if (CompletedHidden.name().equals(name())) { return CDef.CompletedHidden.of(code); }
            if (Condition.name().equals(name())) { return CDef.Condition.of(code); }
            if (Constract.name().equals(name())) { return CDef.Constract.of(code); }
            if (CsPsType.name().equals(name())) { return CDef.CsPsType.of(code); }
            if (DefaultStockType.name().equals(name())) { return CDef.DefaultStockType.of(code); }
            if (DelivCenterFrom.name().equals(name())) { return CDef.DelivCenterFrom.of(code); }
            if (DelivCenterTo.name().equals(name())) { return CDef.DelivCenterTo.of(code); }
            if (DeliveryDtUnspecified.name().equals(name())) { return CDef.DeliveryDtUnspecified.of(code); }
            if (DeliveryTimeZone.name().equals(name())) { return CDef.DeliveryTimeZone.of(code); }
            if (DeliveryTypeSendCls.name().equals(name())) { return CDef.DeliveryTypeSendCls.of(code); }
            if (DepositItemFlg.name().equals(name())) { return CDef.DepositItemFlg.of(code); }
            if (DepositType.name().equals(name())) { return CDef.DepositType.of(code); }
            if (DiffCls.name().equals(name())) { return CDef.DiffCls.of(code); }
            if (DirectDeliveryTypeCd.name().equals(name())) { return CDef.DirectDeliveryTypeCd.of(code); }
            if (EcOrder.name().equals(name())) { return CDef.EcOrder.of(code); }
            if (EcType.name().equals(name())) { return CDef.EcType.of(code); }
            if (ExecuteStatus.name().equals(name())) { return CDef.ExecuteStatus.of(code); }
            if (Fee.name().equals(name())) { return CDef.Fee.of(code); }
            if (Floor.name().equals(name())) { return CDef.Floor.of(code); }
            if (FloorCd.name().equals(name())) { return CDef.FloorCd.of(code); }
            if (FloorEndFlg.name().equals(name())) { return CDef.FloorEndFlg.of(code); }
            if (FloorTypeCd.name().equals(name())) { return CDef.FloorTypeCd.of(code); }
            if (HandOverStatus.name().equals(name())) { return CDef.HandOverStatus.of(code); }
            if (HandlingType.name().equals(name())) { return CDef.HandlingType.of(code); }
            if (HeavyItemFlg.name().equals(name())) { return CDef.HeavyItemFlg.of(code); }
            if (HeavyItemHadlingFlg.name().equals(name())) { return CDef.HeavyItemHadlingFlg.of(code); }
            if (HinmokuGroupCd.name().equals(name())) { return CDef.HinmokuGroupCd.of(code); }
            if (HolidayFlg.name().equals(name())) { return CDef.HolidayFlg.of(code); }
            if (IdManagAbolitionTypeCd.name().equals(name())) { return CDef.IdManagAbolitionTypeCd.of(code); }
            if (InsuranceFlg.name().equals(name())) { return CDef.InsuranceFlg.of(code); }
            if (InventoryDataStatus.name().equals(name())) { return CDef.InventoryDataStatus.of(code); }
            if (InventoryDiffCls.name().equals(name())) { return CDef.InventoryDiffCls.of(code); }
            if (InventoryInputCls.name().equals(name())) { return CDef.InventoryInputCls.of(code); }
            if (InventoryListOutCls.name().equals(name())) { return CDef.InventoryListOutCls.of(code); }
            if (InventoryListType.name().equals(name())) { return CDef.InventoryListType.of(code); }
            if (ItManagType.name().equals(name())) { return CDef.ItManagType.of(code); }
            if (ItemDensan.name().equals(name())) { return CDef.ItemDensan.of(code); }
            if (LargeItemFlg.name().equals(name())) { return CDef.LargeItemFlg.of(code); }
            if (LimitDtSplitTypeCd.name().equals(name())) { return CDef.LimitDtSplitTypeCd.of(code); }
            if (LimitDtUnmatchTypeCd.name().equals(name())) { return CDef.LimitDtUnmatchTypeCd.of(code); }
            if (LogiAttentionTypeCd.name().equals(name())) { return CDef.LogiAttentionTypeCd.of(code); }
            if (LogiSpecialTypeCd.name().equals(name())) { return CDef.LogiSpecialTypeCd.of(code); }
            if (LogiWeightFlg.name().equals(name())) { return CDef.LogiWeightFlg.of(code); }
            if (LotSplitTypeCd.name().equals(name())) { return CDef.LotSplitTypeCd.of(code); }
            if (LotUnmatchTypeCd.name().equals(name())) { return CDef.LotUnmatchTypeCd.of(code); }
            if (MaxStoreShape.name().equals(name())) { return CDef.MaxStoreShape.of(code); }
            if (MedicalManagFlg.name().equals(name())) { return CDef.MedicalManagFlg.of(code); }
            if (MoveDirection.name().equals(name())) { return CDef.MoveDirection.of(code); }
            if (NationalHolidayCarrier.name().equals(name())) { return CDef.NationalHolidayCarrier.of(code); }
            if (NationalHolidayFlg.name().equals(name())) { return CDef.NationalHolidayFlg.of(code); }
            if (NizoroeProcessId.name().equals(name())) { return CDef.NizoroeProcessId.of(code); }
            if (NizoroeProcessIdWms.name().equals(name())) { return CDef.NizoroeProcessIdWms.of(code); }
            if (NizoroeTime.name().equals(name())) { return CDef.NizoroeTime.of(code); }
            if (NizoroeType.name().equals(name())) { return CDef.NizoroeType.of(code); }
            if (NizoroeTypeWms.name().equals(name())) { return CDef.NizoroeTypeWms.of(code); }
            if (NoOkinawaFlightFlg.name().equals(name())) { return CDef.NoOkinawaFlightFlg.of(code); }
            if (OcrDateFormat.name().equals(name())) { return CDef.OcrDateFormat.of(code); }
            if (OutputListType.name().equals(name())) { return CDef.OutputListType.of(code); }
            if (OutputMonth.name().equals(name())) { return CDef.OutputMonth.of(code); }
            if (OutputStatus.name().equals(name())) { return CDef.OutputStatus.of(code); }
            if (PaymentTypeCd.name().equals(name())) { return CDef.PaymentTypeCd.of(code); }
            if (PickingPatternCd.name().equals(name())) { return CDef.PickingPatternCd.of(code); }
            if (Prefecture.name().equals(name())) { return CDef.Prefecture.of(code); }
            if (PriceDiffHidden.name().equals(name())) { return CDef.PriceDiffHidden.of(code); }
            if (ProdDtManagFlg.name().equals(name())) { return CDef.ProdDtManagFlg.of(code); }
            if (ProdDtSplitTypeCd.name().equals(name())) { return CDef.ProdDtSplitTypeCd.of(code); }
            if (ProdDtUnmatchTypeCd.name().equals(name())) { return CDef.ProdDtUnmatchTypeCd.of(code); }
            if (ProductCategoryConvertCls.name().equals(name())) { return CDef.ProductCategoryConvertCls.of(code); }
            if (ProductCategoryPlant.name().equals(name())) { return CDef.ProductCategoryPlant.of(code); }
            if (ProductCategoryType.name().equals(name())) { return CDef.ProductCategoryType.of(code); }
            if (ProductStoreStatus.name().equals(name())) { return CDef.ProductStoreStatus.of(code); }
            if (ProductUnitCls.name().equals(name())) { return CDef.ProductUnitCls.of(code); }
            if (ReceiveReason.name().equals(name())) { return CDef.ReceiveReason.of(code); }
            if (ReceiveReasonConvert.name().equals(name())) { return CDef.ReceiveReasonConvert.of(code); }
            if (ReceiveReasonDepositReceive.name().equals(name())) { return CDef.ReceiveReasonDepositReceive.of(code); }
            if (ReceiveStatus01.name().equals(name())) { return CDef.ReceiveStatus01.of(code); }
            if (RecommendLocationTypeCd.name().equals(name())) { return CDef.RecommendLocationTypeCd.of(code); }
            if (RelatedProducts.name().equals(name())) { return CDef.RelatedProducts.of(code); }
            if (RemainFlg.name().equals(name())) { return CDef.RemainFlg.of(code); }
            if (ReplenishShape.name().equals(name())) { return CDef.ReplenishShape.of(code); }
            if (SampleCls.name().equals(name())) { return CDef.SampleCls.of(code); }
            if (SearchReferenceDt.name().equals(name())) { return CDef.SearchReferenceDt.of(code); }
            if (SerialManagFlg.name().equals(name())) { return CDef.SerialManagFlg.of(code); }
            if (ShapeGrpTypeCd.name().equals(name())) { return CDef.ShapeGrpTypeCd.of(code); }
            if (SharedProductTypeCd.name().equals(name())) { return CDef.SharedProductTypeCd.of(code); }
            if (ShippingInspectionHidden.name().equals(name())) { return CDef.ShippingInspectionHidden.of(code); }
            if (ShippingInspectionStatus.name().equals(name())) { return CDef.ShippingInspectionStatus.of(code); }
            if (ShippingProcessType.name().equals(name())) { return CDef.ShippingProcessType.of(code); }
            if (ShippingProgress.name().equals(name())) { return CDef.ShippingProgress.of(code); }
            if (ShippingReason.name().equals(name())) { return CDef.ShippingReason.of(code); }
            if (ShippingReasonConvert.name().equals(name())) { return CDef.ShippingReasonConvert.of(code); }
            if (ShippingSlipType.name().equals(name())) { return CDef.ShippingSlipType.of(code); }
            if (ShippingType.name().equals(name())) { return CDef.ShippingType.of(code); }
            if (ShippingWorkType.name().equals(name())) { return CDef.ShippingWorkType.of(code); }
            if (SlipType2.name().equals(name())) { return CDef.SlipType2.of(code); }
            if (SpareTypeCd.name().equals(name())) { return CDef.SpareTypeCd.of(code); }
            if (SpecifiedNumOfShoes.name().equals(name())) { return CDef.SpecifiedNumOfShoes.of(code); }
            if (SplitDeliveryTypeCd.name().equals(name())) { return CDef.SplitDeliveryTypeCd.of(code); }
            if (StockDifference.name().equals(name())) { return CDef.StockDifference.of(code); }
            if (StockDisplayType.name().equals(name())) { return CDef.StockDisplayType.of(code); }
            if (StockExist.name().equals(name())) { return CDef.StockExist.of(code); }
            if (StockProcessType.name().equals(name())) { return CDef.StockProcessType.of(code); }
            if (StockRefCls.name().equals(name())) { return CDef.StockRefCls.of(code); }
            if (StockTakingStatus.name().equals(name())) { return CDef.StockTakingStatus.of(code); }
            if (StockZeroDisplay.name().equals(name())) { return CDef.StockZeroDisplay.of(code); }
            if (SuppliesVarietyFlg.name().equals(name())) { return CDef.SuppliesVarietyFlg.of(code); }
            if (TargetBase.name().equals(name())) { return CDef.TargetBase.of(code); }
            if (TargetItemCd.name().equals(name())) { return CDef.TargetItemCd.of(code); }
            if (TargetKoguchiCd.name().equals(name())) { return CDef.TargetKoguchiCd.of(code); }
            if (TargetSalesCd.name().equals(name())) { return CDef.TargetSalesCd.of(code); }
            if (UnitCls.name().equals(name())) { return CDef.UnitCls.of(code); }
            if (UrgentShippingTimeZone.name().equals(name())) { return CDef.UrgentShippingTimeZone.of(code); }
            if (WorkType.name().equals(name())) { return CDef.WorkType.of(code); }
            if (ReceiveLabelFlg.name().equals(name())) { return CDef.ReceiveLabelFlg.of(code); }
            if (ReceiveDtUnmatchFlg.name().equals(name())) { return CDef.ReceiveDtUnmatchFlg.of(code); }
            if (PrintFlg.name().equals(name())) { return CDef.PrintFlg.of(code); }
            if (ReceiveRemainFlg.name().equals(name())) { return CDef.ReceiveRemainFlg.of(code); }
            if (ShippingPickedHidden.name().equals(name())) { return CDef.ShippingPickedHidden.of(code); }
            if (CarrierDataOutFlg.name().equals(name())) { return CDef.CarrierDataOutFlg.of(code); }
            if (PllOutFlg.name().equals(name())) { return CDef.PllOutFlg.of(code); }
            if (DepositorCls.name().equals(name())) { return CDef.DepositorCls.of(code); }
            if (RplOutFlg.name().equals(name())) { return CDef.RplOutFlg.of(code); }
            if (RecordSendFlg.name().equals(name())) { return CDef.RecordSendFlg.of(code); }
            if (HandOverHidden.name().equals(name())) { return CDef.HandOverHidden.of(code); }
            if (ExternalWarehouseFlg.name().equals(name())) { return CDef.ExternalWarehouseFlg.of(code); }
            if (StandardPlantCls.name().equals(name())) { return CDef.StandardPlantCls.of(code); }
            if (LargeItemHadlingFlg.name().equals(name())) { return CDef.LargeItemHadlingFlg.of(code); }
            if (HolidayCarrierFlg.name().equals(name())) { return CDef.HolidayCarrierFlg.of(code); }
            if (OkinawaFlightFlg.name().equals(name())) { return CDef.OkinawaFlightFlg.of(code); }
            if (BaseDefaultCarrierFlg.name().equals(name())) { return CDef.BaseDefaultCarrierFlg.of(code); }
            if (SlipTypeCd.name().equals(name())) { return CDef.SlipTypeCd.of(code); }
            if (ProperFlg.name().equals(name())) { return CDef.ProperFlg.of(code); }
            if (CdlOutFlg.name().equals(name())) { return CDef.CdlOutFlg.of(code); }
            if (ErrorNum.name().equals(name())) { return CDef.ErrorNum.of(code); }
            if (CenterPicListCls1.name().equals(name())) { return CDef.CenterPicListCls1.of(code); }
            if (CenterPicListCls2.name().equals(name())) { return CDef.CenterPicListCls2.of(code); }
            if (CenterPicListCls3.name().equals(name())) { return CDef.CenterPicListCls3.of(code); }
            if (CenterSagawaDelivTz.name().equals(name())) { return CDef.CenterSagawaDelivTz.of(code); }
            if (CenterTransportTypeItem.name().equals(name())) { return CDef.CenterTransportTypeItem.of(code); }
            if (CenterSlipShapeCd.name().equals(name())) { return CDef.CenterSlipShapeCd.of(code); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return CDef.CenterTransportTypeSpeed.of(code); }
            if (CenterSealType.name().equals(name())) { return CDef.CenterSealType.of(code); }
            if (CenterTagClass.name().equals(name())) { return CDef.CenterTagClass.of(code); }
            if (CenterTagDataType.name().equals(name())) { return CDef.CenterTagDataType.of(code); }
            if (CenterTagType.name().equals(name())) { return CDef.CenterTagType.of(code); }
            if (CenterTagTypeAfter.name().equals(name())) { return CDef.CenterTagTypeAfter.of(code); }
            if (CenterApiBinsyuCode.name().equals(name())) { return CDef.CenterApiBinsyuCode.of(code); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return CDef.CenterApiDaibikiFlg.of(code); }
            if (CenterApiDaibikiType.name().equals(name())) { return CDef.CenterApiDaibikiType.of(code); }
            if (CenterApiEidomeFlg.name().equals(name())) { return CDef.CenterApiEidomeFlg.of(code); }
            if (CenterApiWeightCd.name().equals(name())) { return CDef.CenterApiWeightCd.of(code); }
            if (CenterOutputTargetFlg.name().equals(name())) { return CDef.CenterOutputTargetFlg.of(code); }
            if (CenterPrintCondition.name().equals(name())) { return CDef.CenterPrintCondition.of(code); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        public OptionalThing<? extends Classification> byName(String name) {
            if (ProcessTypeCd.name().equals(name())) { return CDef.ProcessTypeCd.byName(name); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return CDef.AfterDelivSlipOutTgt.byName(name); }
            if (AfterTagOutFlg.name().equals(name())) { return CDef.AfterTagOutFlg.byName(name); }
            if (AllShippingFlg.name().equals(name())) { return CDef.AllShippingFlg.byName(name); }
            if (AllcNgDisplay.name().equals(name())) { return CDef.AllcNgDisplay.byName(name); }
            if (AllcNgFlg.name().equals(name())) { return CDef.AllcNgFlg.byName(name); }
            if (AllocSortKey.name().equals(name())) { return CDef.AllocSortKey.byName(name); }
            if (ArrivalStoreFormat.name().equals(name())) { return CDef.ArrivalStoreFormat.byName(name); }
            if (AutoEmgSetFlg.name().equals(name())) { return CDef.AutoEmgSetFlg.byName(name); }
            if (AutoEmgSetTgt.name().equals(name())) { return CDef.AutoEmgSetTgt.byName(name); }
            if (AutoPrintTargetFlg.name().equals(name())) { return CDef.AutoPrintTargetFlg.byName(name); }
            if (AutoShipInstFlg.name().equals(name())) { return CDef.AutoShipInstFlg.byName(name); }
            if (BarcodeType.name().equals(name())) { return CDef.BarcodeType.byName(name); }
            if (BatchProgressFlg.name().equals(name())) { return CDef.BatchProgressFlg.byName(name); }
            if (BoxSelectSkip.name().equals(name())) { return CDef.BoxSelectSkip.byName(name); }
            if (CancelDataDisplay.name().equals(name())) { return CDef.CancelDataDisplay.byName(name); }
            if (CasePicFlg.name().equals(name())) { return CDef.CasePicFlg.byName(name); }
            if (CenterClientCls.name().equals(name())) { return CDef.CenterClientCls.byName(name); }
            if (CenterTransitFlg.name().equals(name())) { return CDef.CenterTransitFlg.byName(name); }
            if (CharacterCd.name().equals(name())) { return CDef.CharacterCd.byName(name); }
            if (ChargeQty0Display.name().equals(name())) { return CDef.ChargeQty0Display.byName(name); }
            if (CheckDigit.name().equals(name())) { return CDef.CheckDigit.byName(name); }
            if (CodCls.name().equals(name())) { return CDef.CodCls.byName(name); }
            if (CodType.name().equals(name())) { return CDef.CodType.byName(name); }
            if (CodeFlg.name().equals(name())) { return CDef.CodeFlg.byName(name); }
            if (CodeType.name().equals(name())) { return CDef.CodeType.byName(name); }
            if (ColType.name().equals(name())) { return CDef.ColType.byName(name); }
            if (CommentFlg.name().equals(name())) { return CDef.CommentFlg.byName(name); }
            if (CompanyFlg.name().equals(name())) { return CDef.CompanyFlg.byName(name); }
            if (CoolCls.name().equals(name())) { return CDef.CoolCls.byName(name); }
            if (CoolType.name().equals(name())) { return CDef.CoolType.byName(name); }
            if (CorrectType.name().equals(name())) { return CDef.CorrectType.byName(name); }
            if (DataInputCommitType.name().equals(name())) { return CDef.DataInputCommitType.byName(name); }
            if (DataInputOperationType.name().equals(name())) { return CDef.DataInputOperationType.byName(name); }
            if (DataInputProcessType.name().equals(name())) { return CDef.DataInputProcessType.byName(name); }
            if (DataInputRange.name().equals(name())) { return CDef.DataInputRange.byName(name); }
            if (DataInputType.name().equals(name())) { return CDef.DataInputType.byName(name); }
            if (DataType.name().equals(name())) { return CDef.DataType.byName(name); }
            if (Default.name().equals(name())) { return CDef.Default.byName(name); }
            if (DefaultFlg.name().equals(name())) { return CDef.DefaultFlg.byName(name); }
            if (DelFlg.name().equals(name())) { return CDef.DelFlg.byName(name); }
            if (DeleteDataDisplay.name().equals(name())) { return CDef.DeleteDataDisplay.byName(name); }
            if (DelivMatchFlg.name().equals(name())) { return CDef.DelivMatchFlg.byName(name); }
            if (DelivTz.name().equals(name())) { return CDef.DelivTz.byName(name); }
            if (DeliveryFlg.name().equals(name())) { return CDef.DeliveryFlg.byName(name); }
            if (DepositFlg.name().equals(name())) { return CDef.DepositFlg.byName(name); }
            if (DisplayRequired.name().equals(name())) { return CDef.DisplayRequired.byName(name); }
            if (DtCls.name().equals(name())) { return CDef.DtCls.byName(name); }
            if (Editable.name().equals(name())) { return CDef.Editable.byName(name); }
            if (EmergencyDisplay.name().equals(name())) { return CDef.EmergencyDisplay.byName(name); }
            if (EmergencyFlg.name().equals(name())) { return CDef.EmergencyFlg.byName(name); }
            if (ErrorFlg.name().equals(name())) { return CDef.ErrorFlg.byName(name); }
            if (ErrorProcessMet.name().equals(name())) { return CDef.ErrorProcessMet.byName(name); }
            if (FixedPoint.name().equals(name())) { return CDef.FixedPoint.byName(name); }
            if (ForceFixedFlg.name().equals(name())) { return CDef.ForceFixedFlg.byName(name); }
            if (ForeignFlg.name().equals(name())) { return CDef.ForeignFlg.byName(name); }
            if (GiftFlg.name().equals(name())) { return CDef.GiftFlg.byName(name); }
            if (GiftStatementType.name().equals(name())) { return CDef.GiftStatementType.byName(name); }
            if (HtCharReadFlg.name().equals(name())) { return CDef.HtCharReadFlg.byName(name); }
            if (ImportFlg.name().equals(name())) { return CDef.ImportFlg.byName(name); }
            if (InfoFlg.name().equals(name())) { return CDef.InfoFlg.byName(name); }
            if (InoutType.name().equals(name())) { return CDef.InoutType.byName(name); }
            if (InputType.name().equals(name())) { return CDef.InputType.byName(name); }
            if (InspectionFlg.name().equals(name())) { return CDef.InspectionFlg.byName(name); }
            if (InventoryLocationProduct.name().equals(name())) { return CDef.InventoryLocationProduct.byName(name); }
            if (InvoiceCreateFlg.name().equals(name())) { return CDef.InvoiceCreateFlg.byName(name); }
            if (ItemType.name().equals(name())) { return CDef.ItemType.byName(name); }
            if (LastFlg.name().equals(name())) { return CDef.LastFlg.byName(name); }
            if (LimitDtManagFlg.name().equals(name())) { return CDef.LimitDtManagFlg.byName(name); }
            if (LimitDtReverseFlg.name().equals(name())) { return CDef.LimitDtReverseFlg.byName(name); }
            if (LimitMessageCd.name().equals(name())) { return CDef.LimitMessageCd.byName(name); }
            if (LineFeedCd.name().equals(name())) { return CDef.LineFeedCd.byName(name); }
            if (ListOutFlg.name().equals(name())) { return CDef.ListOutFlg.byName(name); }
            if (ListOutKbn.name().equals(name())) { return CDef.ListOutKbn.byName(name); }
            if (ListOutFlgDisp.name().equals(name())) { return CDef.ListOutFlgDisp.byName(name); }
            if (LoadingFlg.name().equals(name())) { return CDef.LoadingFlg.byName(name); }
            if (LocationType.name().equals(name())) { return CDef.LocationType.byName(name); }
            if (Lockout.name().equals(name())) { return CDef.Lockout.byName(name); }
            if (LogDtlStatus.name().equals(name())) { return CDef.LogDtlStatus.byName(name); }
            if (LogDtlType.name().equals(name())) { return CDef.LogDtlType.byName(name); }
            if (LogStatus.name().equals(name())) { return CDef.LogStatus.byName(name); }
            if (LotManagFlg.name().equals(name())) { return CDef.LotManagFlg.byName(name); }
            if (LotReverseFlg.name().equals(name())) { return CDef.LotReverseFlg.byName(name); }
            if (MergeCls.name().equals(name())) { return CDef.MergeCls.byName(name); }
            if (MergeFlg.name().equals(name())) { return CDef.MergeFlg.byName(name); }
            if (MessageType.name().equals(name())) { return CDef.MessageType.byName(name); }
            if (MixedFlg.name().equals(name())) { return CDef.MixedFlg.byName(name); }
            if (MoveInstStatus.name().equals(name())) { return CDef.MoveInstStatus.byName(name); }
            if (MultiPicCls.name().equals(name())) { return CDef.MultiPicCls.byName(name); }
            if (MultiPicFlg.name().equals(name())) { return CDef.MultiPicFlg.byName(name); }
            if (Necessary.name().equals(name())) { return CDef.Necessary.byName(name); }
            if (NoAllcDisplayFlg.name().equals(name())) { return CDef.NoAllcDisplayFlg.byName(name); }
            if (NoConfirmedFlg.name().equals(name())) { return CDef.NoConfirmedFlg.byName(name); }
            if (NoStockCls.name().equals(name())) { return CDef.NoStockCls.byName(name); }
            if (NoStockOutFlg.name().equals(name())) { return CDef.NoStockOutFlg.byName(name); }
            if (NoUpsideDownCls.name().equals(name())) { return CDef.NoUpsideDownCls.byName(name); }
            if (NotCompletedFlg.name().equals(name())) { return CDef.NotCompletedFlg.byName(name); }
            if (OnetimeFlg.name().equals(name())) { return CDef.OnetimeFlg.byName(name); }
            if (OverStoreNumFlg.name().equals(name())) { return CDef.OverStoreNumFlg.byName(name); }
            if (PackingCalCls.name().equals(name())) { return CDef.PackingCalCls.byName(name); }
            if (PackingProcessCls.name().equals(name())) { return CDef.PackingProcessCls.byName(name); }
            if (PackingShowFlg.name().equals(name())) { return CDef.PackingShowFlg.byName(name); }
            if (PackingStatus.name().equals(name())) { return CDef.PackingStatus.byName(name); }
            if (PasswordReset.name().equals(name())) { return CDef.PasswordReset.byName(name); }
            if (PastStoreDtFlg.name().equals(name())) { return CDef.PastStoreDtFlg.byName(name); }
            if (PhysicalDelete.name().equals(name())) { return CDef.PhysicalDelete.byName(name); }
            if (PicCls.name().equals(name())) { return CDef.PicCls.byName(name); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return CDef.PicMthdRcmdBreakKey.byName(name); }
            if (PicMthdRcmdFlg.name().equals(name())) { return CDef.PicMthdRcmdFlg.byName(name); }
            if (PicMthdRcmdListOut.name().equals(name())) { return CDef.PicMthdRcmdListOut.byName(name); }
            if (PickingFlg.name().equals(name())) { return CDef.PickingFlg.byName(name); }
            if (PickingLocationFlg.name().equals(name())) { return CDef.PickingLocationFlg.byName(name); }
            if (PickingStatus.name().equals(name())) { return CDef.PickingStatus.byName(name); }
            if (PickingType.name().equals(name())) { return CDef.PickingType.byName(name); }
            if (PostType.name().equals(name())) { return CDef.PostType.byName(name); }
            if (PrintDataType.name().equals(name())) { return CDef.PrintDataType.byName(name); }
            if (PrintErrorFlg.name().equals(name())) { return CDef.PrintErrorFlg.byName(name); }
            if (PrintQueueStatus.name().equals(name())) { return CDef.PrintQueueStatus.byName(name); }
            if (PrintResultClass.name().equals(name())) { return CDef.PrintResultClass.byName(name); }
            if (PrintServiceStatus.name().equals(name())) { return CDef.PrintServiceStatus.byName(name); }
            if (PrintStatus.name().equals(name())) { return CDef.PrintStatus.byName(name); }
            if (PrintedFlg.name().equals(name())) { return CDef.PrintedFlg.byName(name); }
            if (PriorityFlg.name().equals(name())) { return CDef.PriorityFlg.byName(name); }
            if (ProductLabelJanBarcode.name().equals(name())) { return CDef.ProductLabelJanBarcode.byName(name); }
            if (ProductLabelOutUnit.name().equals(name())) { return CDef.ProductLabelOutUnit.byName(name); }
            if (ProductLabelProdBarcode.name().equals(name())) { return CDef.ProductLabelProdBarcode.byName(name); }
            if (ProductPartPacking.name().equals(name())) { return CDef.ProductPartPacking.byName(name); }
            if (ProductTypeCode.name().equals(name())) { return CDef.ProductTypeCode.byName(name); }
            if (Qty0Display.name().equals(name())) { return CDef.Qty0Display.byName(name); }
            if (ReasonType.name().equals(name())) { return CDef.ReasonType.byName(name); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return CDef.ReceiveDeliveryStatus.byName(name); }
            if (ReceiveFlg.name().equals(name())) { return CDef.ReceiveFlg.byName(name); }
            if (ReceiveStatus.name().equals(name())) { return CDef.ReceiveStatus.byName(name); }
            if (ReplenishAllocCls.name().equals(name())) { return CDef.ReplenishAllocCls.byName(name); }
            if (ReplenishProductCdUnset.name().equals(name())) { return CDef.ReplenishProductCdUnset.byName(name); }
            if (ReplenishSearchCls.name().equals(name())) { return CDef.ReplenishSearchCls.byName(name); }
            if (ReplenishUnitCls.name().equals(name())) { return CDef.ReplenishUnitCls.byName(name); }
            if (ReportLayoutItemType.name().equals(name())) { return CDef.ReportLayoutItemType.byName(name); }
            if (RestockType.name().equals(name())) { return CDef.RestockType.byName(name); }
            if (ResultAfterProductLabel.name().equals(name())) { return CDef.ResultAfterProductLabel.byName(name); }
            if (ReverseValidFlg.name().equals(name())) { return CDef.ReverseValidFlg.byName(name); }
            if (Select.name().equals(name())) { return CDef.Select.byName(name); }
            if (SelectPrintServiceStatus.name().equals(name())) { return CDef.SelectPrintServiceStatus.byName(name); }
            if (SerialOperationType.name().equals(name())) { return CDef.SerialOperationType.byName(name); }
            if (TargetWindow.name().equals(name())) { return CDef.TargetWindow.byName(name); }
            if (SettlementType.name().equals(name())) { return CDef.SettlementType.byName(name); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return CDef.SglRowInspAfterOutCls.byName(name); }
            if (SglRowPicFlg.name().equals(name())) { return CDef.SglRowPicFlg.byName(name); }
            if (SheetCollate.name().equals(name())) { return CDef.SheetCollate.byName(name); }
            if (ShippingFlg.name().equals(name())) { return CDef.ShippingFlg.byName(name); }
            if (ShippingStatus.name().equals(name())) { return CDef.ShippingStatus.byName(name); }
            if (ShippingStopFlg.name().equals(name())) { return CDef.ShippingStopFlg.byName(name); }
            if (ShortStockDisplay.name().equals(name())) { return CDef.ShortStockDisplay.byName(name); }
            if (ShpCheckCls.name().equals(name())) { return CDef.ShpCheckCls.byName(name); }
            if (ShpCheckDisplay.name().equals(name())) { return CDef.ShpCheckDisplay.byName(name); }
            if (SlipType.name().equals(name())) { return CDef.SlipType.byName(name); }
            if (SoundPlayFlg.name().equals(name())) { return CDef.SoundPlayFlg.byName(name); }
            if (StockAdjustFlg.name().equals(name())) { return CDef.StockAdjustFlg.byName(name); }
            if (StockDisplayFld.name().equals(name())) { return CDef.StockDisplayFld.byName(name); }
            if (StockExistOnlyFlg.name().equals(name())) { return CDef.StockExistOnlyFlg.byName(name); }
            if (StockMoveFlg.name().equals(name())) { return CDef.StockMoveFlg.byName(name); }
            if (StockNum0Display.name().equals(name())) { return CDef.StockNum0Display.byName(name); }
            if (StockOutAllocCls.name().equals(name())) { return CDef.StockOutAllocCls.byName(name); }
            if (StockOutAutoInstFlg.name().equals(name())) { return CDef.StockOutAutoInstFlg.byName(name); }
            if (StockOutFlg.name().equals(name())) { return CDef.StockOutFlg.byName(name); }
            if (StockOutInstCxlFlg.name().equals(name())) { return CDef.StockOutInstCxlFlg.byName(name); }
            if (StockOutInstSplitFlg.name().equals(name())) { return CDef.StockOutInstSplitFlg.byName(name); }
            if (StockQtyDisplay.name().equals(name())) { return CDef.StockQtyDisplay.byName(name); }
            if (StockTakingInput.name().equals(name())) { return CDef.StockTakingInput.byName(name); }
            if (StockTarget.name().equals(name())) { return CDef.StockTarget.byName(name); }
            if (StoreDtFlg.name().equals(name())) { return CDef.StoreDtFlg.byName(name); }
            if (StoreFlg.name().equals(name())) { return CDef.StoreFlg.byName(name); }
            if (StoreNoDivideDisplay.name().equals(name())) { return CDef.StoreNoDivideDisplay.byName(name); }
            if (StoreNoFlg.name().equals(name())) { return CDef.StoreNoFlg.byName(name); }
            if (StoreNoMergeFlg.name().equals(name())) { return CDef.StoreNoMergeFlg.byName(name); }
            if (SystemLogStatus.name().equals(name())) { return CDef.SystemLogStatus.byName(name); }
            if (SystemLogType.name().equals(name())) { return CDef.SystemLogType.byName(name); }
            if (SystemType.name().equals(name())) { return CDef.SystemType.byName(name); }
            if (TagDeliveryOutFlg.name().equals(name())) { return CDef.TagDeliveryOutFlg.byName(name); }
            if (TakingShippingDtFlg.name().equals(name())) { return CDef.TakingShippingDtFlg.byName(name); }
            if (TakingShippingFlg.name().equals(name())) { return CDef.TakingShippingFlg.byName(name); }
            if (TextAlign.name().equals(name())) { return CDef.TextAlign.byName(name); }
            if (TotalPicFlg.name().equals(name())) { return CDef.TotalPicFlg.byName(name); }
            if (TrackingNumberingUnit.name().equals(name())) { return CDef.TrackingNumberingUnit.byName(name); }
            if (TransitDisplay.name().equals(name())) { return CDef.TransitDisplay.byName(name); }
            if (Unmatch.name().equals(name())) { return CDef.Unmatch.byName(name); }
            if (UpdCd.name().equals(name())) { return CDef.UpdCd.byName(name); }
            if (UpdType.name().equals(name())) { return CDef.UpdType.byName(name); }
            if (Updatable.name().equals(name())) { return CDef.Updatable.byName(name); }
            if (UploadTableNm.name().equals(name())) { return CDef.UploadTableNm.byName(name); }
            if (UseHtShipFlg.name().equals(name())) { return CDef.UseHtShipFlg.byName(name); }
            if (UserEditable.name().equals(name())) { return CDef.UserEditable.byName(name); }
            if (VendorFlg.name().equals(name())) { return CDef.VendorFlg.byName(name); }
            if (Visible.name().equals(name())) { return CDef.Visible.byName(name); }
            if (WorkFlg.name().equals(name())) { return CDef.WorkFlg.byName(name); }
            if (WorkMessageFlg.name().equals(name())) { return CDef.WorkMessageFlg.byName(name); }
            if (YamatoDelivTz.name().equals(name())) { return CDef.YamatoDelivTz.byName(name); }
            if (YupackDelivTz.name().equals(name())) { return CDef.YupackDelivTz.byName(name); }
            if (ZipFlg.name().equals(name())) { return CDef.ZipFlg.byName(name); }
            if (ResultAfterProductTarget.name().equals(name())) { return CDef.ResultAfterProductTarget.byName(name); }
            if (CopyTargetTable.name().equals(name())) { return CDef.CopyTargetTable.byName(name); }
            if (InspectionLabelOutFlg.name().equals(name())) { return CDef.InspectionLabelOutFlg.byName(name); }
            if (DecimalProductPacking.name().equals(name())) { return CDef.DecimalProductPacking.byName(name); }
            if (DecimalExistFlg.name().equals(name())) { return CDef.DecimalExistFlg.byName(name); }
            if (CasePickFlg.name().equals(name())) { return CDef.CasePickFlg.byName(name); }
            if (EmReplenishShapeFlg.name().equals(name())) { return CDef.EmReplenishShapeFlg.byName(name); }
            if (WorkStatus.name().equals(name())) { return CDef.WorkStatus.byName(name); }
            if (WorkLogOutFlg.name().equals(name())) { return CDef.WorkLogOutFlg.byName(name); }
            if (RoleControlClass.name().equals(name())) { return CDef.RoleControlClass.byName(name); }
            if (BolOutFlg.name().equals(name())) { return CDef.BolOutFlg.byName(name); }
            if (BolOutputTargetFlg.name().equals(name())) { return CDef.BolOutputTargetFlg.byName(name); }
            if (PaymentTerm.name().equals(name())) { return CDef.PaymentTerm.byName(name); }
            if (CesIntegrationFlg.name().equals(name())) { return CDef.CesIntegrationFlg.byName(name); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return CDef.PackingSlipAutoOutputFlg.byName(name); }
            if (FreightCls.name().equals(name())) { return CDef.FreightCls.byName(name); }
            if (SatDeliveryFlg.name().equals(name())) { return CDef.SatDeliveryFlg.byName(name); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return CDef.ResidentialDeliveryFlg.byName(name); }
            if (CodFlg.name().equals(name())) { return CDef.CodFlg.byName(name); }
            if (SignatureRequiredFlg.name().equals(name())) { return CDef.SignatureRequiredFlg.byName(name); }
            if (SignatureReleaseFlg.name().equals(name())) { return CDef.SignatureReleaseFlg.byName(name); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return CDef.CallBeforeDeliveryFlg.byName(name); }
            if (FreezableProtectionFlg.name().equals(name())) { return CDef.FreezableProtectionFlg.byName(name); }
            if (GuaranteedPlusFlg.name().equals(name())) { return CDef.GuaranteedPlusFlg.byName(name); }
            if (ResidentialPickupFlg.name().equals(name())) { return CDef.ResidentialPickupFlg.byName(name); }
            if (DoNotStackStackFlg.name().equals(name())) { return CDef.DoNotStackStackFlg.byName(name); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return CDef.LimitedAccessDeliveryFlg.byName(name); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return CDef.LimitedAccessPickupFlg.byName(name); }
            if (OverSizedFlg.name().equals(name())) { return CDef.OverSizedFlg.byName(name); }
            if (PoisonFlg.name().equals(name())) { return CDef.PoisonFlg.byName(name); }
            if (FoogFlg.name().equals(name())) { return CDef.FoogFlg.byName(name); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return CDef.LiftgateDeliveryPrepaidFlg.byName(name); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return CDef.LiftgateDeliveryCollectFlg.byName(name); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return CDef.LiftgatePickupPrepaidFlg.byName(name); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return CDef.LiftgatePickupCollectFlg.byName(name); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return CDef.InsideDeliveryPrepaidFlg.byName(name); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return CDef.InsideDeliveryCollectFlg.byName(name); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return CDef.InsidePickupPrepaidFlg.byName(name); }
            if (InsidePickupCollectFlg.name().equals(name())) { return CDef.InsidePickupCollectFlg.byName(name); }
            if (RcmdPickingCls.name().equals(name())) { return CDef.RcmdPickingCls.byName(name); }
            if (SglRowPicTarget.name().equals(name())) { return CDef.SglRowPicTarget.byName(name); }
            if (CasePicTarget.name().equals(name())) { return CDef.CasePicTarget.byName(name); }
            if (AttendanceLeavingRest.name().equals(name())) { return CDef.AttendanceLeavingRest.byName(name); }
            if (UploadZipType.name().equals(name())) { return CDef.UploadZipType.byName(name); }
            if (FwType.name().equals(name())) { return CDef.FwType.byName(name); }
            if (McaType.name().equals(name())) { return CDef.McaType.byName(name); }
            if (AccountFlg.name().equals(name())) { return CDef.AccountFlg.byName(name); }
            if (AlarmReasonCls.name().equals(name())) { return CDef.AlarmReasonCls.byName(name); }
            if (AlarmType.name().equals(name())) { return CDef.AlarmType.byName(name); }
            if (AreaCls.name().equals(name())) { return CDef.AreaCls.byName(name); }
            if (AssortStatus.name().equals(name())) { return CDef.AssortStatus.byName(name); }
            if (BaseCls.name().equals(name())) { return CDef.BaseCls.byName(name); }
            if (BoxType.name().equals(name())) { return CDef.BoxType.byName(name); }
            if (CarrierType.name().equals(name())) { return CDef.CarrierType.byName(name); }
            if (CarrierTypeCd.name().equals(name())) { return CDef.CarrierTypeCd.byName(name); }
            if (CaseTypeCd.name().equals(name())) { return CDef.CaseTypeCd.byName(name); }
            if (ClosingDt.name().equals(name())) { return CDef.ClosingDt.byName(name); }
            if (CompletedHidden.name().equals(name())) { return CDef.CompletedHidden.byName(name); }
            if (Condition.name().equals(name())) { return CDef.Condition.byName(name); }
            if (Constract.name().equals(name())) { return CDef.Constract.byName(name); }
            if (CsPsType.name().equals(name())) { return CDef.CsPsType.byName(name); }
            if (DefaultStockType.name().equals(name())) { return CDef.DefaultStockType.byName(name); }
            if (DelivCenterFrom.name().equals(name())) { return CDef.DelivCenterFrom.byName(name); }
            if (DelivCenterTo.name().equals(name())) { return CDef.DelivCenterTo.byName(name); }
            if (DeliveryDtUnspecified.name().equals(name())) { return CDef.DeliveryDtUnspecified.byName(name); }
            if (DeliveryTimeZone.name().equals(name())) { return CDef.DeliveryTimeZone.byName(name); }
            if (DeliveryTypeSendCls.name().equals(name())) { return CDef.DeliveryTypeSendCls.byName(name); }
            if (DepositItemFlg.name().equals(name())) { return CDef.DepositItemFlg.byName(name); }
            if (DepositType.name().equals(name())) { return CDef.DepositType.byName(name); }
            if (DiffCls.name().equals(name())) { return CDef.DiffCls.byName(name); }
            if (DirectDeliveryTypeCd.name().equals(name())) { return CDef.DirectDeliveryTypeCd.byName(name); }
            if (EcOrder.name().equals(name())) { return CDef.EcOrder.byName(name); }
            if (EcType.name().equals(name())) { return CDef.EcType.byName(name); }
            if (ExecuteStatus.name().equals(name())) { return CDef.ExecuteStatus.byName(name); }
            if (Fee.name().equals(name())) { return CDef.Fee.byName(name); }
            if (Floor.name().equals(name())) { return CDef.Floor.byName(name); }
            if (FloorCd.name().equals(name())) { return CDef.FloorCd.byName(name); }
            if (FloorEndFlg.name().equals(name())) { return CDef.FloorEndFlg.byName(name); }
            if (FloorTypeCd.name().equals(name())) { return CDef.FloorTypeCd.byName(name); }
            if (HandOverStatus.name().equals(name())) { return CDef.HandOverStatus.byName(name); }
            if (HandlingType.name().equals(name())) { return CDef.HandlingType.byName(name); }
            if (HeavyItemFlg.name().equals(name())) { return CDef.HeavyItemFlg.byName(name); }
            if (HeavyItemHadlingFlg.name().equals(name())) { return CDef.HeavyItemHadlingFlg.byName(name); }
            if (HinmokuGroupCd.name().equals(name())) { return CDef.HinmokuGroupCd.byName(name); }
            if (HolidayFlg.name().equals(name())) { return CDef.HolidayFlg.byName(name); }
            if (IdManagAbolitionTypeCd.name().equals(name())) { return CDef.IdManagAbolitionTypeCd.byName(name); }
            if (InsuranceFlg.name().equals(name())) { return CDef.InsuranceFlg.byName(name); }
            if (InventoryDataStatus.name().equals(name())) { return CDef.InventoryDataStatus.byName(name); }
            if (InventoryDiffCls.name().equals(name())) { return CDef.InventoryDiffCls.byName(name); }
            if (InventoryInputCls.name().equals(name())) { return CDef.InventoryInputCls.byName(name); }
            if (InventoryListOutCls.name().equals(name())) { return CDef.InventoryListOutCls.byName(name); }
            if (InventoryListType.name().equals(name())) { return CDef.InventoryListType.byName(name); }
            if (ItManagType.name().equals(name())) { return CDef.ItManagType.byName(name); }
            if (ItemDensan.name().equals(name())) { return CDef.ItemDensan.byName(name); }
            if (LargeItemFlg.name().equals(name())) { return CDef.LargeItemFlg.byName(name); }
            if (LimitDtSplitTypeCd.name().equals(name())) { return CDef.LimitDtSplitTypeCd.byName(name); }
            if (LimitDtUnmatchTypeCd.name().equals(name())) { return CDef.LimitDtUnmatchTypeCd.byName(name); }
            if (LogiAttentionTypeCd.name().equals(name())) { return CDef.LogiAttentionTypeCd.byName(name); }
            if (LogiSpecialTypeCd.name().equals(name())) { return CDef.LogiSpecialTypeCd.byName(name); }
            if (LogiWeightFlg.name().equals(name())) { return CDef.LogiWeightFlg.byName(name); }
            if (LotSplitTypeCd.name().equals(name())) { return CDef.LotSplitTypeCd.byName(name); }
            if (LotUnmatchTypeCd.name().equals(name())) { return CDef.LotUnmatchTypeCd.byName(name); }
            if (MaxStoreShape.name().equals(name())) { return CDef.MaxStoreShape.byName(name); }
            if (MedicalManagFlg.name().equals(name())) { return CDef.MedicalManagFlg.byName(name); }
            if (MoveDirection.name().equals(name())) { return CDef.MoveDirection.byName(name); }
            if (NationalHolidayCarrier.name().equals(name())) { return CDef.NationalHolidayCarrier.byName(name); }
            if (NationalHolidayFlg.name().equals(name())) { return CDef.NationalHolidayFlg.byName(name); }
            if (NizoroeProcessId.name().equals(name())) { return CDef.NizoroeProcessId.byName(name); }
            if (NizoroeProcessIdWms.name().equals(name())) { return CDef.NizoroeProcessIdWms.byName(name); }
            if (NizoroeTime.name().equals(name())) { return CDef.NizoroeTime.byName(name); }
            if (NizoroeType.name().equals(name())) { return CDef.NizoroeType.byName(name); }
            if (NizoroeTypeWms.name().equals(name())) { return CDef.NizoroeTypeWms.byName(name); }
            if (NoOkinawaFlightFlg.name().equals(name())) { return CDef.NoOkinawaFlightFlg.byName(name); }
            if (OcrDateFormat.name().equals(name())) { return CDef.OcrDateFormat.byName(name); }
            if (OutputListType.name().equals(name())) { return CDef.OutputListType.byName(name); }
            if (OutputMonth.name().equals(name())) { return CDef.OutputMonth.byName(name); }
            if (OutputStatus.name().equals(name())) { return CDef.OutputStatus.byName(name); }
            if (PaymentTypeCd.name().equals(name())) { return CDef.PaymentTypeCd.byName(name); }
            if (PickingPatternCd.name().equals(name())) { return CDef.PickingPatternCd.byName(name); }
            if (Prefecture.name().equals(name())) { return CDef.Prefecture.byName(name); }
            if (PriceDiffHidden.name().equals(name())) { return CDef.PriceDiffHidden.byName(name); }
            if (ProdDtManagFlg.name().equals(name())) { return CDef.ProdDtManagFlg.byName(name); }
            if (ProdDtSplitTypeCd.name().equals(name())) { return CDef.ProdDtSplitTypeCd.byName(name); }
            if (ProdDtUnmatchTypeCd.name().equals(name())) { return CDef.ProdDtUnmatchTypeCd.byName(name); }
            if (ProductCategoryConvertCls.name().equals(name())) { return CDef.ProductCategoryConvertCls.byName(name); }
            if (ProductCategoryPlant.name().equals(name())) { return CDef.ProductCategoryPlant.byName(name); }
            if (ProductCategoryType.name().equals(name())) { return CDef.ProductCategoryType.byName(name); }
            if (ProductStoreStatus.name().equals(name())) { return CDef.ProductStoreStatus.byName(name); }
            if (ProductUnitCls.name().equals(name())) { return CDef.ProductUnitCls.byName(name); }
            if (ReceiveReason.name().equals(name())) { return CDef.ReceiveReason.byName(name); }
            if (ReceiveReasonConvert.name().equals(name())) { return CDef.ReceiveReasonConvert.byName(name); }
            if (ReceiveReasonDepositReceive.name().equals(name())) { return CDef.ReceiveReasonDepositReceive.byName(name); }
            if (ReceiveStatus01.name().equals(name())) { return CDef.ReceiveStatus01.byName(name); }
            if (RecommendLocationTypeCd.name().equals(name())) { return CDef.RecommendLocationTypeCd.byName(name); }
            if (RelatedProducts.name().equals(name())) { return CDef.RelatedProducts.byName(name); }
            if (RemainFlg.name().equals(name())) { return CDef.RemainFlg.byName(name); }
            if (ReplenishShape.name().equals(name())) { return CDef.ReplenishShape.byName(name); }
            if (SampleCls.name().equals(name())) { return CDef.SampleCls.byName(name); }
            if (SearchReferenceDt.name().equals(name())) { return CDef.SearchReferenceDt.byName(name); }
            if (SerialManagFlg.name().equals(name())) { return CDef.SerialManagFlg.byName(name); }
            if (ShapeGrpTypeCd.name().equals(name())) { return CDef.ShapeGrpTypeCd.byName(name); }
            if (SharedProductTypeCd.name().equals(name())) { return CDef.SharedProductTypeCd.byName(name); }
            if (ShippingInspectionHidden.name().equals(name())) { return CDef.ShippingInspectionHidden.byName(name); }
            if (ShippingInspectionStatus.name().equals(name())) { return CDef.ShippingInspectionStatus.byName(name); }
            if (ShippingProcessType.name().equals(name())) { return CDef.ShippingProcessType.byName(name); }
            if (ShippingProgress.name().equals(name())) { return CDef.ShippingProgress.byName(name); }
            if (ShippingReason.name().equals(name())) { return CDef.ShippingReason.byName(name); }
            if (ShippingReasonConvert.name().equals(name())) { return CDef.ShippingReasonConvert.byName(name); }
            if (ShippingSlipType.name().equals(name())) { return CDef.ShippingSlipType.byName(name); }
            if (ShippingType.name().equals(name())) { return CDef.ShippingType.byName(name); }
            if (ShippingWorkType.name().equals(name())) { return CDef.ShippingWorkType.byName(name); }
            if (SlipType2.name().equals(name())) { return CDef.SlipType2.byName(name); }
            if (SpareTypeCd.name().equals(name())) { return CDef.SpareTypeCd.byName(name); }
            if (SpecifiedNumOfShoes.name().equals(name())) { return CDef.SpecifiedNumOfShoes.byName(name); }
            if (SplitDeliveryTypeCd.name().equals(name())) { return CDef.SplitDeliveryTypeCd.byName(name); }
            if (StockDifference.name().equals(name())) { return CDef.StockDifference.byName(name); }
            if (StockDisplayType.name().equals(name())) { return CDef.StockDisplayType.byName(name); }
            if (StockExist.name().equals(name())) { return CDef.StockExist.byName(name); }
            if (StockProcessType.name().equals(name())) { return CDef.StockProcessType.byName(name); }
            if (StockRefCls.name().equals(name())) { return CDef.StockRefCls.byName(name); }
            if (StockTakingStatus.name().equals(name())) { return CDef.StockTakingStatus.byName(name); }
            if (StockZeroDisplay.name().equals(name())) { return CDef.StockZeroDisplay.byName(name); }
            if (SuppliesVarietyFlg.name().equals(name())) { return CDef.SuppliesVarietyFlg.byName(name); }
            if (TargetBase.name().equals(name())) { return CDef.TargetBase.byName(name); }
            if (TargetItemCd.name().equals(name())) { return CDef.TargetItemCd.byName(name); }
            if (TargetKoguchiCd.name().equals(name())) { return CDef.TargetKoguchiCd.byName(name); }
            if (TargetSalesCd.name().equals(name())) { return CDef.TargetSalesCd.byName(name); }
            if (UnitCls.name().equals(name())) { return CDef.UnitCls.byName(name); }
            if (UrgentShippingTimeZone.name().equals(name())) { return CDef.UrgentShippingTimeZone.byName(name); }
            if (WorkType.name().equals(name())) { return CDef.WorkType.byName(name); }
            if (ReceiveLabelFlg.name().equals(name())) { return CDef.ReceiveLabelFlg.byName(name); }
            if (ReceiveDtUnmatchFlg.name().equals(name())) { return CDef.ReceiveDtUnmatchFlg.byName(name); }
            if (PrintFlg.name().equals(name())) { return CDef.PrintFlg.byName(name); }
            if (ReceiveRemainFlg.name().equals(name())) { return CDef.ReceiveRemainFlg.byName(name); }
            if (ShippingPickedHidden.name().equals(name())) { return CDef.ShippingPickedHidden.byName(name); }
            if (CarrierDataOutFlg.name().equals(name())) { return CDef.CarrierDataOutFlg.byName(name); }
            if (PllOutFlg.name().equals(name())) { return CDef.PllOutFlg.byName(name); }
            if (DepositorCls.name().equals(name())) { return CDef.DepositorCls.byName(name); }
            if (RplOutFlg.name().equals(name())) { return CDef.RplOutFlg.byName(name); }
            if (RecordSendFlg.name().equals(name())) { return CDef.RecordSendFlg.byName(name); }
            if (HandOverHidden.name().equals(name())) { return CDef.HandOverHidden.byName(name); }
            if (ExternalWarehouseFlg.name().equals(name())) { return CDef.ExternalWarehouseFlg.byName(name); }
            if (StandardPlantCls.name().equals(name())) { return CDef.StandardPlantCls.byName(name); }
            if (LargeItemHadlingFlg.name().equals(name())) { return CDef.LargeItemHadlingFlg.byName(name); }
            if (HolidayCarrierFlg.name().equals(name())) { return CDef.HolidayCarrierFlg.byName(name); }
            if (OkinawaFlightFlg.name().equals(name())) { return CDef.OkinawaFlightFlg.byName(name); }
            if (BaseDefaultCarrierFlg.name().equals(name())) { return CDef.BaseDefaultCarrierFlg.byName(name); }
            if (SlipTypeCd.name().equals(name())) { return CDef.SlipTypeCd.byName(name); }
            if (ProperFlg.name().equals(name())) { return CDef.ProperFlg.byName(name); }
            if (CdlOutFlg.name().equals(name())) { return CDef.CdlOutFlg.byName(name); }
            if (ErrorNum.name().equals(name())) { return CDef.ErrorNum.byName(name); }
            if (CenterPicListCls1.name().equals(name())) { return CDef.CenterPicListCls1.byName(name); }
            if (CenterPicListCls2.name().equals(name())) { return CDef.CenterPicListCls2.byName(name); }
            if (CenterPicListCls3.name().equals(name())) { return CDef.CenterPicListCls3.byName(name); }
            if (CenterSagawaDelivTz.name().equals(name())) { return CDef.CenterSagawaDelivTz.byName(name); }
            if (CenterTransportTypeItem.name().equals(name())) { return CDef.CenterTransportTypeItem.byName(name); }
            if (CenterSlipShapeCd.name().equals(name())) { return CDef.CenterSlipShapeCd.byName(name); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return CDef.CenterTransportTypeSpeed.byName(name); }
            if (CenterSealType.name().equals(name())) { return CDef.CenterSealType.byName(name); }
            if (CenterTagClass.name().equals(name())) { return CDef.CenterTagClass.byName(name); }
            if (CenterTagDataType.name().equals(name())) { return CDef.CenterTagDataType.byName(name); }
            if (CenterTagType.name().equals(name())) { return CDef.CenterTagType.byName(name); }
            if (CenterTagTypeAfter.name().equals(name())) { return CDef.CenterTagTypeAfter.byName(name); }
            if (CenterApiBinsyuCode.name().equals(name())) { return CDef.CenterApiBinsyuCode.byName(name); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return CDef.CenterApiDaibikiFlg.byName(name); }
            if (CenterApiDaibikiType.name().equals(name())) { return CDef.CenterApiDaibikiType.byName(name); }
            if (CenterApiEidomeFlg.name().equals(name())) { return CDef.CenterApiEidomeFlg.byName(name); }
            if (CenterApiWeightCd.name().equals(name())) { return CDef.CenterApiWeightCd.byName(name); }
            if (CenterOutputTargetFlg.name().equals(name())) { return CDef.CenterOutputTargetFlg.byName(name); }
            if (CenterPrintCondition.name().equals(name())) { return CDef.CenterPrintCondition.byName(name); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        public Classification codeOf(Object code) { // null if not found, old style so use of(code)
            if (ProcessTypeCd.name().equals(name())) { return CDef.ProcessTypeCd.codeOf(code); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return CDef.AfterDelivSlipOutTgt.codeOf(code); }
            if (AfterTagOutFlg.name().equals(name())) { return CDef.AfterTagOutFlg.codeOf(code); }
            if (AllShippingFlg.name().equals(name())) { return CDef.AllShippingFlg.codeOf(code); }
            if (AllcNgDisplay.name().equals(name())) { return CDef.AllcNgDisplay.codeOf(code); }
            if (AllcNgFlg.name().equals(name())) { return CDef.AllcNgFlg.codeOf(code); }
            if (AllocSortKey.name().equals(name())) { return CDef.AllocSortKey.codeOf(code); }
            if (ArrivalStoreFormat.name().equals(name())) { return CDef.ArrivalStoreFormat.codeOf(code); }
            if (AutoEmgSetFlg.name().equals(name())) { return CDef.AutoEmgSetFlg.codeOf(code); }
            if (AutoEmgSetTgt.name().equals(name())) { return CDef.AutoEmgSetTgt.codeOf(code); }
            if (AutoPrintTargetFlg.name().equals(name())) { return CDef.AutoPrintTargetFlg.codeOf(code); }
            if (AutoShipInstFlg.name().equals(name())) { return CDef.AutoShipInstFlg.codeOf(code); }
            if (BarcodeType.name().equals(name())) { return CDef.BarcodeType.codeOf(code); }
            if (BatchProgressFlg.name().equals(name())) { return CDef.BatchProgressFlg.codeOf(code); }
            if (BoxSelectSkip.name().equals(name())) { return CDef.BoxSelectSkip.codeOf(code); }
            if (CancelDataDisplay.name().equals(name())) { return CDef.CancelDataDisplay.codeOf(code); }
            if (CasePicFlg.name().equals(name())) { return CDef.CasePicFlg.codeOf(code); }
            if (CenterClientCls.name().equals(name())) { return CDef.CenterClientCls.codeOf(code); }
            if (CenterTransitFlg.name().equals(name())) { return CDef.CenterTransitFlg.codeOf(code); }
            if (CharacterCd.name().equals(name())) { return CDef.CharacterCd.codeOf(code); }
            if (ChargeQty0Display.name().equals(name())) { return CDef.ChargeQty0Display.codeOf(code); }
            if (CheckDigit.name().equals(name())) { return CDef.CheckDigit.codeOf(code); }
            if (CodCls.name().equals(name())) { return CDef.CodCls.codeOf(code); }
            if (CodType.name().equals(name())) { return CDef.CodType.codeOf(code); }
            if (CodeFlg.name().equals(name())) { return CDef.CodeFlg.codeOf(code); }
            if (CodeType.name().equals(name())) { return CDef.CodeType.codeOf(code); }
            if (ColType.name().equals(name())) { return CDef.ColType.codeOf(code); }
            if (CommentFlg.name().equals(name())) { return CDef.CommentFlg.codeOf(code); }
            if (CompanyFlg.name().equals(name())) { return CDef.CompanyFlg.codeOf(code); }
            if (CoolCls.name().equals(name())) { return CDef.CoolCls.codeOf(code); }
            if (CoolType.name().equals(name())) { return CDef.CoolType.codeOf(code); }
            if (CorrectType.name().equals(name())) { return CDef.CorrectType.codeOf(code); }
            if (DataInputCommitType.name().equals(name())) { return CDef.DataInputCommitType.codeOf(code); }
            if (DataInputOperationType.name().equals(name())) { return CDef.DataInputOperationType.codeOf(code); }
            if (DataInputProcessType.name().equals(name())) { return CDef.DataInputProcessType.codeOf(code); }
            if (DataInputRange.name().equals(name())) { return CDef.DataInputRange.codeOf(code); }
            if (DataInputType.name().equals(name())) { return CDef.DataInputType.codeOf(code); }
            if (DataType.name().equals(name())) { return CDef.DataType.codeOf(code); }
            if (Default.name().equals(name())) { return CDef.Default.codeOf(code); }
            if (DefaultFlg.name().equals(name())) { return CDef.DefaultFlg.codeOf(code); }
            if (DelFlg.name().equals(name())) { return CDef.DelFlg.codeOf(code); }
            if (DeleteDataDisplay.name().equals(name())) { return CDef.DeleteDataDisplay.codeOf(code); }
            if (DelivMatchFlg.name().equals(name())) { return CDef.DelivMatchFlg.codeOf(code); }
            if (DelivTz.name().equals(name())) { return CDef.DelivTz.codeOf(code); }
            if (DeliveryFlg.name().equals(name())) { return CDef.DeliveryFlg.codeOf(code); }
            if (DepositFlg.name().equals(name())) { return CDef.DepositFlg.codeOf(code); }
            if (DisplayRequired.name().equals(name())) { return CDef.DisplayRequired.codeOf(code); }
            if (DtCls.name().equals(name())) { return CDef.DtCls.codeOf(code); }
            if (Editable.name().equals(name())) { return CDef.Editable.codeOf(code); }
            if (EmergencyDisplay.name().equals(name())) { return CDef.EmergencyDisplay.codeOf(code); }
            if (EmergencyFlg.name().equals(name())) { return CDef.EmergencyFlg.codeOf(code); }
            if (ErrorFlg.name().equals(name())) { return CDef.ErrorFlg.codeOf(code); }
            if (ErrorProcessMet.name().equals(name())) { return CDef.ErrorProcessMet.codeOf(code); }
            if (FixedPoint.name().equals(name())) { return CDef.FixedPoint.codeOf(code); }
            if (ForceFixedFlg.name().equals(name())) { return CDef.ForceFixedFlg.codeOf(code); }
            if (ForeignFlg.name().equals(name())) { return CDef.ForeignFlg.codeOf(code); }
            if (GiftFlg.name().equals(name())) { return CDef.GiftFlg.codeOf(code); }
            if (GiftStatementType.name().equals(name())) { return CDef.GiftStatementType.codeOf(code); }
            if (HtCharReadFlg.name().equals(name())) { return CDef.HtCharReadFlg.codeOf(code); }
            if (ImportFlg.name().equals(name())) { return CDef.ImportFlg.codeOf(code); }
            if (InfoFlg.name().equals(name())) { return CDef.InfoFlg.codeOf(code); }
            if (InoutType.name().equals(name())) { return CDef.InoutType.codeOf(code); }
            if (InputType.name().equals(name())) { return CDef.InputType.codeOf(code); }
            if (InspectionFlg.name().equals(name())) { return CDef.InspectionFlg.codeOf(code); }
            if (InventoryLocationProduct.name().equals(name())) { return CDef.InventoryLocationProduct.codeOf(code); }
            if (InvoiceCreateFlg.name().equals(name())) { return CDef.InvoiceCreateFlg.codeOf(code); }
            if (ItemType.name().equals(name())) { return CDef.ItemType.codeOf(code); }
            if (LastFlg.name().equals(name())) { return CDef.LastFlg.codeOf(code); }
            if (LimitDtManagFlg.name().equals(name())) { return CDef.LimitDtManagFlg.codeOf(code); }
            if (LimitDtReverseFlg.name().equals(name())) { return CDef.LimitDtReverseFlg.codeOf(code); }
            if (LimitMessageCd.name().equals(name())) { return CDef.LimitMessageCd.codeOf(code); }
            if (LineFeedCd.name().equals(name())) { return CDef.LineFeedCd.codeOf(code); }
            if (ListOutFlg.name().equals(name())) { return CDef.ListOutFlg.codeOf(code); }
            if (ListOutKbn.name().equals(name())) { return CDef.ListOutKbn.codeOf(code); }
            if (ListOutFlgDisp.name().equals(name())) { return CDef.ListOutFlgDisp.codeOf(code); }
            if (LoadingFlg.name().equals(name())) { return CDef.LoadingFlg.codeOf(code); }
            if (LocationType.name().equals(name())) { return CDef.LocationType.codeOf(code); }
            if (Lockout.name().equals(name())) { return CDef.Lockout.codeOf(code); }
            if (LogDtlStatus.name().equals(name())) { return CDef.LogDtlStatus.codeOf(code); }
            if (LogDtlType.name().equals(name())) { return CDef.LogDtlType.codeOf(code); }
            if (LogStatus.name().equals(name())) { return CDef.LogStatus.codeOf(code); }
            if (LotManagFlg.name().equals(name())) { return CDef.LotManagFlg.codeOf(code); }
            if (LotReverseFlg.name().equals(name())) { return CDef.LotReverseFlg.codeOf(code); }
            if (MergeCls.name().equals(name())) { return CDef.MergeCls.codeOf(code); }
            if (MergeFlg.name().equals(name())) { return CDef.MergeFlg.codeOf(code); }
            if (MessageType.name().equals(name())) { return CDef.MessageType.codeOf(code); }
            if (MixedFlg.name().equals(name())) { return CDef.MixedFlg.codeOf(code); }
            if (MoveInstStatus.name().equals(name())) { return CDef.MoveInstStatus.codeOf(code); }
            if (MultiPicCls.name().equals(name())) { return CDef.MultiPicCls.codeOf(code); }
            if (MultiPicFlg.name().equals(name())) { return CDef.MultiPicFlg.codeOf(code); }
            if (Necessary.name().equals(name())) { return CDef.Necessary.codeOf(code); }
            if (NoAllcDisplayFlg.name().equals(name())) { return CDef.NoAllcDisplayFlg.codeOf(code); }
            if (NoConfirmedFlg.name().equals(name())) { return CDef.NoConfirmedFlg.codeOf(code); }
            if (NoStockCls.name().equals(name())) { return CDef.NoStockCls.codeOf(code); }
            if (NoStockOutFlg.name().equals(name())) { return CDef.NoStockOutFlg.codeOf(code); }
            if (NoUpsideDownCls.name().equals(name())) { return CDef.NoUpsideDownCls.codeOf(code); }
            if (NotCompletedFlg.name().equals(name())) { return CDef.NotCompletedFlg.codeOf(code); }
            if (OnetimeFlg.name().equals(name())) { return CDef.OnetimeFlg.codeOf(code); }
            if (OverStoreNumFlg.name().equals(name())) { return CDef.OverStoreNumFlg.codeOf(code); }
            if (PackingCalCls.name().equals(name())) { return CDef.PackingCalCls.codeOf(code); }
            if (PackingProcessCls.name().equals(name())) { return CDef.PackingProcessCls.codeOf(code); }
            if (PackingShowFlg.name().equals(name())) { return CDef.PackingShowFlg.codeOf(code); }
            if (PackingStatus.name().equals(name())) { return CDef.PackingStatus.codeOf(code); }
            if (PasswordReset.name().equals(name())) { return CDef.PasswordReset.codeOf(code); }
            if (PastStoreDtFlg.name().equals(name())) { return CDef.PastStoreDtFlg.codeOf(code); }
            if (PhysicalDelete.name().equals(name())) { return CDef.PhysicalDelete.codeOf(code); }
            if (PicCls.name().equals(name())) { return CDef.PicCls.codeOf(code); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return CDef.PicMthdRcmdBreakKey.codeOf(code); }
            if (PicMthdRcmdFlg.name().equals(name())) { return CDef.PicMthdRcmdFlg.codeOf(code); }
            if (PicMthdRcmdListOut.name().equals(name())) { return CDef.PicMthdRcmdListOut.codeOf(code); }
            if (PickingFlg.name().equals(name())) { return CDef.PickingFlg.codeOf(code); }
            if (PickingLocationFlg.name().equals(name())) { return CDef.PickingLocationFlg.codeOf(code); }
            if (PickingStatus.name().equals(name())) { return CDef.PickingStatus.codeOf(code); }
            if (PickingType.name().equals(name())) { return CDef.PickingType.codeOf(code); }
            if (PostType.name().equals(name())) { return CDef.PostType.codeOf(code); }
            if (PrintDataType.name().equals(name())) { return CDef.PrintDataType.codeOf(code); }
            if (PrintErrorFlg.name().equals(name())) { return CDef.PrintErrorFlg.codeOf(code); }
            if (PrintQueueStatus.name().equals(name())) { return CDef.PrintQueueStatus.codeOf(code); }
            if (PrintResultClass.name().equals(name())) { return CDef.PrintResultClass.codeOf(code); }
            if (PrintServiceStatus.name().equals(name())) { return CDef.PrintServiceStatus.codeOf(code); }
            if (PrintStatus.name().equals(name())) { return CDef.PrintStatus.codeOf(code); }
            if (PrintedFlg.name().equals(name())) { return CDef.PrintedFlg.codeOf(code); }
            if (PriorityFlg.name().equals(name())) { return CDef.PriorityFlg.codeOf(code); }
            if (ProductLabelJanBarcode.name().equals(name())) { return CDef.ProductLabelJanBarcode.codeOf(code); }
            if (ProductLabelOutUnit.name().equals(name())) { return CDef.ProductLabelOutUnit.codeOf(code); }
            if (ProductLabelProdBarcode.name().equals(name())) { return CDef.ProductLabelProdBarcode.codeOf(code); }
            if (ProductPartPacking.name().equals(name())) { return CDef.ProductPartPacking.codeOf(code); }
            if (ProductTypeCode.name().equals(name())) { return CDef.ProductTypeCode.codeOf(code); }
            if (Qty0Display.name().equals(name())) { return CDef.Qty0Display.codeOf(code); }
            if (ReasonType.name().equals(name())) { return CDef.ReasonType.codeOf(code); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return CDef.ReceiveDeliveryStatus.codeOf(code); }
            if (ReceiveFlg.name().equals(name())) { return CDef.ReceiveFlg.codeOf(code); }
            if (ReceiveStatus.name().equals(name())) { return CDef.ReceiveStatus.codeOf(code); }
            if (ReplenishAllocCls.name().equals(name())) { return CDef.ReplenishAllocCls.codeOf(code); }
            if (ReplenishProductCdUnset.name().equals(name())) { return CDef.ReplenishProductCdUnset.codeOf(code); }
            if (ReplenishSearchCls.name().equals(name())) { return CDef.ReplenishSearchCls.codeOf(code); }
            if (ReplenishUnitCls.name().equals(name())) { return CDef.ReplenishUnitCls.codeOf(code); }
            if (ReportLayoutItemType.name().equals(name())) { return CDef.ReportLayoutItemType.codeOf(code); }
            if (RestockType.name().equals(name())) { return CDef.RestockType.codeOf(code); }
            if (ResultAfterProductLabel.name().equals(name())) { return CDef.ResultAfterProductLabel.codeOf(code); }
            if (ReverseValidFlg.name().equals(name())) { return CDef.ReverseValidFlg.codeOf(code); }
            if (Select.name().equals(name())) { return CDef.Select.codeOf(code); }
            if (SelectPrintServiceStatus.name().equals(name())) { return CDef.SelectPrintServiceStatus.codeOf(code); }
            if (SerialOperationType.name().equals(name())) { return CDef.SerialOperationType.codeOf(code); }
            if (TargetWindow.name().equals(name())) { return CDef.TargetWindow.codeOf(code); }
            if (SettlementType.name().equals(name())) { return CDef.SettlementType.codeOf(code); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return CDef.SglRowInspAfterOutCls.codeOf(code); }
            if (SglRowPicFlg.name().equals(name())) { return CDef.SglRowPicFlg.codeOf(code); }
            if (SheetCollate.name().equals(name())) { return CDef.SheetCollate.codeOf(code); }
            if (ShippingFlg.name().equals(name())) { return CDef.ShippingFlg.codeOf(code); }
            if (ShippingStatus.name().equals(name())) { return CDef.ShippingStatus.codeOf(code); }
            if (ShippingStopFlg.name().equals(name())) { return CDef.ShippingStopFlg.codeOf(code); }
            if (ShortStockDisplay.name().equals(name())) { return CDef.ShortStockDisplay.codeOf(code); }
            if (ShpCheckCls.name().equals(name())) { return CDef.ShpCheckCls.codeOf(code); }
            if (ShpCheckDisplay.name().equals(name())) { return CDef.ShpCheckDisplay.codeOf(code); }
            if (SlipType.name().equals(name())) { return CDef.SlipType.codeOf(code); }
            if (SoundPlayFlg.name().equals(name())) { return CDef.SoundPlayFlg.codeOf(code); }
            if (StockAdjustFlg.name().equals(name())) { return CDef.StockAdjustFlg.codeOf(code); }
            if (StockDisplayFld.name().equals(name())) { return CDef.StockDisplayFld.codeOf(code); }
            if (StockExistOnlyFlg.name().equals(name())) { return CDef.StockExistOnlyFlg.codeOf(code); }
            if (StockMoveFlg.name().equals(name())) { return CDef.StockMoveFlg.codeOf(code); }
            if (StockNum0Display.name().equals(name())) { return CDef.StockNum0Display.codeOf(code); }
            if (StockOutAllocCls.name().equals(name())) { return CDef.StockOutAllocCls.codeOf(code); }
            if (StockOutAutoInstFlg.name().equals(name())) { return CDef.StockOutAutoInstFlg.codeOf(code); }
            if (StockOutFlg.name().equals(name())) { return CDef.StockOutFlg.codeOf(code); }
            if (StockOutInstCxlFlg.name().equals(name())) { return CDef.StockOutInstCxlFlg.codeOf(code); }
            if (StockOutInstSplitFlg.name().equals(name())) { return CDef.StockOutInstSplitFlg.codeOf(code); }
            if (StockQtyDisplay.name().equals(name())) { return CDef.StockQtyDisplay.codeOf(code); }
            if (StockTakingInput.name().equals(name())) { return CDef.StockTakingInput.codeOf(code); }
            if (StockTarget.name().equals(name())) { return CDef.StockTarget.codeOf(code); }
            if (StoreDtFlg.name().equals(name())) { return CDef.StoreDtFlg.codeOf(code); }
            if (StoreFlg.name().equals(name())) { return CDef.StoreFlg.codeOf(code); }
            if (StoreNoDivideDisplay.name().equals(name())) { return CDef.StoreNoDivideDisplay.codeOf(code); }
            if (StoreNoFlg.name().equals(name())) { return CDef.StoreNoFlg.codeOf(code); }
            if (StoreNoMergeFlg.name().equals(name())) { return CDef.StoreNoMergeFlg.codeOf(code); }
            if (SystemLogStatus.name().equals(name())) { return CDef.SystemLogStatus.codeOf(code); }
            if (SystemLogType.name().equals(name())) { return CDef.SystemLogType.codeOf(code); }
            if (SystemType.name().equals(name())) { return CDef.SystemType.codeOf(code); }
            if (TagDeliveryOutFlg.name().equals(name())) { return CDef.TagDeliveryOutFlg.codeOf(code); }
            if (TakingShippingDtFlg.name().equals(name())) { return CDef.TakingShippingDtFlg.codeOf(code); }
            if (TakingShippingFlg.name().equals(name())) { return CDef.TakingShippingFlg.codeOf(code); }
            if (TextAlign.name().equals(name())) { return CDef.TextAlign.codeOf(code); }
            if (TotalPicFlg.name().equals(name())) { return CDef.TotalPicFlg.codeOf(code); }
            if (TrackingNumberingUnit.name().equals(name())) { return CDef.TrackingNumberingUnit.codeOf(code); }
            if (TransitDisplay.name().equals(name())) { return CDef.TransitDisplay.codeOf(code); }
            if (Unmatch.name().equals(name())) { return CDef.Unmatch.codeOf(code); }
            if (UpdCd.name().equals(name())) { return CDef.UpdCd.codeOf(code); }
            if (UpdType.name().equals(name())) { return CDef.UpdType.codeOf(code); }
            if (Updatable.name().equals(name())) { return CDef.Updatable.codeOf(code); }
            if (UploadTableNm.name().equals(name())) { return CDef.UploadTableNm.codeOf(code); }
            if (UseHtShipFlg.name().equals(name())) { return CDef.UseHtShipFlg.codeOf(code); }
            if (UserEditable.name().equals(name())) { return CDef.UserEditable.codeOf(code); }
            if (VendorFlg.name().equals(name())) { return CDef.VendorFlg.codeOf(code); }
            if (Visible.name().equals(name())) { return CDef.Visible.codeOf(code); }
            if (WorkFlg.name().equals(name())) { return CDef.WorkFlg.codeOf(code); }
            if (WorkMessageFlg.name().equals(name())) { return CDef.WorkMessageFlg.codeOf(code); }
            if (YamatoDelivTz.name().equals(name())) { return CDef.YamatoDelivTz.codeOf(code); }
            if (YupackDelivTz.name().equals(name())) { return CDef.YupackDelivTz.codeOf(code); }
            if (ZipFlg.name().equals(name())) { return CDef.ZipFlg.codeOf(code); }
            if (ResultAfterProductTarget.name().equals(name())) { return CDef.ResultAfterProductTarget.codeOf(code); }
            if (CopyTargetTable.name().equals(name())) { return CDef.CopyTargetTable.codeOf(code); }
            if (InspectionLabelOutFlg.name().equals(name())) { return CDef.InspectionLabelOutFlg.codeOf(code); }
            if (DecimalProductPacking.name().equals(name())) { return CDef.DecimalProductPacking.codeOf(code); }
            if (DecimalExistFlg.name().equals(name())) { return CDef.DecimalExistFlg.codeOf(code); }
            if (CasePickFlg.name().equals(name())) { return CDef.CasePickFlg.codeOf(code); }
            if (EmReplenishShapeFlg.name().equals(name())) { return CDef.EmReplenishShapeFlg.codeOf(code); }
            if (WorkStatus.name().equals(name())) { return CDef.WorkStatus.codeOf(code); }
            if (WorkLogOutFlg.name().equals(name())) { return CDef.WorkLogOutFlg.codeOf(code); }
            if (RoleControlClass.name().equals(name())) { return CDef.RoleControlClass.codeOf(code); }
            if (BolOutFlg.name().equals(name())) { return CDef.BolOutFlg.codeOf(code); }
            if (BolOutputTargetFlg.name().equals(name())) { return CDef.BolOutputTargetFlg.codeOf(code); }
            if (PaymentTerm.name().equals(name())) { return CDef.PaymentTerm.codeOf(code); }
            if (CesIntegrationFlg.name().equals(name())) { return CDef.CesIntegrationFlg.codeOf(code); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return CDef.PackingSlipAutoOutputFlg.codeOf(code); }
            if (FreightCls.name().equals(name())) { return CDef.FreightCls.codeOf(code); }
            if (SatDeliveryFlg.name().equals(name())) { return CDef.SatDeliveryFlg.codeOf(code); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return CDef.ResidentialDeliveryFlg.codeOf(code); }
            if (CodFlg.name().equals(name())) { return CDef.CodFlg.codeOf(code); }
            if (SignatureRequiredFlg.name().equals(name())) { return CDef.SignatureRequiredFlg.codeOf(code); }
            if (SignatureReleaseFlg.name().equals(name())) { return CDef.SignatureReleaseFlg.codeOf(code); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return CDef.CallBeforeDeliveryFlg.codeOf(code); }
            if (FreezableProtectionFlg.name().equals(name())) { return CDef.FreezableProtectionFlg.codeOf(code); }
            if (GuaranteedPlusFlg.name().equals(name())) { return CDef.GuaranteedPlusFlg.codeOf(code); }
            if (ResidentialPickupFlg.name().equals(name())) { return CDef.ResidentialPickupFlg.codeOf(code); }
            if (DoNotStackStackFlg.name().equals(name())) { return CDef.DoNotStackStackFlg.codeOf(code); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return CDef.LimitedAccessDeliveryFlg.codeOf(code); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return CDef.LimitedAccessPickupFlg.codeOf(code); }
            if (OverSizedFlg.name().equals(name())) { return CDef.OverSizedFlg.codeOf(code); }
            if (PoisonFlg.name().equals(name())) { return CDef.PoisonFlg.codeOf(code); }
            if (FoogFlg.name().equals(name())) { return CDef.FoogFlg.codeOf(code); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return CDef.LiftgateDeliveryPrepaidFlg.codeOf(code); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return CDef.LiftgateDeliveryCollectFlg.codeOf(code); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return CDef.LiftgatePickupPrepaidFlg.codeOf(code); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return CDef.LiftgatePickupCollectFlg.codeOf(code); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return CDef.InsideDeliveryPrepaidFlg.codeOf(code); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return CDef.InsideDeliveryCollectFlg.codeOf(code); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return CDef.InsidePickupPrepaidFlg.codeOf(code); }
            if (InsidePickupCollectFlg.name().equals(name())) { return CDef.InsidePickupCollectFlg.codeOf(code); }
            if (RcmdPickingCls.name().equals(name())) { return CDef.RcmdPickingCls.codeOf(code); }
            if (SglRowPicTarget.name().equals(name())) { return CDef.SglRowPicTarget.codeOf(code); }
            if (CasePicTarget.name().equals(name())) { return CDef.CasePicTarget.codeOf(code); }
            if (AttendanceLeavingRest.name().equals(name())) { return CDef.AttendanceLeavingRest.codeOf(code); }
            if (UploadZipType.name().equals(name())) { return CDef.UploadZipType.codeOf(code); }
            if (FwType.name().equals(name())) { return CDef.FwType.codeOf(code); }
            if (McaType.name().equals(name())) { return CDef.McaType.codeOf(code); }
            if (AccountFlg.name().equals(name())) { return CDef.AccountFlg.codeOf(code); }
            if (AlarmReasonCls.name().equals(name())) { return CDef.AlarmReasonCls.codeOf(code); }
            if (AlarmType.name().equals(name())) { return CDef.AlarmType.codeOf(code); }
            if (AreaCls.name().equals(name())) { return CDef.AreaCls.codeOf(code); }
            if (AssortStatus.name().equals(name())) { return CDef.AssortStatus.codeOf(code); }
            if (BaseCls.name().equals(name())) { return CDef.BaseCls.codeOf(code); }
            if (BoxType.name().equals(name())) { return CDef.BoxType.codeOf(code); }
            if (CarrierType.name().equals(name())) { return CDef.CarrierType.codeOf(code); }
            if (CarrierTypeCd.name().equals(name())) { return CDef.CarrierTypeCd.codeOf(code); }
            if (CaseTypeCd.name().equals(name())) { return CDef.CaseTypeCd.codeOf(code); }
            if (ClosingDt.name().equals(name())) { return CDef.ClosingDt.codeOf(code); }
            if (CompletedHidden.name().equals(name())) { return CDef.CompletedHidden.codeOf(code); }
            if (Condition.name().equals(name())) { return CDef.Condition.codeOf(code); }
            if (Constract.name().equals(name())) { return CDef.Constract.codeOf(code); }
            if (CsPsType.name().equals(name())) { return CDef.CsPsType.codeOf(code); }
            if (DefaultStockType.name().equals(name())) { return CDef.DefaultStockType.codeOf(code); }
            if (DelivCenterFrom.name().equals(name())) { return CDef.DelivCenterFrom.codeOf(code); }
            if (DelivCenterTo.name().equals(name())) { return CDef.DelivCenterTo.codeOf(code); }
            if (DeliveryDtUnspecified.name().equals(name())) { return CDef.DeliveryDtUnspecified.codeOf(code); }
            if (DeliveryTimeZone.name().equals(name())) { return CDef.DeliveryTimeZone.codeOf(code); }
            if (DeliveryTypeSendCls.name().equals(name())) { return CDef.DeliveryTypeSendCls.codeOf(code); }
            if (DepositItemFlg.name().equals(name())) { return CDef.DepositItemFlg.codeOf(code); }
            if (DepositType.name().equals(name())) { return CDef.DepositType.codeOf(code); }
            if (DiffCls.name().equals(name())) { return CDef.DiffCls.codeOf(code); }
            if (DirectDeliveryTypeCd.name().equals(name())) { return CDef.DirectDeliveryTypeCd.codeOf(code); }
            if (EcOrder.name().equals(name())) { return CDef.EcOrder.codeOf(code); }
            if (EcType.name().equals(name())) { return CDef.EcType.codeOf(code); }
            if (ExecuteStatus.name().equals(name())) { return CDef.ExecuteStatus.codeOf(code); }
            if (Fee.name().equals(name())) { return CDef.Fee.codeOf(code); }
            if (Floor.name().equals(name())) { return CDef.Floor.codeOf(code); }
            if (FloorCd.name().equals(name())) { return CDef.FloorCd.codeOf(code); }
            if (FloorEndFlg.name().equals(name())) { return CDef.FloorEndFlg.codeOf(code); }
            if (FloorTypeCd.name().equals(name())) { return CDef.FloorTypeCd.codeOf(code); }
            if (HandOverStatus.name().equals(name())) { return CDef.HandOverStatus.codeOf(code); }
            if (HandlingType.name().equals(name())) { return CDef.HandlingType.codeOf(code); }
            if (HeavyItemFlg.name().equals(name())) { return CDef.HeavyItemFlg.codeOf(code); }
            if (HeavyItemHadlingFlg.name().equals(name())) { return CDef.HeavyItemHadlingFlg.codeOf(code); }
            if (HinmokuGroupCd.name().equals(name())) { return CDef.HinmokuGroupCd.codeOf(code); }
            if (HolidayFlg.name().equals(name())) { return CDef.HolidayFlg.codeOf(code); }
            if (IdManagAbolitionTypeCd.name().equals(name())) { return CDef.IdManagAbolitionTypeCd.codeOf(code); }
            if (InsuranceFlg.name().equals(name())) { return CDef.InsuranceFlg.codeOf(code); }
            if (InventoryDataStatus.name().equals(name())) { return CDef.InventoryDataStatus.codeOf(code); }
            if (InventoryDiffCls.name().equals(name())) { return CDef.InventoryDiffCls.codeOf(code); }
            if (InventoryInputCls.name().equals(name())) { return CDef.InventoryInputCls.codeOf(code); }
            if (InventoryListOutCls.name().equals(name())) { return CDef.InventoryListOutCls.codeOf(code); }
            if (InventoryListType.name().equals(name())) { return CDef.InventoryListType.codeOf(code); }
            if (ItManagType.name().equals(name())) { return CDef.ItManagType.codeOf(code); }
            if (ItemDensan.name().equals(name())) { return CDef.ItemDensan.codeOf(code); }
            if (LargeItemFlg.name().equals(name())) { return CDef.LargeItemFlg.codeOf(code); }
            if (LimitDtSplitTypeCd.name().equals(name())) { return CDef.LimitDtSplitTypeCd.codeOf(code); }
            if (LimitDtUnmatchTypeCd.name().equals(name())) { return CDef.LimitDtUnmatchTypeCd.codeOf(code); }
            if (LogiAttentionTypeCd.name().equals(name())) { return CDef.LogiAttentionTypeCd.codeOf(code); }
            if (LogiSpecialTypeCd.name().equals(name())) { return CDef.LogiSpecialTypeCd.codeOf(code); }
            if (LogiWeightFlg.name().equals(name())) { return CDef.LogiWeightFlg.codeOf(code); }
            if (LotSplitTypeCd.name().equals(name())) { return CDef.LotSplitTypeCd.codeOf(code); }
            if (LotUnmatchTypeCd.name().equals(name())) { return CDef.LotUnmatchTypeCd.codeOf(code); }
            if (MaxStoreShape.name().equals(name())) { return CDef.MaxStoreShape.codeOf(code); }
            if (MedicalManagFlg.name().equals(name())) { return CDef.MedicalManagFlg.codeOf(code); }
            if (MoveDirection.name().equals(name())) { return CDef.MoveDirection.codeOf(code); }
            if (NationalHolidayCarrier.name().equals(name())) { return CDef.NationalHolidayCarrier.codeOf(code); }
            if (NationalHolidayFlg.name().equals(name())) { return CDef.NationalHolidayFlg.codeOf(code); }
            if (NizoroeProcessId.name().equals(name())) { return CDef.NizoroeProcessId.codeOf(code); }
            if (NizoroeProcessIdWms.name().equals(name())) { return CDef.NizoroeProcessIdWms.codeOf(code); }
            if (NizoroeTime.name().equals(name())) { return CDef.NizoroeTime.codeOf(code); }
            if (NizoroeType.name().equals(name())) { return CDef.NizoroeType.codeOf(code); }
            if (NizoroeTypeWms.name().equals(name())) { return CDef.NizoroeTypeWms.codeOf(code); }
            if (NoOkinawaFlightFlg.name().equals(name())) { return CDef.NoOkinawaFlightFlg.codeOf(code); }
            if (OcrDateFormat.name().equals(name())) { return CDef.OcrDateFormat.codeOf(code); }
            if (OutputListType.name().equals(name())) { return CDef.OutputListType.codeOf(code); }
            if (OutputMonth.name().equals(name())) { return CDef.OutputMonth.codeOf(code); }
            if (OutputStatus.name().equals(name())) { return CDef.OutputStatus.codeOf(code); }
            if (PaymentTypeCd.name().equals(name())) { return CDef.PaymentTypeCd.codeOf(code); }
            if (PickingPatternCd.name().equals(name())) { return CDef.PickingPatternCd.codeOf(code); }
            if (Prefecture.name().equals(name())) { return CDef.Prefecture.codeOf(code); }
            if (PriceDiffHidden.name().equals(name())) { return CDef.PriceDiffHidden.codeOf(code); }
            if (ProdDtManagFlg.name().equals(name())) { return CDef.ProdDtManagFlg.codeOf(code); }
            if (ProdDtSplitTypeCd.name().equals(name())) { return CDef.ProdDtSplitTypeCd.codeOf(code); }
            if (ProdDtUnmatchTypeCd.name().equals(name())) { return CDef.ProdDtUnmatchTypeCd.codeOf(code); }
            if (ProductCategoryConvertCls.name().equals(name())) { return CDef.ProductCategoryConvertCls.codeOf(code); }
            if (ProductCategoryPlant.name().equals(name())) { return CDef.ProductCategoryPlant.codeOf(code); }
            if (ProductCategoryType.name().equals(name())) { return CDef.ProductCategoryType.codeOf(code); }
            if (ProductStoreStatus.name().equals(name())) { return CDef.ProductStoreStatus.codeOf(code); }
            if (ProductUnitCls.name().equals(name())) { return CDef.ProductUnitCls.codeOf(code); }
            if (ReceiveReason.name().equals(name())) { return CDef.ReceiveReason.codeOf(code); }
            if (ReceiveReasonConvert.name().equals(name())) { return CDef.ReceiveReasonConvert.codeOf(code); }
            if (ReceiveReasonDepositReceive.name().equals(name())) { return CDef.ReceiveReasonDepositReceive.codeOf(code); }
            if (ReceiveStatus01.name().equals(name())) { return CDef.ReceiveStatus01.codeOf(code); }
            if (RecommendLocationTypeCd.name().equals(name())) { return CDef.RecommendLocationTypeCd.codeOf(code); }
            if (RelatedProducts.name().equals(name())) { return CDef.RelatedProducts.codeOf(code); }
            if (RemainFlg.name().equals(name())) { return CDef.RemainFlg.codeOf(code); }
            if (ReplenishShape.name().equals(name())) { return CDef.ReplenishShape.codeOf(code); }
            if (SampleCls.name().equals(name())) { return CDef.SampleCls.codeOf(code); }
            if (SearchReferenceDt.name().equals(name())) { return CDef.SearchReferenceDt.codeOf(code); }
            if (SerialManagFlg.name().equals(name())) { return CDef.SerialManagFlg.codeOf(code); }
            if (ShapeGrpTypeCd.name().equals(name())) { return CDef.ShapeGrpTypeCd.codeOf(code); }
            if (SharedProductTypeCd.name().equals(name())) { return CDef.SharedProductTypeCd.codeOf(code); }
            if (ShippingInspectionHidden.name().equals(name())) { return CDef.ShippingInspectionHidden.codeOf(code); }
            if (ShippingInspectionStatus.name().equals(name())) { return CDef.ShippingInspectionStatus.codeOf(code); }
            if (ShippingProcessType.name().equals(name())) { return CDef.ShippingProcessType.codeOf(code); }
            if (ShippingProgress.name().equals(name())) { return CDef.ShippingProgress.codeOf(code); }
            if (ShippingReason.name().equals(name())) { return CDef.ShippingReason.codeOf(code); }
            if (ShippingReasonConvert.name().equals(name())) { return CDef.ShippingReasonConvert.codeOf(code); }
            if (ShippingSlipType.name().equals(name())) { return CDef.ShippingSlipType.codeOf(code); }
            if (ShippingType.name().equals(name())) { return CDef.ShippingType.codeOf(code); }
            if (ShippingWorkType.name().equals(name())) { return CDef.ShippingWorkType.codeOf(code); }
            if (SlipType2.name().equals(name())) { return CDef.SlipType2.codeOf(code); }
            if (SpareTypeCd.name().equals(name())) { return CDef.SpareTypeCd.codeOf(code); }
            if (SpecifiedNumOfShoes.name().equals(name())) { return CDef.SpecifiedNumOfShoes.codeOf(code); }
            if (SplitDeliveryTypeCd.name().equals(name())) { return CDef.SplitDeliveryTypeCd.codeOf(code); }
            if (StockDifference.name().equals(name())) { return CDef.StockDifference.codeOf(code); }
            if (StockDisplayType.name().equals(name())) { return CDef.StockDisplayType.codeOf(code); }
            if (StockExist.name().equals(name())) { return CDef.StockExist.codeOf(code); }
            if (StockProcessType.name().equals(name())) { return CDef.StockProcessType.codeOf(code); }
            if (StockRefCls.name().equals(name())) { return CDef.StockRefCls.codeOf(code); }
            if (StockTakingStatus.name().equals(name())) { return CDef.StockTakingStatus.codeOf(code); }
            if (StockZeroDisplay.name().equals(name())) { return CDef.StockZeroDisplay.codeOf(code); }
            if (SuppliesVarietyFlg.name().equals(name())) { return CDef.SuppliesVarietyFlg.codeOf(code); }
            if (TargetBase.name().equals(name())) { return CDef.TargetBase.codeOf(code); }
            if (TargetItemCd.name().equals(name())) { return CDef.TargetItemCd.codeOf(code); }
            if (TargetKoguchiCd.name().equals(name())) { return CDef.TargetKoguchiCd.codeOf(code); }
            if (TargetSalesCd.name().equals(name())) { return CDef.TargetSalesCd.codeOf(code); }
            if (UnitCls.name().equals(name())) { return CDef.UnitCls.codeOf(code); }
            if (UrgentShippingTimeZone.name().equals(name())) { return CDef.UrgentShippingTimeZone.codeOf(code); }
            if (WorkType.name().equals(name())) { return CDef.WorkType.codeOf(code); }
            if (ReceiveLabelFlg.name().equals(name())) { return CDef.ReceiveLabelFlg.codeOf(code); }
            if (ReceiveDtUnmatchFlg.name().equals(name())) { return CDef.ReceiveDtUnmatchFlg.codeOf(code); }
            if (PrintFlg.name().equals(name())) { return CDef.PrintFlg.codeOf(code); }
            if (ReceiveRemainFlg.name().equals(name())) { return CDef.ReceiveRemainFlg.codeOf(code); }
            if (ShippingPickedHidden.name().equals(name())) { return CDef.ShippingPickedHidden.codeOf(code); }
            if (CarrierDataOutFlg.name().equals(name())) { return CDef.CarrierDataOutFlg.codeOf(code); }
            if (PllOutFlg.name().equals(name())) { return CDef.PllOutFlg.codeOf(code); }
            if (DepositorCls.name().equals(name())) { return CDef.DepositorCls.codeOf(code); }
            if (RplOutFlg.name().equals(name())) { return CDef.RplOutFlg.codeOf(code); }
            if (RecordSendFlg.name().equals(name())) { return CDef.RecordSendFlg.codeOf(code); }
            if (HandOverHidden.name().equals(name())) { return CDef.HandOverHidden.codeOf(code); }
            if (ExternalWarehouseFlg.name().equals(name())) { return CDef.ExternalWarehouseFlg.codeOf(code); }
            if (StandardPlantCls.name().equals(name())) { return CDef.StandardPlantCls.codeOf(code); }
            if (LargeItemHadlingFlg.name().equals(name())) { return CDef.LargeItemHadlingFlg.codeOf(code); }
            if (HolidayCarrierFlg.name().equals(name())) { return CDef.HolidayCarrierFlg.codeOf(code); }
            if (OkinawaFlightFlg.name().equals(name())) { return CDef.OkinawaFlightFlg.codeOf(code); }
            if (BaseDefaultCarrierFlg.name().equals(name())) { return CDef.BaseDefaultCarrierFlg.codeOf(code); }
            if (SlipTypeCd.name().equals(name())) { return CDef.SlipTypeCd.codeOf(code); }
            if (ProperFlg.name().equals(name())) { return CDef.ProperFlg.codeOf(code); }
            if (CdlOutFlg.name().equals(name())) { return CDef.CdlOutFlg.codeOf(code); }
            if (ErrorNum.name().equals(name())) { return CDef.ErrorNum.codeOf(code); }
            if (CenterPicListCls1.name().equals(name())) { return CDef.CenterPicListCls1.codeOf(code); }
            if (CenterPicListCls2.name().equals(name())) { return CDef.CenterPicListCls2.codeOf(code); }
            if (CenterPicListCls3.name().equals(name())) { return CDef.CenterPicListCls3.codeOf(code); }
            if (CenterSagawaDelivTz.name().equals(name())) { return CDef.CenterSagawaDelivTz.codeOf(code); }
            if (CenterTransportTypeItem.name().equals(name())) { return CDef.CenterTransportTypeItem.codeOf(code); }
            if (CenterSlipShapeCd.name().equals(name())) { return CDef.CenterSlipShapeCd.codeOf(code); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return CDef.CenterTransportTypeSpeed.codeOf(code); }
            if (CenterSealType.name().equals(name())) { return CDef.CenterSealType.codeOf(code); }
            if (CenterTagClass.name().equals(name())) { return CDef.CenterTagClass.codeOf(code); }
            if (CenterTagDataType.name().equals(name())) { return CDef.CenterTagDataType.codeOf(code); }
            if (CenterTagType.name().equals(name())) { return CDef.CenterTagType.codeOf(code); }
            if (CenterTagTypeAfter.name().equals(name())) { return CDef.CenterTagTypeAfter.codeOf(code); }
            if (CenterApiBinsyuCode.name().equals(name())) { return CDef.CenterApiBinsyuCode.codeOf(code); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return CDef.CenterApiDaibikiFlg.codeOf(code); }
            if (CenterApiDaibikiType.name().equals(name())) { return CDef.CenterApiDaibikiType.codeOf(code); }
            if (CenterApiEidomeFlg.name().equals(name())) { return CDef.CenterApiEidomeFlg.codeOf(code); }
            if (CenterApiWeightCd.name().equals(name())) { return CDef.CenterApiWeightCd.codeOf(code); }
            if (CenterOutputTargetFlg.name().equals(name())) { return CDef.CenterOutputTargetFlg.codeOf(code); }
            if (CenterPrintCondition.name().equals(name())) { return CDef.CenterPrintCondition.codeOf(code); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        public Classification nameOf(String name) { // null if not found, old style so use byName(name)
            if (ProcessTypeCd.name().equals(name())) { return CDef.ProcessTypeCd.valueOf(name); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return CDef.AfterDelivSlipOutTgt.valueOf(name); }
            if (AfterTagOutFlg.name().equals(name())) { return CDef.AfterTagOutFlg.valueOf(name); }
            if (AllShippingFlg.name().equals(name())) { return CDef.AllShippingFlg.valueOf(name); }
            if (AllcNgDisplay.name().equals(name())) { return CDef.AllcNgDisplay.valueOf(name); }
            if (AllcNgFlg.name().equals(name())) { return CDef.AllcNgFlg.valueOf(name); }
            if (AllocSortKey.name().equals(name())) { return CDef.AllocSortKey.valueOf(name); }
            if (ArrivalStoreFormat.name().equals(name())) { return CDef.ArrivalStoreFormat.valueOf(name); }
            if (AutoEmgSetFlg.name().equals(name())) { return CDef.AutoEmgSetFlg.valueOf(name); }
            if (AutoEmgSetTgt.name().equals(name())) { return CDef.AutoEmgSetTgt.valueOf(name); }
            if (AutoPrintTargetFlg.name().equals(name())) { return CDef.AutoPrintTargetFlg.valueOf(name); }
            if (AutoShipInstFlg.name().equals(name())) { return CDef.AutoShipInstFlg.valueOf(name); }
            if (BarcodeType.name().equals(name())) { return CDef.BarcodeType.valueOf(name); }
            if (BatchProgressFlg.name().equals(name())) { return CDef.BatchProgressFlg.valueOf(name); }
            if (BoxSelectSkip.name().equals(name())) { return CDef.BoxSelectSkip.valueOf(name); }
            if (CancelDataDisplay.name().equals(name())) { return CDef.CancelDataDisplay.valueOf(name); }
            if (CasePicFlg.name().equals(name())) { return CDef.CasePicFlg.valueOf(name); }
            if (CenterClientCls.name().equals(name())) { return CDef.CenterClientCls.valueOf(name); }
            if (CenterTransitFlg.name().equals(name())) { return CDef.CenterTransitFlg.valueOf(name); }
            if (CharacterCd.name().equals(name())) { return CDef.CharacterCd.valueOf(name); }
            if (ChargeQty0Display.name().equals(name())) { return CDef.ChargeQty0Display.valueOf(name); }
            if (CheckDigit.name().equals(name())) { return CDef.CheckDigit.valueOf(name); }
            if (CodCls.name().equals(name())) { return CDef.CodCls.valueOf(name); }
            if (CodType.name().equals(name())) { return CDef.CodType.valueOf(name); }
            if (CodeFlg.name().equals(name())) { return CDef.CodeFlg.valueOf(name); }
            if (CodeType.name().equals(name())) { return CDef.CodeType.valueOf(name); }
            if (ColType.name().equals(name())) { return CDef.ColType.valueOf(name); }
            if (CommentFlg.name().equals(name())) { return CDef.CommentFlg.valueOf(name); }
            if (CompanyFlg.name().equals(name())) { return CDef.CompanyFlg.valueOf(name); }
            if (CoolCls.name().equals(name())) { return CDef.CoolCls.valueOf(name); }
            if (CoolType.name().equals(name())) { return CDef.CoolType.valueOf(name); }
            if (CorrectType.name().equals(name())) { return CDef.CorrectType.valueOf(name); }
            if (DataInputCommitType.name().equals(name())) { return CDef.DataInputCommitType.valueOf(name); }
            if (DataInputOperationType.name().equals(name())) { return CDef.DataInputOperationType.valueOf(name); }
            if (DataInputProcessType.name().equals(name())) { return CDef.DataInputProcessType.valueOf(name); }
            if (DataInputRange.name().equals(name())) { return CDef.DataInputRange.valueOf(name); }
            if (DataInputType.name().equals(name())) { return CDef.DataInputType.valueOf(name); }
            if (DataType.name().equals(name())) { return CDef.DataType.valueOf(name); }
            if (Default.name().equals(name())) { return CDef.Default.valueOf(name); }
            if (DefaultFlg.name().equals(name())) { return CDef.DefaultFlg.valueOf(name); }
            if (DelFlg.name().equals(name())) { return CDef.DelFlg.valueOf(name); }
            if (DeleteDataDisplay.name().equals(name())) { return CDef.DeleteDataDisplay.valueOf(name); }
            if (DelivMatchFlg.name().equals(name())) { return CDef.DelivMatchFlg.valueOf(name); }
            if (DelivTz.name().equals(name())) { return CDef.DelivTz.valueOf(name); }
            if (DeliveryFlg.name().equals(name())) { return CDef.DeliveryFlg.valueOf(name); }
            if (DepositFlg.name().equals(name())) { return CDef.DepositFlg.valueOf(name); }
            if (DisplayRequired.name().equals(name())) { return CDef.DisplayRequired.valueOf(name); }
            if (DtCls.name().equals(name())) { return CDef.DtCls.valueOf(name); }
            if (Editable.name().equals(name())) { return CDef.Editable.valueOf(name); }
            if (EmergencyDisplay.name().equals(name())) { return CDef.EmergencyDisplay.valueOf(name); }
            if (EmergencyFlg.name().equals(name())) { return CDef.EmergencyFlg.valueOf(name); }
            if (ErrorFlg.name().equals(name())) { return CDef.ErrorFlg.valueOf(name); }
            if (ErrorProcessMet.name().equals(name())) { return CDef.ErrorProcessMet.valueOf(name); }
            if (FixedPoint.name().equals(name())) { return CDef.FixedPoint.valueOf(name); }
            if (ForceFixedFlg.name().equals(name())) { return CDef.ForceFixedFlg.valueOf(name); }
            if (ForeignFlg.name().equals(name())) { return CDef.ForeignFlg.valueOf(name); }
            if (GiftFlg.name().equals(name())) { return CDef.GiftFlg.valueOf(name); }
            if (GiftStatementType.name().equals(name())) { return CDef.GiftStatementType.valueOf(name); }
            if (HtCharReadFlg.name().equals(name())) { return CDef.HtCharReadFlg.valueOf(name); }
            if (ImportFlg.name().equals(name())) { return CDef.ImportFlg.valueOf(name); }
            if (InfoFlg.name().equals(name())) { return CDef.InfoFlg.valueOf(name); }
            if (InoutType.name().equals(name())) { return CDef.InoutType.valueOf(name); }
            if (InputType.name().equals(name())) { return CDef.InputType.valueOf(name); }
            if (InspectionFlg.name().equals(name())) { return CDef.InspectionFlg.valueOf(name); }
            if (InventoryLocationProduct.name().equals(name())) { return CDef.InventoryLocationProduct.valueOf(name); }
            if (InvoiceCreateFlg.name().equals(name())) { return CDef.InvoiceCreateFlg.valueOf(name); }
            if (ItemType.name().equals(name())) { return CDef.ItemType.valueOf(name); }
            if (LastFlg.name().equals(name())) { return CDef.LastFlg.valueOf(name); }
            if (LimitDtManagFlg.name().equals(name())) { return CDef.LimitDtManagFlg.valueOf(name); }
            if (LimitDtReverseFlg.name().equals(name())) { return CDef.LimitDtReverseFlg.valueOf(name); }
            if (LimitMessageCd.name().equals(name())) { return CDef.LimitMessageCd.valueOf(name); }
            if (LineFeedCd.name().equals(name())) { return CDef.LineFeedCd.valueOf(name); }
            if (ListOutFlg.name().equals(name())) { return CDef.ListOutFlg.valueOf(name); }
            if (ListOutKbn.name().equals(name())) { return CDef.ListOutKbn.valueOf(name); }
            if (ListOutFlgDisp.name().equals(name())) { return CDef.ListOutFlgDisp.valueOf(name); }
            if (LoadingFlg.name().equals(name())) { return CDef.LoadingFlg.valueOf(name); }
            if (LocationType.name().equals(name())) { return CDef.LocationType.valueOf(name); }
            if (Lockout.name().equals(name())) { return CDef.Lockout.valueOf(name); }
            if (LogDtlStatus.name().equals(name())) { return CDef.LogDtlStatus.valueOf(name); }
            if (LogDtlType.name().equals(name())) { return CDef.LogDtlType.valueOf(name); }
            if (LogStatus.name().equals(name())) { return CDef.LogStatus.valueOf(name); }
            if (LotManagFlg.name().equals(name())) { return CDef.LotManagFlg.valueOf(name); }
            if (LotReverseFlg.name().equals(name())) { return CDef.LotReverseFlg.valueOf(name); }
            if (MergeCls.name().equals(name())) { return CDef.MergeCls.valueOf(name); }
            if (MergeFlg.name().equals(name())) { return CDef.MergeFlg.valueOf(name); }
            if (MessageType.name().equals(name())) { return CDef.MessageType.valueOf(name); }
            if (MixedFlg.name().equals(name())) { return CDef.MixedFlg.valueOf(name); }
            if (MoveInstStatus.name().equals(name())) { return CDef.MoveInstStatus.valueOf(name); }
            if (MultiPicCls.name().equals(name())) { return CDef.MultiPicCls.valueOf(name); }
            if (MultiPicFlg.name().equals(name())) { return CDef.MultiPicFlg.valueOf(name); }
            if (Necessary.name().equals(name())) { return CDef.Necessary.valueOf(name); }
            if (NoAllcDisplayFlg.name().equals(name())) { return CDef.NoAllcDisplayFlg.valueOf(name); }
            if (NoConfirmedFlg.name().equals(name())) { return CDef.NoConfirmedFlg.valueOf(name); }
            if (NoStockCls.name().equals(name())) { return CDef.NoStockCls.valueOf(name); }
            if (NoStockOutFlg.name().equals(name())) { return CDef.NoStockOutFlg.valueOf(name); }
            if (NoUpsideDownCls.name().equals(name())) { return CDef.NoUpsideDownCls.valueOf(name); }
            if (NotCompletedFlg.name().equals(name())) { return CDef.NotCompletedFlg.valueOf(name); }
            if (OnetimeFlg.name().equals(name())) { return CDef.OnetimeFlg.valueOf(name); }
            if (OverStoreNumFlg.name().equals(name())) { return CDef.OverStoreNumFlg.valueOf(name); }
            if (PackingCalCls.name().equals(name())) { return CDef.PackingCalCls.valueOf(name); }
            if (PackingProcessCls.name().equals(name())) { return CDef.PackingProcessCls.valueOf(name); }
            if (PackingShowFlg.name().equals(name())) { return CDef.PackingShowFlg.valueOf(name); }
            if (PackingStatus.name().equals(name())) { return CDef.PackingStatus.valueOf(name); }
            if (PasswordReset.name().equals(name())) { return CDef.PasswordReset.valueOf(name); }
            if (PastStoreDtFlg.name().equals(name())) { return CDef.PastStoreDtFlg.valueOf(name); }
            if (PhysicalDelete.name().equals(name())) { return CDef.PhysicalDelete.valueOf(name); }
            if (PicCls.name().equals(name())) { return CDef.PicCls.valueOf(name); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return CDef.PicMthdRcmdBreakKey.valueOf(name); }
            if (PicMthdRcmdFlg.name().equals(name())) { return CDef.PicMthdRcmdFlg.valueOf(name); }
            if (PicMthdRcmdListOut.name().equals(name())) { return CDef.PicMthdRcmdListOut.valueOf(name); }
            if (PickingFlg.name().equals(name())) { return CDef.PickingFlg.valueOf(name); }
            if (PickingLocationFlg.name().equals(name())) { return CDef.PickingLocationFlg.valueOf(name); }
            if (PickingStatus.name().equals(name())) { return CDef.PickingStatus.valueOf(name); }
            if (PickingType.name().equals(name())) { return CDef.PickingType.valueOf(name); }
            if (PostType.name().equals(name())) { return CDef.PostType.valueOf(name); }
            if (PrintDataType.name().equals(name())) { return CDef.PrintDataType.valueOf(name); }
            if (PrintErrorFlg.name().equals(name())) { return CDef.PrintErrorFlg.valueOf(name); }
            if (PrintQueueStatus.name().equals(name())) { return CDef.PrintQueueStatus.valueOf(name); }
            if (PrintResultClass.name().equals(name())) { return CDef.PrintResultClass.valueOf(name); }
            if (PrintServiceStatus.name().equals(name())) { return CDef.PrintServiceStatus.valueOf(name); }
            if (PrintStatus.name().equals(name())) { return CDef.PrintStatus.valueOf(name); }
            if (PrintedFlg.name().equals(name())) { return CDef.PrintedFlg.valueOf(name); }
            if (PriorityFlg.name().equals(name())) { return CDef.PriorityFlg.valueOf(name); }
            if (ProductLabelJanBarcode.name().equals(name())) { return CDef.ProductLabelJanBarcode.valueOf(name); }
            if (ProductLabelOutUnit.name().equals(name())) { return CDef.ProductLabelOutUnit.valueOf(name); }
            if (ProductLabelProdBarcode.name().equals(name())) { return CDef.ProductLabelProdBarcode.valueOf(name); }
            if (ProductPartPacking.name().equals(name())) { return CDef.ProductPartPacking.valueOf(name); }
            if (ProductTypeCode.name().equals(name())) { return CDef.ProductTypeCode.valueOf(name); }
            if (Qty0Display.name().equals(name())) { return CDef.Qty0Display.valueOf(name); }
            if (ReasonType.name().equals(name())) { return CDef.ReasonType.valueOf(name); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return CDef.ReceiveDeliveryStatus.valueOf(name); }
            if (ReceiveFlg.name().equals(name())) { return CDef.ReceiveFlg.valueOf(name); }
            if (ReceiveStatus.name().equals(name())) { return CDef.ReceiveStatus.valueOf(name); }
            if (ReplenishAllocCls.name().equals(name())) { return CDef.ReplenishAllocCls.valueOf(name); }
            if (ReplenishProductCdUnset.name().equals(name())) { return CDef.ReplenishProductCdUnset.valueOf(name); }
            if (ReplenishSearchCls.name().equals(name())) { return CDef.ReplenishSearchCls.valueOf(name); }
            if (ReplenishUnitCls.name().equals(name())) { return CDef.ReplenishUnitCls.valueOf(name); }
            if (ReportLayoutItemType.name().equals(name())) { return CDef.ReportLayoutItemType.valueOf(name); }
            if (RestockType.name().equals(name())) { return CDef.RestockType.valueOf(name); }
            if (ResultAfterProductLabel.name().equals(name())) { return CDef.ResultAfterProductLabel.valueOf(name); }
            if (ReverseValidFlg.name().equals(name())) { return CDef.ReverseValidFlg.valueOf(name); }
            if (Select.name().equals(name())) { return CDef.Select.valueOf(name); }
            if (SelectPrintServiceStatus.name().equals(name())) { return CDef.SelectPrintServiceStatus.valueOf(name); }
            if (SerialOperationType.name().equals(name())) { return CDef.SerialOperationType.valueOf(name); }
            if (TargetWindow.name().equals(name())) { return CDef.TargetWindow.valueOf(name); }
            if (SettlementType.name().equals(name())) { return CDef.SettlementType.valueOf(name); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return CDef.SglRowInspAfterOutCls.valueOf(name); }
            if (SglRowPicFlg.name().equals(name())) { return CDef.SglRowPicFlg.valueOf(name); }
            if (SheetCollate.name().equals(name())) { return CDef.SheetCollate.valueOf(name); }
            if (ShippingFlg.name().equals(name())) { return CDef.ShippingFlg.valueOf(name); }
            if (ShippingStatus.name().equals(name())) { return CDef.ShippingStatus.valueOf(name); }
            if (ShippingStopFlg.name().equals(name())) { return CDef.ShippingStopFlg.valueOf(name); }
            if (ShortStockDisplay.name().equals(name())) { return CDef.ShortStockDisplay.valueOf(name); }
            if (ShpCheckCls.name().equals(name())) { return CDef.ShpCheckCls.valueOf(name); }
            if (ShpCheckDisplay.name().equals(name())) { return CDef.ShpCheckDisplay.valueOf(name); }
            if (SlipType.name().equals(name())) { return CDef.SlipType.valueOf(name); }
            if (SoundPlayFlg.name().equals(name())) { return CDef.SoundPlayFlg.valueOf(name); }
            if (StockAdjustFlg.name().equals(name())) { return CDef.StockAdjustFlg.valueOf(name); }
            if (StockDisplayFld.name().equals(name())) { return CDef.StockDisplayFld.valueOf(name); }
            if (StockExistOnlyFlg.name().equals(name())) { return CDef.StockExistOnlyFlg.valueOf(name); }
            if (StockMoveFlg.name().equals(name())) { return CDef.StockMoveFlg.valueOf(name); }
            if (StockNum0Display.name().equals(name())) { return CDef.StockNum0Display.valueOf(name); }
            if (StockOutAllocCls.name().equals(name())) { return CDef.StockOutAllocCls.valueOf(name); }
            if (StockOutAutoInstFlg.name().equals(name())) { return CDef.StockOutAutoInstFlg.valueOf(name); }
            if (StockOutFlg.name().equals(name())) { return CDef.StockOutFlg.valueOf(name); }
            if (StockOutInstCxlFlg.name().equals(name())) { return CDef.StockOutInstCxlFlg.valueOf(name); }
            if (StockOutInstSplitFlg.name().equals(name())) { return CDef.StockOutInstSplitFlg.valueOf(name); }
            if (StockQtyDisplay.name().equals(name())) { return CDef.StockQtyDisplay.valueOf(name); }
            if (StockTakingInput.name().equals(name())) { return CDef.StockTakingInput.valueOf(name); }
            if (StockTarget.name().equals(name())) { return CDef.StockTarget.valueOf(name); }
            if (StoreDtFlg.name().equals(name())) { return CDef.StoreDtFlg.valueOf(name); }
            if (StoreFlg.name().equals(name())) { return CDef.StoreFlg.valueOf(name); }
            if (StoreNoDivideDisplay.name().equals(name())) { return CDef.StoreNoDivideDisplay.valueOf(name); }
            if (StoreNoFlg.name().equals(name())) { return CDef.StoreNoFlg.valueOf(name); }
            if (StoreNoMergeFlg.name().equals(name())) { return CDef.StoreNoMergeFlg.valueOf(name); }
            if (SystemLogStatus.name().equals(name())) { return CDef.SystemLogStatus.valueOf(name); }
            if (SystemLogType.name().equals(name())) { return CDef.SystemLogType.valueOf(name); }
            if (SystemType.name().equals(name())) { return CDef.SystemType.valueOf(name); }
            if (TagDeliveryOutFlg.name().equals(name())) { return CDef.TagDeliveryOutFlg.valueOf(name); }
            if (TakingShippingDtFlg.name().equals(name())) { return CDef.TakingShippingDtFlg.valueOf(name); }
            if (TakingShippingFlg.name().equals(name())) { return CDef.TakingShippingFlg.valueOf(name); }
            if (TextAlign.name().equals(name())) { return CDef.TextAlign.valueOf(name); }
            if (TotalPicFlg.name().equals(name())) { return CDef.TotalPicFlg.valueOf(name); }
            if (TrackingNumberingUnit.name().equals(name())) { return CDef.TrackingNumberingUnit.valueOf(name); }
            if (TransitDisplay.name().equals(name())) { return CDef.TransitDisplay.valueOf(name); }
            if (Unmatch.name().equals(name())) { return CDef.Unmatch.valueOf(name); }
            if (UpdCd.name().equals(name())) { return CDef.UpdCd.valueOf(name); }
            if (UpdType.name().equals(name())) { return CDef.UpdType.valueOf(name); }
            if (Updatable.name().equals(name())) { return CDef.Updatable.valueOf(name); }
            if (UploadTableNm.name().equals(name())) { return CDef.UploadTableNm.valueOf(name); }
            if (UseHtShipFlg.name().equals(name())) { return CDef.UseHtShipFlg.valueOf(name); }
            if (UserEditable.name().equals(name())) { return CDef.UserEditable.valueOf(name); }
            if (VendorFlg.name().equals(name())) { return CDef.VendorFlg.valueOf(name); }
            if (Visible.name().equals(name())) { return CDef.Visible.valueOf(name); }
            if (WorkFlg.name().equals(name())) { return CDef.WorkFlg.valueOf(name); }
            if (WorkMessageFlg.name().equals(name())) { return CDef.WorkMessageFlg.valueOf(name); }
            if (YamatoDelivTz.name().equals(name())) { return CDef.YamatoDelivTz.valueOf(name); }
            if (YupackDelivTz.name().equals(name())) { return CDef.YupackDelivTz.valueOf(name); }
            if (ZipFlg.name().equals(name())) { return CDef.ZipFlg.valueOf(name); }
            if (ResultAfterProductTarget.name().equals(name())) { return CDef.ResultAfterProductTarget.valueOf(name); }
            if (CopyTargetTable.name().equals(name())) { return CDef.CopyTargetTable.valueOf(name); }
            if (InspectionLabelOutFlg.name().equals(name())) { return CDef.InspectionLabelOutFlg.valueOf(name); }
            if (DecimalProductPacking.name().equals(name())) { return CDef.DecimalProductPacking.valueOf(name); }
            if (DecimalExistFlg.name().equals(name())) { return CDef.DecimalExistFlg.valueOf(name); }
            if (CasePickFlg.name().equals(name())) { return CDef.CasePickFlg.valueOf(name); }
            if (EmReplenishShapeFlg.name().equals(name())) { return CDef.EmReplenishShapeFlg.valueOf(name); }
            if (WorkStatus.name().equals(name())) { return CDef.WorkStatus.valueOf(name); }
            if (WorkLogOutFlg.name().equals(name())) { return CDef.WorkLogOutFlg.valueOf(name); }
            if (RoleControlClass.name().equals(name())) { return CDef.RoleControlClass.valueOf(name); }
            if (BolOutFlg.name().equals(name())) { return CDef.BolOutFlg.valueOf(name); }
            if (BolOutputTargetFlg.name().equals(name())) { return CDef.BolOutputTargetFlg.valueOf(name); }
            if (PaymentTerm.name().equals(name())) { return CDef.PaymentTerm.valueOf(name); }
            if (CesIntegrationFlg.name().equals(name())) { return CDef.CesIntegrationFlg.valueOf(name); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return CDef.PackingSlipAutoOutputFlg.valueOf(name); }
            if (FreightCls.name().equals(name())) { return CDef.FreightCls.valueOf(name); }
            if (SatDeliveryFlg.name().equals(name())) { return CDef.SatDeliveryFlg.valueOf(name); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return CDef.ResidentialDeliveryFlg.valueOf(name); }
            if (CodFlg.name().equals(name())) { return CDef.CodFlg.valueOf(name); }
            if (SignatureRequiredFlg.name().equals(name())) { return CDef.SignatureRequiredFlg.valueOf(name); }
            if (SignatureReleaseFlg.name().equals(name())) { return CDef.SignatureReleaseFlg.valueOf(name); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return CDef.CallBeforeDeliveryFlg.valueOf(name); }
            if (FreezableProtectionFlg.name().equals(name())) { return CDef.FreezableProtectionFlg.valueOf(name); }
            if (GuaranteedPlusFlg.name().equals(name())) { return CDef.GuaranteedPlusFlg.valueOf(name); }
            if (ResidentialPickupFlg.name().equals(name())) { return CDef.ResidentialPickupFlg.valueOf(name); }
            if (DoNotStackStackFlg.name().equals(name())) { return CDef.DoNotStackStackFlg.valueOf(name); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return CDef.LimitedAccessDeliveryFlg.valueOf(name); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return CDef.LimitedAccessPickupFlg.valueOf(name); }
            if (OverSizedFlg.name().equals(name())) { return CDef.OverSizedFlg.valueOf(name); }
            if (PoisonFlg.name().equals(name())) { return CDef.PoisonFlg.valueOf(name); }
            if (FoogFlg.name().equals(name())) { return CDef.FoogFlg.valueOf(name); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return CDef.LiftgateDeliveryPrepaidFlg.valueOf(name); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return CDef.LiftgateDeliveryCollectFlg.valueOf(name); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return CDef.LiftgatePickupPrepaidFlg.valueOf(name); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return CDef.LiftgatePickupCollectFlg.valueOf(name); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return CDef.InsideDeliveryPrepaidFlg.valueOf(name); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return CDef.InsideDeliveryCollectFlg.valueOf(name); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return CDef.InsidePickupPrepaidFlg.valueOf(name); }
            if (InsidePickupCollectFlg.name().equals(name())) { return CDef.InsidePickupCollectFlg.valueOf(name); }
            if (RcmdPickingCls.name().equals(name())) { return CDef.RcmdPickingCls.valueOf(name); }
            if (SglRowPicTarget.name().equals(name())) { return CDef.SglRowPicTarget.valueOf(name); }
            if (CasePicTarget.name().equals(name())) { return CDef.CasePicTarget.valueOf(name); }
            if (AttendanceLeavingRest.name().equals(name())) { return CDef.AttendanceLeavingRest.valueOf(name); }
            if (UploadZipType.name().equals(name())) { return CDef.UploadZipType.valueOf(name); }
            if (FwType.name().equals(name())) { return CDef.FwType.valueOf(name); }
            if (McaType.name().equals(name())) { return CDef.McaType.valueOf(name); }
            if (AccountFlg.name().equals(name())) { return CDef.AccountFlg.valueOf(name); }
            if (AlarmReasonCls.name().equals(name())) { return CDef.AlarmReasonCls.valueOf(name); }
            if (AlarmType.name().equals(name())) { return CDef.AlarmType.valueOf(name); }
            if (AreaCls.name().equals(name())) { return CDef.AreaCls.valueOf(name); }
            if (AssortStatus.name().equals(name())) { return CDef.AssortStatus.valueOf(name); }
            if (BaseCls.name().equals(name())) { return CDef.BaseCls.valueOf(name); }
            if (BoxType.name().equals(name())) { return CDef.BoxType.valueOf(name); }
            if (CarrierType.name().equals(name())) { return CDef.CarrierType.valueOf(name); }
            if (CarrierTypeCd.name().equals(name())) { return CDef.CarrierTypeCd.valueOf(name); }
            if (CaseTypeCd.name().equals(name())) { return CDef.CaseTypeCd.valueOf(name); }
            if (ClosingDt.name().equals(name())) { return CDef.ClosingDt.valueOf(name); }
            if (CompletedHidden.name().equals(name())) { return CDef.CompletedHidden.valueOf(name); }
            if (Condition.name().equals(name())) { return CDef.Condition.valueOf(name); }
            if (Constract.name().equals(name())) { return CDef.Constract.valueOf(name); }
            if (CsPsType.name().equals(name())) { return CDef.CsPsType.valueOf(name); }
            if (DefaultStockType.name().equals(name())) { return CDef.DefaultStockType.valueOf(name); }
            if (DelivCenterFrom.name().equals(name())) { return CDef.DelivCenterFrom.valueOf(name); }
            if (DelivCenterTo.name().equals(name())) { return CDef.DelivCenterTo.valueOf(name); }
            if (DeliveryDtUnspecified.name().equals(name())) { return CDef.DeliveryDtUnspecified.valueOf(name); }
            if (DeliveryTimeZone.name().equals(name())) { return CDef.DeliveryTimeZone.valueOf(name); }
            if (DeliveryTypeSendCls.name().equals(name())) { return CDef.DeliveryTypeSendCls.valueOf(name); }
            if (DepositItemFlg.name().equals(name())) { return CDef.DepositItemFlg.valueOf(name); }
            if (DepositType.name().equals(name())) { return CDef.DepositType.valueOf(name); }
            if (DiffCls.name().equals(name())) { return CDef.DiffCls.valueOf(name); }
            if (DirectDeliveryTypeCd.name().equals(name())) { return CDef.DirectDeliveryTypeCd.valueOf(name); }
            if (EcOrder.name().equals(name())) { return CDef.EcOrder.valueOf(name); }
            if (EcType.name().equals(name())) { return CDef.EcType.valueOf(name); }
            if (ExecuteStatus.name().equals(name())) { return CDef.ExecuteStatus.valueOf(name); }
            if (Fee.name().equals(name())) { return CDef.Fee.valueOf(name); }
            if (Floor.name().equals(name())) { return CDef.Floor.valueOf(name); }
            if (FloorCd.name().equals(name())) { return CDef.FloorCd.valueOf(name); }
            if (FloorEndFlg.name().equals(name())) { return CDef.FloorEndFlg.valueOf(name); }
            if (FloorTypeCd.name().equals(name())) { return CDef.FloorTypeCd.valueOf(name); }
            if (HandOverStatus.name().equals(name())) { return CDef.HandOverStatus.valueOf(name); }
            if (HandlingType.name().equals(name())) { return CDef.HandlingType.valueOf(name); }
            if (HeavyItemFlg.name().equals(name())) { return CDef.HeavyItemFlg.valueOf(name); }
            if (HeavyItemHadlingFlg.name().equals(name())) { return CDef.HeavyItemHadlingFlg.valueOf(name); }
            if (HinmokuGroupCd.name().equals(name())) { return CDef.HinmokuGroupCd.valueOf(name); }
            if (HolidayFlg.name().equals(name())) { return CDef.HolidayFlg.valueOf(name); }
            if (IdManagAbolitionTypeCd.name().equals(name())) { return CDef.IdManagAbolitionTypeCd.valueOf(name); }
            if (InsuranceFlg.name().equals(name())) { return CDef.InsuranceFlg.valueOf(name); }
            if (InventoryDataStatus.name().equals(name())) { return CDef.InventoryDataStatus.valueOf(name); }
            if (InventoryDiffCls.name().equals(name())) { return CDef.InventoryDiffCls.valueOf(name); }
            if (InventoryInputCls.name().equals(name())) { return CDef.InventoryInputCls.valueOf(name); }
            if (InventoryListOutCls.name().equals(name())) { return CDef.InventoryListOutCls.valueOf(name); }
            if (InventoryListType.name().equals(name())) { return CDef.InventoryListType.valueOf(name); }
            if (ItManagType.name().equals(name())) { return CDef.ItManagType.valueOf(name); }
            if (ItemDensan.name().equals(name())) { return CDef.ItemDensan.valueOf(name); }
            if (LargeItemFlg.name().equals(name())) { return CDef.LargeItemFlg.valueOf(name); }
            if (LimitDtSplitTypeCd.name().equals(name())) { return CDef.LimitDtSplitTypeCd.valueOf(name); }
            if (LimitDtUnmatchTypeCd.name().equals(name())) { return CDef.LimitDtUnmatchTypeCd.valueOf(name); }
            if (LogiAttentionTypeCd.name().equals(name())) { return CDef.LogiAttentionTypeCd.valueOf(name); }
            if (LogiSpecialTypeCd.name().equals(name())) { return CDef.LogiSpecialTypeCd.valueOf(name); }
            if (LogiWeightFlg.name().equals(name())) { return CDef.LogiWeightFlg.valueOf(name); }
            if (LotSplitTypeCd.name().equals(name())) { return CDef.LotSplitTypeCd.valueOf(name); }
            if (LotUnmatchTypeCd.name().equals(name())) { return CDef.LotUnmatchTypeCd.valueOf(name); }
            if (MaxStoreShape.name().equals(name())) { return CDef.MaxStoreShape.valueOf(name); }
            if (MedicalManagFlg.name().equals(name())) { return CDef.MedicalManagFlg.valueOf(name); }
            if (MoveDirection.name().equals(name())) { return CDef.MoveDirection.valueOf(name); }
            if (NationalHolidayCarrier.name().equals(name())) { return CDef.NationalHolidayCarrier.valueOf(name); }
            if (NationalHolidayFlg.name().equals(name())) { return CDef.NationalHolidayFlg.valueOf(name); }
            if (NizoroeProcessId.name().equals(name())) { return CDef.NizoroeProcessId.valueOf(name); }
            if (NizoroeProcessIdWms.name().equals(name())) { return CDef.NizoroeProcessIdWms.valueOf(name); }
            if (NizoroeTime.name().equals(name())) { return CDef.NizoroeTime.valueOf(name); }
            if (NizoroeType.name().equals(name())) { return CDef.NizoroeType.valueOf(name); }
            if (NizoroeTypeWms.name().equals(name())) { return CDef.NizoroeTypeWms.valueOf(name); }
            if (NoOkinawaFlightFlg.name().equals(name())) { return CDef.NoOkinawaFlightFlg.valueOf(name); }
            if (OcrDateFormat.name().equals(name())) { return CDef.OcrDateFormat.valueOf(name); }
            if (OutputListType.name().equals(name())) { return CDef.OutputListType.valueOf(name); }
            if (OutputMonth.name().equals(name())) { return CDef.OutputMonth.valueOf(name); }
            if (OutputStatus.name().equals(name())) { return CDef.OutputStatus.valueOf(name); }
            if (PaymentTypeCd.name().equals(name())) { return CDef.PaymentTypeCd.valueOf(name); }
            if (PickingPatternCd.name().equals(name())) { return CDef.PickingPatternCd.valueOf(name); }
            if (Prefecture.name().equals(name())) { return CDef.Prefecture.valueOf(name); }
            if (PriceDiffHidden.name().equals(name())) { return CDef.PriceDiffHidden.valueOf(name); }
            if (ProdDtManagFlg.name().equals(name())) { return CDef.ProdDtManagFlg.valueOf(name); }
            if (ProdDtSplitTypeCd.name().equals(name())) { return CDef.ProdDtSplitTypeCd.valueOf(name); }
            if (ProdDtUnmatchTypeCd.name().equals(name())) { return CDef.ProdDtUnmatchTypeCd.valueOf(name); }
            if (ProductCategoryConvertCls.name().equals(name())) { return CDef.ProductCategoryConvertCls.valueOf(name); }
            if (ProductCategoryPlant.name().equals(name())) { return CDef.ProductCategoryPlant.valueOf(name); }
            if (ProductCategoryType.name().equals(name())) { return CDef.ProductCategoryType.valueOf(name); }
            if (ProductStoreStatus.name().equals(name())) { return CDef.ProductStoreStatus.valueOf(name); }
            if (ProductUnitCls.name().equals(name())) { return CDef.ProductUnitCls.valueOf(name); }
            if (ReceiveReason.name().equals(name())) { return CDef.ReceiveReason.valueOf(name); }
            if (ReceiveReasonConvert.name().equals(name())) { return CDef.ReceiveReasonConvert.valueOf(name); }
            if (ReceiveReasonDepositReceive.name().equals(name())) { return CDef.ReceiveReasonDepositReceive.valueOf(name); }
            if (ReceiveStatus01.name().equals(name())) { return CDef.ReceiveStatus01.valueOf(name); }
            if (RecommendLocationTypeCd.name().equals(name())) { return CDef.RecommendLocationTypeCd.valueOf(name); }
            if (RelatedProducts.name().equals(name())) { return CDef.RelatedProducts.valueOf(name); }
            if (RemainFlg.name().equals(name())) { return CDef.RemainFlg.valueOf(name); }
            if (ReplenishShape.name().equals(name())) { return CDef.ReplenishShape.valueOf(name); }
            if (SampleCls.name().equals(name())) { return CDef.SampleCls.valueOf(name); }
            if (SearchReferenceDt.name().equals(name())) { return CDef.SearchReferenceDt.valueOf(name); }
            if (SerialManagFlg.name().equals(name())) { return CDef.SerialManagFlg.valueOf(name); }
            if (ShapeGrpTypeCd.name().equals(name())) { return CDef.ShapeGrpTypeCd.valueOf(name); }
            if (SharedProductTypeCd.name().equals(name())) { return CDef.SharedProductTypeCd.valueOf(name); }
            if (ShippingInspectionHidden.name().equals(name())) { return CDef.ShippingInspectionHidden.valueOf(name); }
            if (ShippingInspectionStatus.name().equals(name())) { return CDef.ShippingInspectionStatus.valueOf(name); }
            if (ShippingProcessType.name().equals(name())) { return CDef.ShippingProcessType.valueOf(name); }
            if (ShippingProgress.name().equals(name())) { return CDef.ShippingProgress.valueOf(name); }
            if (ShippingReason.name().equals(name())) { return CDef.ShippingReason.valueOf(name); }
            if (ShippingReasonConvert.name().equals(name())) { return CDef.ShippingReasonConvert.valueOf(name); }
            if (ShippingSlipType.name().equals(name())) { return CDef.ShippingSlipType.valueOf(name); }
            if (ShippingType.name().equals(name())) { return CDef.ShippingType.valueOf(name); }
            if (ShippingWorkType.name().equals(name())) { return CDef.ShippingWorkType.valueOf(name); }
            if (SlipType2.name().equals(name())) { return CDef.SlipType2.valueOf(name); }
            if (SpareTypeCd.name().equals(name())) { return CDef.SpareTypeCd.valueOf(name); }
            if (SpecifiedNumOfShoes.name().equals(name())) { return CDef.SpecifiedNumOfShoes.valueOf(name); }
            if (SplitDeliveryTypeCd.name().equals(name())) { return CDef.SplitDeliveryTypeCd.valueOf(name); }
            if (StockDifference.name().equals(name())) { return CDef.StockDifference.valueOf(name); }
            if (StockDisplayType.name().equals(name())) { return CDef.StockDisplayType.valueOf(name); }
            if (StockExist.name().equals(name())) { return CDef.StockExist.valueOf(name); }
            if (StockProcessType.name().equals(name())) { return CDef.StockProcessType.valueOf(name); }
            if (StockRefCls.name().equals(name())) { return CDef.StockRefCls.valueOf(name); }
            if (StockTakingStatus.name().equals(name())) { return CDef.StockTakingStatus.valueOf(name); }
            if (StockZeroDisplay.name().equals(name())) { return CDef.StockZeroDisplay.valueOf(name); }
            if (SuppliesVarietyFlg.name().equals(name())) { return CDef.SuppliesVarietyFlg.valueOf(name); }
            if (TargetBase.name().equals(name())) { return CDef.TargetBase.valueOf(name); }
            if (TargetItemCd.name().equals(name())) { return CDef.TargetItemCd.valueOf(name); }
            if (TargetKoguchiCd.name().equals(name())) { return CDef.TargetKoguchiCd.valueOf(name); }
            if (TargetSalesCd.name().equals(name())) { return CDef.TargetSalesCd.valueOf(name); }
            if (UnitCls.name().equals(name())) { return CDef.UnitCls.valueOf(name); }
            if (UrgentShippingTimeZone.name().equals(name())) { return CDef.UrgentShippingTimeZone.valueOf(name); }
            if (WorkType.name().equals(name())) { return CDef.WorkType.valueOf(name); }
            if (ReceiveLabelFlg.name().equals(name())) { return CDef.ReceiveLabelFlg.valueOf(name); }
            if (ReceiveDtUnmatchFlg.name().equals(name())) { return CDef.ReceiveDtUnmatchFlg.valueOf(name); }
            if (PrintFlg.name().equals(name())) { return CDef.PrintFlg.valueOf(name); }
            if (ReceiveRemainFlg.name().equals(name())) { return CDef.ReceiveRemainFlg.valueOf(name); }
            if (ShippingPickedHidden.name().equals(name())) { return CDef.ShippingPickedHidden.valueOf(name); }
            if (CarrierDataOutFlg.name().equals(name())) { return CDef.CarrierDataOutFlg.valueOf(name); }
            if (PllOutFlg.name().equals(name())) { return CDef.PllOutFlg.valueOf(name); }
            if (DepositorCls.name().equals(name())) { return CDef.DepositorCls.valueOf(name); }
            if (RplOutFlg.name().equals(name())) { return CDef.RplOutFlg.valueOf(name); }
            if (RecordSendFlg.name().equals(name())) { return CDef.RecordSendFlg.valueOf(name); }
            if (HandOverHidden.name().equals(name())) { return CDef.HandOverHidden.valueOf(name); }
            if (ExternalWarehouseFlg.name().equals(name())) { return CDef.ExternalWarehouseFlg.valueOf(name); }
            if (StandardPlantCls.name().equals(name())) { return CDef.StandardPlantCls.valueOf(name); }
            if (LargeItemHadlingFlg.name().equals(name())) { return CDef.LargeItemHadlingFlg.valueOf(name); }
            if (HolidayCarrierFlg.name().equals(name())) { return CDef.HolidayCarrierFlg.valueOf(name); }
            if (OkinawaFlightFlg.name().equals(name())) { return CDef.OkinawaFlightFlg.valueOf(name); }
            if (BaseDefaultCarrierFlg.name().equals(name())) { return CDef.BaseDefaultCarrierFlg.valueOf(name); }
            if (SlipTypeCd.name().equals(name())) { return CDef.SlipTypeCd.valueOf(name); }
            if (ProperFlg.name().equals(name())) { return CDef.ProperFlg.valueOf(name); }
            if (CdlOutFlg.name().equals(name())) { return CDef.CdlOutFlg.valueOf(name); }
            if (ErrorNum.name().equals(name())) { return CDef.ErrorNum.valueOf(name); }
            if (CenterPicListCls1.name().equals(name())) { return CDef.CenterPicListCls1.valueOf(name); }
            if (CenterPicListCls2.name().equals(name())) { return CDef.CenterPicListCls2.valueOf(name); }
            if (CenterPicListCls3.name().equals(name())) { return CDef.CenterPicListCls3.valueOf(name); }
            if (CenterSagawaDelivTz.name().equals(name())) { return CDef.CenterSagawaDelivTz.valueOf(name); }
            if (CenterTransportTypeItem.name().equals(name())) { return CDef.CenterTransportTypeItem.valueOf(name); }
            if (CenterSlipShapeCd.name().equals(name())) { return CDef.CenterSlipShapeCd.valueOf(name); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return CDef.CenterTransportTypeSpeed.valueOf(name); }
            if (CenterSealType.name().equals(name())) { return CDef.CenterSealType.valueOf(name); }
            if (CenterTagClass.name().equals(name())) { return CDef.CenterTagClass.valueOf(name); }
            if (CenterTagDataType.name().equals(name())) { return CDef.CenterTagDataType.valueOf(name); }
            if (CenterTagType.name().equals(name())) { return CDef.CenterTagType.valueOf(name); }
            if (CenterTagTypeAfter.name().equals(name())) { return CDef.CenterTagTypeAfter.valueOf(name); }
            if (CenterApiBinsyuCode.name().equals(name())) { return CDef.CenterApiBinsyuCode.valueOf(name); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return CDef.CenterApiDaibikiFlg.valueOf(name); }
            if (CenterApiDaibikiType.name().equals(name())) { return CDef.CenterApiDaibikiType.valueOf(name); }
            if (CenterApiEidomeFlg.name().equals(name())) { return CDef.CenterApiEidomeFlg.valueOf(name); }
            if (CenterApiWeightCd.name().equals(name())) { return CDef.CenterApiWeightCd.valueOf(name); }
            if (CenterOutputTargetFlg.name().equals(name())) { return CDef.CenterOutputTargetFlg.valueOf(name); }
            if (CenterPrintCondition.name().equals(name())) { return CDef.CenterPrintCondition.valueOf(name); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        public List<Classification> listAll() {
            if (ProcessTypeCd.name().equals(name())) { return toClsList(CDef.ProcessTypeCd.listAll()); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return toClsList(CDef.AfterDelivSlipOutTgt.listAll()); }
            if (AfterTagOutFlg.name().equals(name())) { return toClsList(CDef.AfterTagOutFlg.listAll()); }
            if (AllShippingFlg.name().equals(name())) { return toClsList(CDef.AllShippingFlg.listAll()); }
            if (AllcNgDisplay.name().equals(name())) { return toClsList(CDef.AllcNgDisplay.listAll()); }
            if (AllcNgFlg.name().equals(name())) { return toClsList(CDef.AllcNgFlg.listAll()); }
            if (AllocSortKey.name().equals(name())) { return toClsList(CDef.AllocSortKey.listAll()); }
            if (ArrivalStoreFormat.name().equals(name())) { return toClsList(CDef.ArrivalStoreFormat.listAll()); }
            if (AutoEmgSetFlg.name().equals(name())) { return toClsList(CDef.AutoEmgSetFlg.listAll()); }
            if (AutoEmgSetTgt.name().equals(name())) { return toClsList(CDef.AutoEmgSetTgt.listAll()); }
            if (AutoPrintTargetFlg.name().equals(name())) { return toClsList(CDef.AutoPrintTargetFlg.listAll()); }
            if (AutoShipInstFlg.name().equals(name())) { return toClsList(CDef.AutoShipInstFlg.listAll()); }
            if (BarcodeType.name().equals(name())) { return toClsList(CDef.BarcodeType.listAll()); }
            if (BatchProgressFlg.name().equals(name())) { return toClsList(CDef.BatchProgressFlg.listAll()); }
            if (BoxSelectSkip.name().equals(name())) { return toClsList(CDef.BoxSelectSkip.listAll()); }
            if (CancelDataDisplay.name().equals(name())) { return toClsList(CDef.CancelDataDisplay.listAll()); }
            if (CasePicFlg.name().equals(name())) { return toClsList(CDef.CasePicFlg.listAll()); }
            if (CenterClientCls.name().equals(name())) { return toClsList(CDef.CenterClientCls.listAll()); }
            if (CenterTransitFlg.name().equals(name())) { return toClsList(CDef.CenterTransitFlg.listAll()); }
            if (CharacterCd.name().equals(name())) { return toClsList(CDef.CharacterCd.listAll()); }
            if (ChargeQty0Display.name().equals(name())) { return toClsList(CDef.ChargeQty0Display.listAll()); }
            if (CheckDigit.name().equals(name())) { return toClsList(CDef.CheckDigit.listAll()); }
            if (CodCls.name().equals(name())) { return toClsList(CDef.CodCls.listAll()); }
            if (CodType.name().equals(name())) { return toClsList(CDef.CodType.listAll()); }
            if (CodeFlg.name().equals(name())) { return toClsList(CDef.CodeFlg.listAll()); }
            if (CodeType.name().equals(name())) { return toClsList(CDef.CodeType.listAll()); }
            if (ColType.name().equals(name())) { return toClsList(CDef.ColType.listAll()); }
            if (CommentFlg.name().equals(name())) { return toClsList(CDef.CommentFlg.listAll()); }
            if (CompanyFlg.name().equals(name())) { return toClsList(CDef.CompanyFlg.listAll()); }
            if (CoolCls.name().equals(name())) { return toClsList(CDef.CoolCls.listAll()); }
            if (CoolType.name().equals(name())) { return toClsList(CDef.CoolType.listAll()); }
            if (CorrectType.name().equals(name())) { return toClsList(CDef.CorrectType.listAll()); }
            if (DataInputCommitType.name().equals(name())) { return toClsList(CDef.DataInputCommitType.listAll()); }
            if (DataInputOperationType.name().equals(name())) { return toClsList(CDef.DataInputOperationType.listAll()); }
            if (DataInputProcessType.name().equals(name())) { return toClsList(CDef.DataInputProcessType.listAll()); }
            if (DataInputRange.name().equals(name())) { return toClsList(CDef.DataInputRange.listAll()); }
            if (DataInputType.name().equals(name())) { return toClsList(CDef.DataInputType.listAll()); }
            if (DataType.name().equals(name())) { return toClsList(CDef.DataType.listAll()); }
            if (Default.name().equals(name())) { return toClsList(CDef.Default.listAll()); }
            if (DefaultFlg.name().equals(name())) { return toClsList(CDef.DefaultFlg.listAll()); }
            if (DelFlg.name().equals(name())) { return toClsList(CDef.DelFlg.listAll()); }
            if (DeleteDataDisplay.name().equals(name())) { return toClsList(CDef.DeleteDataDisplay.listAll()); }
            if (DelivMatchFlg.name().equals(name())) { return toClsList(CDef.DelivMatchFlg.listAll()); }
            if (DelivTz.name().equals(name())) { return toClsList(CDef.DelivTz.listAll()); }
            if (DeliveryFlg.name().equals(name())) { return toClsList(CDef.DeliveryFlg.listAll()); }
            if (DepositFlg.name().equals(name())) { return toClsList(CDef.DepositFlg.listAll()); }
            if (DisplayRequired.name().equals(name())) { return toClsList(CDef.DisplayRequired.listAll()); }
            if (DtCls.name().equals(name())) { return toClsList(CDef.DtCls.listAll()); }
            if (Editable.name().equals(name())) { return toClsList(CDef.Editable.listAll()); }
            if (EmergencyDisplay.name().equals(name())) { return toClsList(CDef.EmergencyDisplay.listAll()); }
            if (EmergencyFlg.name().equals(name())) { return toClsList(CDef.EmergencyFlg.listAll()); }
            if (ErrorFlg.name().equals(name())) { return toClsList(CDef.ErrorFlg.listAll()); }
            if (ErrorProcessMet.name().equals(name())) { return toClsList(CDef.ErrorProcessMet.listAll()); }
            if (FixedPoint.name().equals(name())) { return toClsList(CDef.FixedPoint.listAll()); }
            if (ForceFixedFlg.name().equals(name())) { return toClsList(CDef.ForceFixedFlg.listAll()); }
            if (ForeignFlg.name().equals(name())) { return toClsList(CDef.ForeignFlg.listAll()); }
            if (GiftFlg.name().equals(name())) { return toClsList(CDef.GiftFlg.listAll()); }
            if (GiftStatementType.name().equals(name())) { return toClsList(CDef.GiftStatementType.listAll()); }
            if (HtCharReadFlg.name().equals(name())) { return toClsList(CDef.HtCharReadFlg.listAll()); }
            if (ImportFlg.name().equals(name())) { return toClsList(CDef.ImportFlg.listAll()); }
            if (InfoFlg.name().equals(name())) { return toClsList(CDef.InfoFlg.listAll()); }
            if (InoutType.name().equals(name())) { return toClsList(CDef.InoutType.listAll()); }
            if (InputType.name().equals(name())) { return toClsList(CDef.InputType.listAll()); }
            if (InspectionFlg.name().equals(name())) { return toClsList(CDef.InspectionFlg.listAll()); }
            if (InventoryLocationProduct.name().equals(name())) { return toClsList(CDef.InventoryLocationProduct.listAll()); }
            if (InvoiceCreateFlg.name().equals(name())) { return toClsList(CDef.InvoiceCreateFlg.listAll()); }
            if (ItemType.name().equals(name())) { return toClsList(CDef.ItemType.listAll()); }
            if (LastFlg.name().equals(name())) { return toClsList(CDef.LastFlg.listAll()); }
            if (LimitDtManagFlg.name().equals(name())) { return toClsList(CDef.LimitDtManagFlg.listAll()); }
            if (LimitDtReverseFlg.name().equals(name())) { return toClsList(CDef.LimitDtReverseFlg.listAll()); }
            if (LimitMessageCd.name().equals(name())) { return toClsList(CDef.LimitMessageCd.listAll()); }
            if (LineFeedCd.name().equals(name())) { return toClsList(CDef.LineFeedCd.listAll()); }
            if (ListOutFlg.name().equals(name())) { return toClsList(CDef.ListOutFlg.listAll()); }
            if (ListOutKbn.name().equals(name())) { return toClsList(CDef.ListOutKbn.listAll()); }
            if (ListOutFlgDisp.name().equals(name())) { return toClsList(CDef.ListOutFlgDisp.listAll()); }
            if (LoadingFlg.name().equals(name())) { return toClsList(CDef.LoadingFlg.listAll()); }
            if (LocationType.name().equals(name())) { return toClsList(CDef.LocationType.listAll()); }
            if (Lockout.name().equals(name())) { return toClsList(CDef.Lockout.listAll()); }
            if (LogDtlStatus.name().equals(name())) { return toClsList(CDef.LogDtlStatus.listAll()); }
            if (LogDtlType.name().equals(name())) { return toClsList(CDef.LogDtlType.listAll()); }
            if (LogStatus.name().equals(name())) { return toClsList(CDef.LogStatus.listAll()); }
            if (LotManagFlg.name().equals(name())) { return toClsList(CDef.LotManagFlg.listAll()); }
            if (LotReverseFlg.name().equals(name())) { return toClsList(CDef.LotReverseFlg.listAll()); }
            if (MergeCls.name().equals(name())) { return toClsList(CDef.MergeCls.listAll()); }
            if (MergeFlg.name().equals(name())) { return toClsList(CDef.MergeFlg.listAll()); }
            if (MessageType.name().equals(name())) { return toClsList(CDef.MessageType.listAll()); }
            if (MixedFlg.name().equals(name())) { return toClsList(CDef.MixedFlg.listAll()); }
            if (MoveInstStatus.name().equals(name())) { return toClsList(CDef.MoveInstStatus.listAll()); }
            if (MultiPicCls.name().equals(name())) { return toClsList(CDef.MultiPicCls.listAll()); }
            if (MultiPicFlg.name().equals(name())) { return toClsList(CDef.MultiPicFlg.listAll()); }
            if (Necessary.name().equals(name())) { return toClsList(CDef.Necessary.listAll()); }
            if (NoAllcDisplayFlg.name().equals(name())) { return toClsList(CDef.NoAllcDisplayFlg.listAll()); }
            if (NoConfirmedFlg.name().equals(name())) { return toClsList(CDef.NoConfirmedFlg.listAll()); }
            if (NoStockCls.name().equals(name())) { return toClsList(CDef.NoStockCls.listAll()); }
            if (NoStockOutFlg.name().equals(name())) { return toClsList(CDef.NoStockOutFlg.listAll()); }
            if (NoUpsideDownCls.name().equals(name())) { return toClsList(CDef.NoUpsideDownCls.listAll()); }
            if (NotCompletedFlg.name().equals(name())) { return toClsList(CDef.NotCompletedFlg.listAll()); }
            if (OnetimeFlg.name().equals(name())) { return toClsList(CDef.OnetimeFlg.listAll()); }
            if (OverStoreNumFlg.name().equals(name())) { return toClsList(CDef.OverStoreNumFlg.listAll()); }
            if (PackingCalCls.name().equals(name())) { return toClsList(CDef.PackingCalCls.listAll()); }
            if (PackingProcessCls.name().equals(name())) { return toClsList(CDef.PackingProcessCls.listAll()); }
            if (PackingShowFlg.name().equals(name())) { return toClsList(CDef.PackingShowFlg.listAll()); }
            if (PackingStatus.name().equals(name())) { return toClsList(CDef.PackingStatus.listAll()); }
            if (PasswordReset.name().equals(name())) { return toClsList(CDef.PasswordReset.listAll()); }
            if (PastStoreDtFlg.name().equals(name())) { return toClsList(CDef.PastStoreDtFlg.listAll()); }
            if (PhysicalDelete.name().equals(name())) { return toClsList(CDef.PhysicalDelete.listAll()); }
            if (PicCls.name().equals(name())) { return toClsList(CDef.PicCls.listAll()); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return toClsList(CDef.PicMthdRcmdBreakKey.listAll()); }
            if (PicMthdRcmdFlg.name().equals(name())) { return toClsList(CDef.PicMthdRcmdFlg.listAll()); }
            if (PicMthdRcmdListOut.name().equals(name())) { return toClsList(CDef.PicMthdRcmdListOut.listAll()); }
            if (PickingFlg.name().equals(name())) { return toClsList(CDef.PickingFlg.listAll()); }
            if (PickingLocationFlg.name().equals(name())) { return toClsList(CDef.PickingLocationFlg.listAll()); }
            if (PickingStatus.name().equals(name())) { return toClsList(CDef.PickingStatus.listAll()); }
            if (PickingType.name().equals(name())) { return toClsList(CDef.PickingType.listAll()); }
            if (PostType.name().equals(name())) { return toClsList(CDef.PostType.listAll()); }
            if (PrintDataType.name().equals(name())) { return toClsList(CDef.PrintDataType.listAll()); }
            if (PrintErrorFlg.name().equals(name())) { return toClsList(CDef.PrintErrorFlg.listAll()); }
            if (PrintQueueStatus.name().equals(name())) { return toClsList(CDef.PrintQueueStatus.listAll()); }
            if (PrintResultClass.name().equals(name())) { return toClsList(CDef.PrintResultClass.listAll()); }
            if (PrintServiceStatus.name().equals(name())) { return toClsList(CDef.PrintServiceStatus.listAll()); }
            if (PrintStatus.name().equals(name())) { return toClsList(CDef.PrintStatus.listAll()); }
            if (PrintedFlg.name().equals(name())) { return toClsList(CDef.PrintedFlg.listAll()); }
            if (PriorityFlg.name().equals(name())) { return toClsList(CDef.PriorityFlg.listAll()); }
            if (ProductLabelJanBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelJanBarcode.listAll()); }
            if (ProductLabelOutUnit.name().equals(name())) { return toClsList(CDef.ProductLabelOutUnit.listAll()); }
            if (ProductLabelProdBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelProdBarcode.listAll()); }
            if (ProductPartPacking.name().equals(name())) { return toClsList(CDef.ProductPartPacking.listAll()); }
            if (ProductTypeCode.name().equals(name())) { return toClsList(CDef.ProductTypeCode.listAll()); }
            if (Qty0Display.name().equals(name())) { return toClsList(CDef.Qty0Display.listAll()); }
            if (ReasonType.name().equals(name())) { return toClsList(CDef.ReasonType.listAll()); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return toClsList(CDef.ReceiveDeliveryStatus.listAll()); }
            if (ReceiveFlg.name().equals(name())) { return toClsList(CDef.ReceiveFlg.listAll()); }
            if (ReceiveStatus.name().equals(name())) { return toClsList(CDef.ReceiveStatus.listAll()); }
            if (ReplenishAllocCls.name().equals(name())) { return toClsList(CDef.ReplenishAllocCls.listAll()); }
            if (ReplenishProductCdUnset.name().equals(name())) { return toClsList(CDef.ReplenishProductCdUnset.listAll()); }
            if (ReplenishSearchCls.name().equals(name())) { return toClsList(CDef.ReplenishSearchCls.listAll()); }
            if (ReplenishUnitCls.name().equals(name())) { return toClsList(CDef.ReplenishUnitCls.listAll()); }
            if (ReportLayoutItemType.name().equals(name())) { return toClsList(CDef.ReportLayoutItemType.listAll()); }
            if (RestockType.name().equals(name())) { return toClsList(CDef.RestockType.listAll()); }
            if (ResultAfterProductLabel.name().equals(name())) { return toClsList(CDef.ResultAfterProductLabel.listAll()); }
            if (ReverseValidFlg.name().equals(name())) { return toClsList(CDef.ReverseValidFlg.listAll()); }
            if (Select.name().equals(name())) { return toClsList(CDef.Select.listAll()); }
            if (SelectPrintServiceStatus.name().equals(name())) { return toClsList(CDef.SelectPrintServiceStatus.listAll()); }
            if (SerialOperationType.name().equals(name())) { return toClsList(CDef.SerialOperationType.listAll()); }
            if (TargetWindow.name().equals(name())) { return toClsList(CDef.TargetWindow.listAll()); }
            if (SettlementType.name().equals(name())) { return toClsList(CDef.SettlementType.listAll()); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return toClsList(CDef.SglRowInspAfterOutCls.listAll()); }
            if (SglRowPicFlg.name().equals(name())) { return toClsList(CDef.SglRowPicFlg.listAll()); }
            if (SheetCollate.name().equals(name())) { return toClsList(CDef.SheetCollate.listAll()); }
            if (ShippingFlg.name().equals(name())) { return toClsList(CDef.ShippingFlg.listAll()); }
            if (ShippingStatus.name().equals(name())) { return toClsList(CDef.ShippingStatus.listAll()); }
            if (ShippingStopFlg.name().equals(name())) { return toClsList(CDef.ShippingStopFlg.listAll()); }
            if (ShortStockDisplay.name().equals(name())) { return toClsList(CDef.ShortStockDisplay.listAll()); }
            if (ShpCheckCls.name().equals(name())) { return toClsList(CDef.ShpCheckCls.listAll()); }
            if (ShpCheckDisplay.name().equals(name())) { return toClsList(CDef.ShpCheckDisplay.listAll()); }
            if (SlipType.name().equals(name())) { return toClsList(CDef.SlipType.listAll()); }
            if (SoundPlayFlg.name().equals(name())) { return toClsList(CDef.SoundPlayFlg.listAll()); }
            if (StockAdjustFlg.name().equals(name())) { return toClsList(CDef.StockAdjustFlg.listAll()); }
            if (StockDisplayFld.name().equals(name())) { return toClsList(CDef.StockDisplayFld.listAll()); }
            if (StockExistOnlyFlg.name().equals(name())) { return toClsList(CDef.StockExistOnlyFlg.listAll()); }
            if (StockMoveFlg.name().equals(name())) { return toClsList(CDef.StockMoveFlg.listAll()); }
            if (StockNum0Display.name().equals(name())) { return toClsList(CDef.StockNum0Display.listAll()); }
            if (StockOutAllocCls.name().equals(name())) { return toClsList(CDef.StockOutAllocCls.listAll()); }
            if (StockOutAutoInstFlg.name().equals(name())) { return toClsList(CDef.StockOutAutoInstFlg.listAll()); }
            if (StockOutFlg.name().equals(name())) { return toClsList(CDef.StockOutFlg.listAll()); }
            if (StockOutInstCxlFlg.name().equals(name())) { return toClsList(CDef.StockOutInstCxlFlg.listAll()); }
            if (StockOutInstSplitFlg.name().equals(name())) { return toClsList(CDef.StockOutInstSplitFlg.listAll()); }
            if (StockQtyDisplay.name().equals(name())) { return toClsList(CDef.StockQtyDisplay.listAll()); }
            if (StockTakingInput.name().equals(name())) { return toClsList(CDef.StockTakingInput.listAll()); }
            if (StockTarget.name().equals(name())) { return toClsList(CDef.StockTarget.listAll()); }
            if (StoreDtFlg.name().equals(name())) { return toClsList(CDef.StoreDtFlg.listAll()); }
            if (StoreFlg.name().equals(name())) { return toClsList(CDef.StoreFlg.listAll()); }
            if (StoreNoDivideDisplay.name().equals(name())) { return toClsList(CDef.StoreNoDivideDisplay.listAll()); }
            if (StoreNoFlg.name().equals(name())) { return toClsList(CDef.StoreNoFlg.listAll()); }
            if (StoreNoMergeFlg.name().equals(name())) { return toClsList(CDef.StoreNoMergeFlg.listAll()); }
            if (SystemLogStatus.name().equals(name())) { return toClsList(CDef.SystemLogStatus.listAll()); }
            if (SystemLogType.name().equals(name())) { return toClsList(CDef.SystemLogType.listAll()); }
            if (SystemType.name().equals(name())) { return toClsList(CDef.SystemType.listAll()); }
            if (TagDeliveryOutFlg.name().equals(name())) { return toClsList(CDef.TagDeliveryOutFlg.listAll()); }
            if (TakingShippingDtFlg.name().equals(name())) { return toClsList(CDef.TakingShippingDtFlg.listAll()); }
            if (TakingShippingFlg.name().equals(name())) { return toClsList(CDef.TakingShippingFlg.listAll()); }
            if (TextAlign.name().equals(name())) { return toClsList(CDef.TextAlign.listAll()); }
            if (TotalPicFlg.name().equals(name())) { return toClsList(CDef.TotalPicFlg.listAll()); }
            if (TrackingNumberingUnit.name().equals(name())) { return toClsList(CDef.TrackingNumberingUnit.listAll()); }
            if (TransitDisplay.name().equals(name())) { return toClsList(CDef.TransitDisplay.listAll()); }
            if (Unmatch.name().equals(name())) { return toClsList(CDef.Unmatch.listAll()); }
            if (UpdCd.name().equals(name())) { return toClsList(CDef.UpdCd.listAll()); }
            if (UpdType.name().equals(name())) { return toClsList(CDef.UpdType.listAll()); }
            if (Updatable.name().equals(name())) { return toClsList(CDef.Updatable.listAll()); }
            if (UploadTableNm.name().equals(name())) { return toClsList(CDef.UploadTableNm.listAll()); }
            if (UseHtShipFlg.name().equals(name())) { return toClsList(CDef.UseHtShipFlg.listAll()); }
            if (UserEditable.name().equals(name())) { return toClsList(CDef.UserEditable.listAll()); }
            if (VendorFlg.name().equals(name())) { return toClsList(CDef.VendorFlg.listAll()); }
            if (Visible.name().equals(name())) { return toClsList(CDef.Visible.listAll()); }
            if (WorkFlg.name().equals(name())) { return toClsList(CDef.WorkFlg.listAll()); }
            if (WorkMessageFlg.name().equals(name())) { return toClsList(CDef.WorkMessageFlg.listAll()); }
            if (YamatoDelivTz.name().equals(name())) { return toClsList(CDef.YamatoDelivTz.listAll()); }
            if (YupackDelivTz.name().equals(name())) { return toClsList(CDef.YupackDelivTz.listAll()); }
            if (ZipFlg.name().equals(name())) { return toClsList(CDef.ZipFlg.listAll()); }
            if (ResultAfterProductTarget.name().equals(name())) { return toClsList(CDef.ResultAfterProductTarget.listAll()); }
            if (CopyTargetTable.name().equals(name())) { return toClsList(CDef.CopyTargetTable.listAll()); }
            if (InspectionLabelOutFlg.name().equals(name())) { return toClsList(CDef.InspectionLabelOutFlg.listAll()); }
            if (DecimalProductPacking.name().equals(name())) { return toClsList(CDef.DecimalProductPacking.listAll()); }
            if (DecimalExistFlg.name().equals(name())) { return toClsList(CDef.DecimalExistFlg.listAll()); }
            if (CasePickFlg.name().equals(name())) { return toClsList(CDef.CasePickFlg.listAll()); }
            if (EmReplenishShapeFlg.name().equals(name())) { return toClsList(CDef.EmReplenishShapeFlg.listAll()); }
            if (WorkStatus.name().equals(name())) { return toClsList(CDef.WorkStatus.listAll()); }
            if (WorkLogOutFlg.name().equals(name())) { return toClsList(CDef.WorkLogOutFlg.listAll()); }
            if (RoleControlClass.name().equals(name())) { return toClsList(CDef.RoleControlClass.listAll()); }
            if (BolOutFlg.name().equals(name())) { return toClsList(CDef.BolOutFlg.listAll()); }
            if (BolOutputTargetFlg.name().equals(name())) { return toClsList(CDef.BolOutputTargetFlg.listAll()); }
            if (PaymentTerm.name().equals(name())) { return toClsList(CDef.PaymentTerm.listAll()); }
            if (CesIntegrationFlg.name().equals(name())) { return toClsList(CDef.CesIntegrationFlg.listAll()); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return toClsList(CDef.PackingSlipAutoOutputFlg.listAll()); }
            if (FreightCls.name().equals(name())) { return toClsList(CDef.FreightCls.listAll()); }
            if (SatDeliveryFlg.name().equals(name())) { return toClsList(CDef.SatDeliveryFlg.listAll()); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return toClsList(CDef.ResidentialDeliveryFlg.listAll()); }
            if (CodFlg.name().equals(name())) { return toClsList(CDef.CodFlg.listAll()); }
            if (SignatureRequiredFlg.name().equals(name())) { return toClsList(CDef.SignatureRequiredFlg.listAll()); }
            if (SignatureReleaseFlg.name().equals(name())) { return toClsList(CDef.SignatureReleaseFlg.listAll()); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return toClsList(CDef.CallBeforeDeliveryFlg.listAll()); }
            if (FreezableProtectionFlg.name().equals(name())) { return toClsList(CDef.FreezableProtectionFlg.listAll()); }
            if (GuaranteedPlusFlg.name().equals(name())) { return toClsList(CDef.GuaranteedPlusFlg.listAll()); }
            if (ResidentialPickupFlg.name().equals(name())) { return toClsList(CDef.ResidentialPickupFlg.listAll()); }
            if (DoNotStackStackFlg.name().equals(name())) { return toClsList(CDef.DoNotStackStackFlg.listAll()); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessDeliveryFlg.listAll()); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessPickupFlg.listAll()); }
            if (OverSizedFlg.name().equals(name())) { return toClsList(CDef.OverSizedFlg.listAll()); }
            if (PoisonFlg.name().equals(name())) { return toClsList(CDef.PoisonFlg.listAll()); }
            if (FoogFlg.name().equals(name())) { return toClsList(CDef.FoogFlg.listAll()); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryPrepaidFlg.listAll()); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryCollectFlg.listAll()); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupPrepaidFlg.listAll()); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupCollectFlg.listAll()); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryPrepaidFlg.listAll()); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryCollectFlg.listAll()); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsidePickupPrepaidFlg.listAll()); }
            if (InsidePickupCollectFlg.name().equals(name())) { return toClsList(CDef.InsidePickupCollectFlg.listAll()); }
            if (RcmdPickingCls.name().equals(name())) { return toClsList(CDef.RcmdPickingCls.listAll()); }
            if (SglRowPicTarget.name().equals(name())) { return toClsList(CDef.SglRowPicTarget.listAll()); }
            if (CasePicTarget.name().equals(name())) { return toClsList(CDef.CasePicTarget.listAll()); }
            if (AttendanceLeavingRest.name().equals(name())) { return toClsList(CDef.AttendanceLeavingRest.listAll()); }
            if (UploadZipType.name().equals(name())) { return toClsList(CDef.UploadZipType.listAll()); }
            if (FwType.name().equals(name())) { return toClsList(CDef.FwType.listAll()); }
            if (McaType.name().equals(name())) { return toClsList(CDef.McaType.listAll()); }
            if (AccountFlg.name().equals(name())) { return toClsList(CDef.AccountFlg.listAll()); }
            if (AlarmReasonCls.name().equals(name())) { return toClsList(CDef.AlarmReasonCls.listAll()); }
            if (AlarmType.name().equals(name())) { return toClsList(CDef.AlarmType.listAll()); }
            if (AreaCls.name().equals(name())) { return toClsList(CDef.AreaCls.listAll()); }
            if (AssortStatus.name().equals(name())) { return toClsList(CDef.AssortStatus.listAll()); }
            if (BaseCls.name().equals(name())) { return toClsList(CDef.BaseCls.listAll()); }
            if (BoxType.name().equals(name())) { return toClsList(CDef.BoxType.listAll()); }
            if (CarrierType.name().equals(name())) { return toClsList(CDef.CarrierType.listAll()); }
            if (CarrierTypeCd.name().equals(name())) { return toClsList(CDef.CarrierTypeCd.listAll()); }
            if (CaseTypeCd.name().equals(name())) { return toClsList(CDef.CaseTypeCd.listAll()); }
            if (ClosingDt.name().equals(name())) { return toClsList(CDef.ClosingDt.listAll()); }
            if (CompletedHidden.name().equals(name())) { return toClsList(CDef.CompletedHidden.listAll()); }
            if (Condition.name().equals(name())) { return toClsList(CDef.Condition.listAll()); }
            if (Constract.name().equals(name())) { return toClsList(CDef.Constract.listAll()); }
            if (CsPsType.name().equals(name())) { return toClsList(CDef.CsPsType.listAll()); }
            if (DefaultStockType.name().equals(name())) { return toClsList(CDef.DefaultStockType.listAll()); }
            if (DelivCenterFrom.name().equals(name())) { return toClsList(CDef.DelivCenterFrom.listAll()); }
            if (DelivCenterTo.name().equals(name())) { return toClsList(CDef.DelivCenterTo.listAll()); }
            if (DeliveryDtUnspecified.name().equals(name())) { return toClsList(CDef.DeliveryDtUnspecified.listAll()); }
            if (DeliveryTimeZone.name().equals(name())) { return toClsList(CDef.DeliveryTimeZone.listAll()); }
            if (DeliveryTypeSendCls.name().equals(name())) { return toClsList(CDef.DeliveryTypeSendCls.listAll()); }
            if (DepositItemFlg.name().equals(name())) { return toClsList(CDef.DepositItemFlg.listAll()); }
            if (DepositType.name().equals(name())) { return toClsList(CDef.DepositType.listAll()); }
            if (DiffCls.name().equals(name())) { return toClsList(CDef.DiffCls.listAll()); }
            if (DirectDeliveryTypeCd.name().equals(name())) { return toClsList(CDef.DirectDeliveryTypeCd.listAll()); }
            if (EcOrder.name().equals(name())) { return toClsList(CDef.EcOrder.listAll()); }
            if (EcType.name().equals(name())) { return toClsList(CDef.EcType.listAll()); }
            if (ExecuteStatus.name().equals(name())) { return toClsList(CDef.ExecuteStatus.listAll()); }
            if (Fee.name().equals(name())) { return toClsList(CDef.Fee.listAll()); }
            if (Floor.name().equals(name())) { return toClsList(CDef.Floor.listAll()); }
            if (FloorCd.name().equals(name())) { return toClsList(CDef.FloorCd.listAll()); }
            if (FloorEndFlg.name().equals(name())) { return toClsList(CDef.FloorEndFlg.listAll()); }
            if (FloorTypeCd.name().equals(name())) { return toClsList(CDef.FloorTypeCd.listAll()); }
            if (HandOverStatus.name().equals(name())) { return toClsList(CDef.HandOverStatus.listAll()); }
            if (HandlingType.name().equals(name())) { return toClsList(CDef.HandlingType.listAll()); }
            if (HeavyItemFlg.name().equals(name())) { return toClsList(CDef.HeavyItemFlg.listAll()); }
            if (HeavyItemHadlingFlg.name().equals(name())) { return toClsList(CDef.HeavyItemHadlingFlg.listAll()); }
            if (HinmokuGroupCd.name().equals(name())) { return toClsList(CDef.HinmokuGroupCd.listAll()); }
            if (HolidayFlg.name().equals(name())) { return toClsList(CDef.HolidayFlg.listAll()); }
            if (IdManagAbolitionTypeCd.name().equals(name())) { return toClsList(CDef.IdManagAbolitionTypeCd.listAll()); }
            if (InsuranceFlg.name().equals(name())) { return toClsList(CDef.InsuranceFlg.listAll()); }
            if (InventoryDataStatus.name().equals(name())) { return toClsList(CDef.InventoryDataStatus.listAll()); }
            if (InventoryDiffCls.name().equals(name())) { return toClsList(CDef.InventoryDiffCls.listAll()); }
            if (InventoryInputCls.name().equals(name())) { return toClsList(CDef.InventoryInputCls.listAll()); }
            if (InventoryListOutCls.name().equals(name())) { return toClsList(CDef.InventoryListOutCls.listAll()); }
            if (InventoryListType.name().equals(name())) { return toClsList(CDef.InventoryListType.listAll()); }
            if (ItManagType.name().equals(name())) { return toClsList(CDef.ItManagType.listAll()); }
            if (ItemDensan.name().equals(name())) { return toClsList(CDef.ItemDensan.listAll()); }
            if (LargeItemFlg.name().equals(name())) { return toClsList(CDef.LargeItemFlg.listAll()); }
            if (LimitDtSplitTypeCd.name().equals(name())) { return toClsList(CDef.LimitDtSplitTypeCd.listAll()); }
            if (LimitDtUnmatchTypeCd.name().equals(name())) { return toClsList(CDef.LimitDtUnmatchTypeCd.listAll()); }
            if (LogiAttentionTypeCd.name().equals(name())) { return toClsList(CDef.LogiAttentionTypeCd.listAll()); }
            if (LogiSpecialTypeCd.name().equals(name())) { return toClsList(CDef.LogiSpecialTypeCd.listAll()); }
            if (LogiWeightFlg.name().equals(name())) { return toClsList(CDef.LogiWeightFlg.listAll()); }
            if (LotSplitTypeCd.name().equals(name())) { return toClsList(CDef.LotSplitTypeCd.listAll()); }
            if (LotUnmatchTypeCd.name().equals(name())) { return toClsList(CDef.LotUnmatchTypeCd.listAll()); }
            if (MaxStoreShape.name().equals(name())) { return toClsList(CDef.MaxStoreShape.listAll()); }
            if (MedicalManagFlg.name().equals(name())) { return toClsList(CDef.MedicalManagFlg.listAll()); }
            if (MoveDirection.name().equals(name())) { return toClsList(CDef.MoveDirection.listAll()); }
            if (NationalHolidayCarrier.name().equals(name())) { return toClsList(CDef.NationalHolidayCarrier.listAll()); }
            if (NationalHolidayFlg.name().equals(name())) { return toClsList(CDef.NationalHolidayFlg.listAll()); }
            if (NizoroeProcessId.name().equals(name())) { return toClsList(CDef.NizoroeProcessId.listAll()); }
            if (NizoroeProcessIdWms.name().equals(name())) { return toClsList(CDef.NizoroeProcessIdWms.listAll()); }
            if (NizoroeTime.name().equals(name())) { return toClsList(CDef.NizoroeTime.listAll()); }
            if (NizoroeType.name().equals(name())) { return toClsList(CDef.NizoroeType.listAll()); }
            if (NizoroeTypeWms.name().equals(name())) { return toClsList(CDef.NizoroeTypeWms.listAll()); }
            if (NoOkinawaFlightFlg.name().equals(name())) { return toClsList(CDef.NoOkinawaFlightFlg.listAll()); }
            if (OcrDateFormat.name().equals(name())) { return toClsList(CDef.OcrDateFormat.listAll()); }
            if (OutputListType.name().equals(name())) { return toClsList(CDef.OutputListType.listAll()); }
            if (OutputMonth.name().equals(name())) { return toClsList(CDef.OutputMonth.listAll()); }
            if (OutputStatus.name().equals(name())) { return toClsList(CDef.OutputStatus.listAll()); }
            if (PaymentTypeCd.name().equals(name())) { return toClsList(CDef.PaymentTypeCd.listAll()); }
            if (PickingPatternCd.name().equals(name())) { return toClsList(CDef.PickingPatternCd.listAll()); }
            if (Prefecture.name().equals(name())) { return toClsList(CDef.Prefecture.listAll()); }
            if (PriceDiffHidden.name().equals(name())) { return toClsList(CDef.PriceDiffHidden.listAll()); }
            if (ProdDtManagFlg.name().equals(name())) { return toClsList(CDef.ProdDtManagFlg.listAll()); }
            if (ProdDtSplitTypeCd.name().equals(name())) { return toClsList(CDef.ProdDtSplitTypeCd.listAll()); }
            if (ProdDtUnmatchTypeCd.name().equals(name())) { return toClsList(CDef.ProdDtUnmatchTypeCd.listAll()); }
            if (ProductCategoryConvertCls.name().equals(name())) { return toClsList(CDef.ProductCategoryConvertCls.listAll()); }
            if (ProductCategoryPlant.name().equals(name())) { return toClsList(CDef.ProductCategoryPlant.listAll()); }
            if (ProductCategoryType.name().equals(name())) { return toClsList(CDef.ProductCategoryType.listAll()); }
            if (ProductStoreStatus.name().equals(name())) { return toClsList(CDef.ProductStoreStatus.listAll()); }
            if (ProductUnitCls.name().equals(name())) { return toClsList(CDef.ProductUnitCls.listAll()); }
            if (ReceiveReason.name().equals(name())) { return toClsList(CDef.ReceiveReason.listAll()); }
            if (ReceiveReasonConvert.name().equals(name())) { return toClsList(CDef.ReceiveReasonConvert.listAll()); }
            if (ReceiveReasonDepositReceive.name().equals(name())) { return toClsList(CDef.ReceiveReasonDepositReceive.listAll()); }
            if (ReceiveStatus01.name().equals(name())) { return toClsList(CDef.ReceiveStatus01.listAll()); }
            if (RecommendLocationTypeCd.name().equals(name())) { return toClsList(CDef.RecommendLocationTypeCd.listAll()); }
            if (RelatedProducts.name().equals(name())) { return toClsList(CDef.RelatedProducts.listAll()); }
            if (RemainFlg.name().equals(name())) { return toClsList(CDef.RemainFlg.listAll()); }
            if (ReplenishShape.name().equals(name())) { return toClsList(CDef.ReplenishShape.listAll()); }
            if (SampleCls.name().equals(name())) { return toClsList(CDef.SampleCls.listAll()); }
            if (SearchReferenceDt.name().equals(name())) { return toClsList(CDef.SearchReferenceDt.listAll()); }
            if (SerialManagFlg.name().equals(name())) { return toClsList(CDef.SerialManagFlg.listAll()); }
            if (ShapeGrpTypeCd.name().equals(name())) { return toClsList(CDef.ShapeGrpTypeCd.listAll()); }
            if (SharedProductTypeCd.name().equals(name())) { return toClsList(CDef.SharedProductTypeCd.listAll()); }
            if (ShippingInspectionHidden.name().equals(name())) { return toClsList(CDef.ShippingInspectionHidden.listAll()); }
            if (ShippingInspectionStatus.name().equals(name())) { return toClsList(CDef.ShippingInspectionStatus.listAll()); }
            if (ShippingProcessType.name().equals(name())) { return toClsList(CDef.ShippingProcessType.listAll()); }
            if (ShippingProgress.name().equals(name())) { return toClsList(CDef.ShippingProgress.listAll()); }
            if (ShippingReason.name().equals(name())) { return toClsList(CDef.ShippingReason.listAll()); }
            if (ShippingReasonConvert.name().equals(name())) { return toClsList(CDef.ShippingReasonConvert.listAll()); }
            if (ShippingSlipType.name().equals(name())) { return toClsList(CDef.ShippingSlipType.listAll()); }
            if (ShippingType.name().equals(name())) { return toClsList(CDef.ShippingType.listAll()); }
            if (ShippingWorkType.name().equals(name())) { return toClsList(CDef.ShippingWorkType.listAll()); }
            if (SlipType2.name().equals(name())) { return toClsList(CDef.SlipType2.listAll()); }
            if (SpareTypeCd.name().equals(name())) { return toClsList(CDef.SpareTypeCd.listAll()); }
            if (SpecifiedNumOfShoes.name().equals(name())) { return toClsList(CDef.SpecifiedNumOfShoes.listAll()); }
            if (SplitDeliveryTypeCd.name().equals(name())) { return toClsList(CDef.SplitDeliveryTypeCd.listAll()); }
            if (StockDifference.name().equals(name())) { return toClsList(CDef.StockDifference.listAll()); }
            if (StockDisplayType.name().equals(name())) { return toClsList(CDef.StockDisplayType.listAll()); }
            if (StockExist.name().equals(name())) { return toClsList(CDef.StockExist.listAll()); }
            if (StockProcessType.name().equals(name())) { return toClsList(CDef.StockProcessType.listAll()); }
            if (StockRefCls.name().equals(name())) { return toClsList(CDef.StockRefCls.listAll()); }
            if (StockTakingStatus.name().equals(name())) { return toClsList(CDef.StockTakingStatus.listAll()); }
            if (StockZeroDisplay.name().equals(name())) { return toClsList(CDef.StockZeroDisplay.listAll()); }
            if (SuppliesVarietyFlg.name().equals(name())) { return toClsList(CDef.SuppliesVarietyFlg.listAll()); }
            if (TargetBase.name().equals(name())) { return toClsList(CDef.TargetBase.listAll()); }
            if (TargetItemCd.name().equals(name())) { return toClsList(CDef.TargetItemCd.listAll()); }
            if (TargetKoguchiCd.name().equals(name())) { return toClsList(CDef.TargetKoguchiCd.listAll()); }
            if (TargetSalesCd.name().equals(name())) { return toClsList(CDef.TargetSalesCd.listAll()); }
            if (UnitCls.name().equals(name())) { return toClsList(CDef.UnitCls.listAll()); }
            if (UrgentShippingTimeZone.name().equals(name())) { return toClsList(CDef.UrgentShippingTimeZone.listAll()); }
            if (WorkType.name().equals(name())) { return toClsList(CDef.WorkType.listAll()); }
            if (ReceiveLabelFlg.name().equals(name())) { return toClsList(CDef.ReceiveLabelFlg.listAll()); }
            if (ReceiveDtUnmatchFlg.name().equals(name())) { return toClsList(CDef.ReceiveDtUnmatchFlg.listAll()); }
            if (PrintFlg.name().equals(name())) { return toClsList(CDef.PrintFlg.listAll()); }
            if (ReceiveRemainFlg.name().equals(name())) { return toClsList(CDef.ReceiveRemainFlg.listAll()); }
            if (ShippingPickedHidden.name().equals(name())) { return toClsList(CDef.ShippingPickedHidden.listAll()); }
            if (CarrierDataOutFlg.name().equals(name())) { return toClsList(CDef.CarrierDataOutFlg.listAll()); }
            if (PllOutFlg.name().equals(name())) { return toClsList(CDef.PllOutFlg.listAll()); }
            if (DepositorCls.name().equals(name())) { return toClsList(CDef.DepositorCls.listAll()); }
            if (RplOutFlg.name().equals(name())) { return toClsList(CDef.RplOutFlg.listAll()); }
            if (RecordSendFlg.name().equals(name())) { return toClsList(CDef.RecordSendFlg.listAll()); }
            if (HandOverHidden.name().equals(name())) { return toClsList(CDef.HandOverHidden.listAll()); }
            if (ExternalWarehouseFlg.name().equals(name())) { return toClsList(CDef.ExternalWarehouseFlg.listAll()); }
            if (StandardPlantCls.name().equals(name())) { return toClsList(CDef.StandardPlantCls.listAll()); }
            if (LargeItemHadlingFlg.name().equals(name())) { return toClsList(CDef.LargeItemHadlingFlg.listAll()); }
            if (HolidayCarrierFlg.name().equals(name())) { return toClsList(CDef.HolidayCarrierFlg.listAll()); }
            if (OkinawaFlightFlg.name().equals(name())) { return toClsList(CDef.OkinawaFlightFlg.listAll()); }
            if (BaseDefaultCarrierFlg.name().equals(name())) { return toClsList(CDef.BaseDefaultCarrierFlg.listAll()); }
            if (SlipTypeCd.name().equals(name())) { return toClsList(CDef.SlipTypeCd.listAll()); }
            if (ProperFlg.name().equals(name())) { return toClsList(CDef.ProperFlg.listAll()); }
            if (CdlOutFlg.name().equals(name())) { return toClsList(CDef.CdlOutFlg.listAll()); }
            if (ErrorNum.name().equals(name())) { return toClsList(CDef.ErrorNum.listAll()); }
            if (CenterPicListCls1.name().equals(name())) { return toClsList(CDef.CenterPicListCls1.listAll()); }
            if (CenterPicListCls2.name().equals(name())) { return toClsList(CDef.CenterPicListCls2.listAll()); }
            if (CenterPicListCls3.name().equals(name())) { return toClsList(CDef.CenterPicListCls3.listAll()); }
            if (CenterSagawaDelivTz.name().equals(name())) { return toClsList(CDef.CenterSagawaDelivTz.listAll()); }
            if (CenterTransportTypeItem.name().equals(name())) { return toClsList(CDef.CenterTransportTypeItem.listAll()); }
            if (CenterSlipShapeCd.name().equals(name())) { return toClsList(CDef.CenterSlipShapeCd.listAll()); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return toClsList(CDef.CenterTransportTypeSpeed.listAll()); }
            if (CenterSealType.name().equals(name())) { return toClsList(CDef.CenterSealType.listAll()); }
            if (CenterTagClass.name().equals(name())) { return toClsList(CDef.CenterTagClass.listAll()); }
            if (CenterTagDataType.name().equals(name())) { return toClsList(CDef.CenterTagDataType.listAll()); }
            if (CenterTagType.name().equals(name())) { return toClsList(CDef.CenterTagType.listAll()); }
            if (CenterTagTypeAfter.name().equals(name())) { return toClsList(CDef.CenterTagTypeAfter.listAll()); }
            if (CenterApiBinsyuCode.name().equals(name())) { return toClsList(CDef.CenterApiBinsyuCode.listAll()); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiFlg.listAll()); }
            if (CenterApiDaibikiType.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiType.listAll()); }
            if (CenterApiEidomeFlg.name().equals(name())) { return toClsList(CDef.CenterApiEidomeFlg.listAll()); }
            if (CenterApiWeightCd.name().equals(name())) { return toClsList(CDef.CenterApiWeightCd.listAll()); }
            if (CenterOutputTargetFlg.name().equals(name())) { return toClsList(CDef.CenterOutputTargetFlg.listAll()); }
            if (CenterPrintCondition.name().equals(name())) { return toClsList(CDef.CenterPrintCondition.listAll()); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        public List<Classification> listByGroup(String groupName) { // exception if not found
            if (ProcessTypeCd.name().equals(name())) { return toClsList(CDef.ProcessTypeCd.listByGroup(groupName)); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return toClsList(CDef.AfterDelivSlipOutTgt.listByGroup(groupName)); }
            if (AfterTagOutFlg.name().equals(name())) { return toClsList(CDef.AfterTagOutFlg.listByGroup(groupName)); }
            if (AllShippingFlg.name().equals(name())) { return toClsList(CDef.AllShippingFlg.listByGroup(groupName)); }
            if (AllcNgDisplay.name().equals(name())) { return toClsList(CDef.AllcNgDisplay.listByGroup(groupName)); }
            if (AllcNgFlg.name().equals(name())) { return toClsList(CDef.AllcNgFlg.listByGroup(groupName)); }
            if (AllocSortKey.name().equals(name())) { return toClsList(CDef.AllocSortKey.listByGroup(groupName)); }
            if (ArrivalStoreFormat.name().equals(name())) { return toClsList(CDef.ArrivalStoreFormat.listByGroup(groupName)); }
            if (AutoEmgSetFlg.name().equals(name())) { return toClsList(CDef.AutoEmgSetFlg.listByGroup(groupName)); }
            if (AutoEmgSetTgt.name().equals(name())) { return toClsList(CDef.AutoEmgSetTgt.listByGroup(groupName)); }
            if (AutoPrintTargetFlg.name().equals(name())) { return toClsList(CDef.AutoPrintTargetFlg.listByGroup(groupName)); }
            if (AutoShipInstFlg.name().equals(name())) { return toClsList(CDef.AutoShipInstFlg.listByGroup(groupName)); }
            if (BarcodeType.name().equals(name())) { return toClsList(CDef.BarcodeType.listByGroup(groupName)); }
            if (BatchProgressFlg.name().equals(name())) { return toClsList(CDef.BatchProgressFlg.listByGroup(groupName)); }
            if (BoxSelectSkip.name().equals(name())) { return toClsList(CDef.BoxSelectSkip.listByGroup(groupName)); }
            if (CancelDataDisplay.name().equals(name())) { return toClsList(CDef.CancelDataDisplay.listByGroup(groupName)); }
            if (CasePicFlg.name().equals(name())) { return toClsList(CDef.CasePicFlg.listByGroup(groupName)); }
            if (CenterClientCls.name().equals(name())) { return toClsList(CDef.CenterClientCls.listByGroup(groupName)); }
            if (CenterTransitFlg.name().equals(name())) { return toClsList(CDef.CenterTransitFlg.listByGroup(groupName)); }
            if (CharacterCd.name().equals(name())) { return toClsList(CDef.CharacterCd.listByGroup(groupName)); }
            if (ChargeQty0Display.name().equals(name())) { return toClsList(CDef.ChargeQty0Display.listByGroup(groupName)); }
            if (CheckDigit.name().equals(name())) { return toClsList(CDef.CheckDigit.listByGroup(groupName)); }
            if (CodCls.name().equals(name())) { return toClsList(CDef.CodCls.listByGroup(groupName)); }
            if (CodType.name().equals(name())) { return toClsList(CDef.CodType.listByGroup(groupName)); }
            if (CodeFlg.name().equals(name())) { return toClsList(CDef.CodeFlg.listByGroup(groupName)); }
            if (CodeType.name().equals(name())) { return toClsList(CDef.CodeType.listByGroup(groupName)); }
            if (ColType.name().equals(name())) { return toClsList(CDef.ColType.listByGroup(groupName)); }
            if (CommentFlg.name().equals(name())) { return toClsList(CDef.CommentFlg.listByGroup(groupName)); }
            if (CompanyFlg.name().equals(name())) { return toClsList(CDef.CompanyFlg.listByGroup(groupName)); }
            if (CoolCls.name().equals(name())) { return toClsList(CDef.CoolCls.listByGroup(groupName)); }
            if (CoolType.name().equals(name())) { return toClsList(CDef.CoolType.listByGroup(groupName)); }
            if (CorrectType.name().equals(name())) { return toClsList(CDef.CorrectType.listByGroup(groupName)); }
            if (DataInputCommitType.name().equals(name())) { return toClsList(CDef.DataInputCommitType.listByGroup(groupName)); }
            if (DataInputOperationType.name().equals(name())) { return toClsList(CDef.DataInputOperationType.listByGroup(groupName)); }
            if (DataInputProcessType.name().equals(name())) { return toClsList(CDef.DataInputProcessType.listByGroup(groupName)); }
            if (DataInputRange.name().equals(name())) { return toClsList(CDef.DataInputRange.listByGroup(groupName)); }
            if (DataInputType.name().equals(name())) { return toClsList(CDef.DataInputType.listByGroup(groupName)); }
            if (DataType.name().equals(name())) { return toClsList(CDef.DataType.listByGroup(groupName)); }
            if (Default.name().equals(name())) { return toClsList(CDef.Default.listByGroup(groupName)); }
            if (DefaultFlg.name().equals(name())) { return toClsList(CDef.DefaultFlg.listByGroup(groupName)); }
            if (DelFlg.name().equals(name())) { return toClsList(CDef.DelFlg.listByGroup(groupName)); }
            if (DeleteDataDisplay.name().equals(name())) { return toClsList(CDef.DeleteDataDisplay.listByGroup(groupName)); }
            if (DelivMatchFlg.name().equals(name())) { return toClsList(CDef.DelivMatchFlg.listByGroup(groupName)); }
            if (DelivTz.name().equals(name())) { return toClsList(CDef.DelivTz.listByGroup(groupName)); }
            if (DeliveryFlg.name().equals(name())) { return toClsList(CDef.DeliveryFlg.listByGroup(groupName)); }
            if (DepositFlg.name().equals(name())) { return toClsList(CDef.DepositFlg.listByGroup(groupName)); }
            if (DisplayRequired.name().equals(name())) { return toClsList(CDef.DisplayRequired.listByGroup(groupName)); }
            if (DtCls.name().equals(name())) { return toClsList(CDef.DtCls.listByGroup(groupName)); }
            if (Editable.name().equals(name())) { return toClsList(CDef.Editable.listByGroup(groupName)); }
            if (EmergencyDisplay.name().equals(name())) { return toClsList(CDef.EmergencyDisplay.listByGroup(groupName)); }
            if (EmergencyFlg.name().equals(name())) { return toClsList(CDef.EmergencyFlg.listByGroup(groupName)); }
            if (ErrorFlg.name().equals(name())) { return toClsList(CDef.ErrorFlg.listByGroup(groupName)); }
            if (ErrorProcessMet.name().equals(name())) { return toClsList(CDef.ErrorProcessMet.listByGroup(groupName)); }
            if (FixedPoint.name().equals(name())) { return toClsList(CDef.FixedPoint.listByGroup(groupName)); }
            if (ForceFixedFlg.name().equals(name())) { return toClsList(CDef.ForceFixedFlg.listByGroup(groupName)); }
            if (ForeignFlg.name().equals(name())) { return toClsList(CDef.ForeignFlg.listByGroup(groupName)); }
            if (GiftFlg.name().equals(name())) { return toClsList(CDef.GiftFlg.listByGroup(groupName)); }
            if (GiftStatementType.name().equals(name())) { return toClsList(CDef.GiftStatementType.listByGroup(groupName)); }
            if (HtCharReadFlg.name().equals(name())) { return toClsList(CDef.HtCharReadFlg.listByGroup(groupName)); }
            if (ImportFlg.name().equals(name())) { return toClsList(CDef.ImportFlg.listByGroup(groupName)); }
            if (InfoFlg.name().equals(name())) { return toClsList(CDef.InfoFlg.listByGroup(groupName)); }
            if (InoutType.name().equals(name())) { return toClsList(CDef.InoutType.listByGroup(groupName)); }
            if (InputType.name().equals(name())) { return toClsList(CDef.InputType.listByGroup(groupName)); }
            if (InspectionFlg.name().equals(name())) { return toClsList(CDef.InspectionFlg.listByGroup(groupName)); }
            if (InventoryLocationProduct.name().equals(name())) { return toClsList(CDef.InventoryLocationProduct.listByGroup(groupName)); }
            if (InvoiceCreateFlg.name().equals(name())) { return toClsList(CDef.InvoiceCreateFlg.listByGroup(groupName)); }
            if (ItemType.name().equals(name())) { return toClsList(CDef.ItemType.listByGroup(groupName)); }
            if (LastFlg.name().equals(name())) { return toClsList(CDef.LastFlg.listByGroup(groupName)); }
            if (LimitDtManagFlg.name().equals(name())) { return toClsList(CDef.LimitDtManagFlg.listByGroup(groupName)); }
            if (LimitDtReverseFlg.name().equals(name())) { return toClsList(CDef.LimitDtReverseFlg.listByGroup(groupName)); }
            if (LimitMessageCd.name().equals(name())) { return toClsList(CDef.LimitMessageCd.listByGroup(groupName)); }
            if (LineFeedCd.name().equals(name())) { return toClsList(CDef.LineFeedCd.listByGroup(groupName)); }
            if (ListOutFlg.name().equals(name())) { return toClsList(CDef.ListOutFlg.listByGroup(groupName)); }
            if (ListOutKbn.name().equals(name())) { return toClsList(CDef.ListOutKbn.listByGroup(groupName)); }
            if (ListOutFlgDisp.name().equals(name())) { return toClsList(CDef.ListOutFlgDisp.listByGroup(groupName)); }
            if (LoadingFlg.name().equals(name())) { return toClsList(CDef.LoadingFlg.listByGroup(groupName)); }
            if (LocationType.name().equals(name())) { return toClsList(CDef.LocationType.listByGroup(groupName)); }
            if (Lockout.name().equals(name())) { return toClsList(CDef.Lockout.listByGroup(groupName)); }
            if (LogDtlStatus.name().equals(name())) { return toClsList(CDef.LogDtlStatus.listByGroup(groupName)); }
            if (LogDtlType.name().equals(name())) { return toClsList(CDef.LogDtlType.listByGroup(groupName)); }
            if (LogStatus.name().equals(name())) { return toClsList(CDef.LogStatus.listByGroup(groupName)); }
            if (LotManagFlg.name().equals(name())) { return toClsList(CDef.LotManagFlg.listByGroup(groupName)); }
            if (LotReverseFlg.name().equals(name())) { return toClsList(CDef.LotReverseFlg.listByGroup(groupName)); }
            if (MergeCls.name().equals(name())) { return toClsList(CDef.MergeCls.listByGroup(groupName)); }
            if (MergeFlg.name().equals(name())) { return toClsList(CDef.MergeFlg.listByGroup(groupName)); }
            if (MessageType.name().equals(name())) { return toClsList(CDef.MessageType.listByGroup(groupName)); }
            if (MixedFlg.name().equals(name())) { return toClsList(CDef.MixedFlg.listByGroup(groupName)); }
            if (MoveInstStatus.name().equals(name())) { return toClsList(CDef.MoveInstStatus.listByGroup(groupName)); }
            if (MultiPicCls.name().equals(name())) { return toClsList(CDef.MultiPicCls.listByGroup(groupName)); }
            if (MultiPicFlg.name().equals(name())) { return toClsList(CDef.MultiPicFlg.listByGroup(groupName)); }
            if (Necessary.name().equals(name())) { return toClsList(CDef.Necessary.listByGroup(groupName)); }
            if (NoAllcDisplayFlg.name().equals(name())) { return toClsList(CDef.NoAllcDisplayFlg.listByGroup(groupName)); }
            if (NoConfirmedFlg.name().equals(name())) { return toClsList(CDef.NoConfirmedFlg.listByGroup(groupName)); }
            if (NoStockCls.name().equals(name())) { return toClsList(CDef.NoStockCls.listByGroup(groupName)); }
            if (NoStockOutFlg.name().equals(name())) { return toClsList(CDef.NoStockOutFlg.listByGroup(groupName)); }
            if (NoUpsideDownCls.name().equals(name())) { return toClsList(CDef.NoUpsideDownCls.listByGroup(groupName)); }
            if (NotCompletedFlg.name().equals(name())) { return toClsList(CDef.NotCompletedFlg.listByGroup(groupName)); }
            if (OnetimeFlg.name().equals(name())) { return toClsList(CDef.OnetimeFlg.listByGroup(groupName)); }
            if (OverStoreNumFlg.name().equals(name())) { return toClsList(CDef.OverStoreNumFlg.listByGroup(groupName)); }
            if (PackingCalCls.name().equals(name())) { return toClsList(CDef.PackingCalCls.listByGroup(groupName)); }
            if (PackingProcessCls.name().equals(name())) { return toClsList(CDef.PackingProcessCls.listByGroup(groupName)); }
            if (PackingShowFlg.name().equals(name())) { return toClsList(CDef.PackingShowFlg.listByGroup(groupName)); }
            if (PackingStatus.name().equals(name())) { return toClsList(CDef.PackingStatus.listByGroup(groupName)); }
            if (PasswordReset.name().equals(name())) { return toClsList(CDef.PasswordReset.listByGroup(groupName)); }
            if (PastStoreDtFlg.name().equals(name())) { return toClsList(CDef.PastStoreDtFlg.listByGroup(groupName)); }
            if (PhysicalDelete.name().equals(name())) { return toClsList(CDef.PhysicalDelete.listByGroup(groupName)); }
            if (PicCls.name().equals(name())) { return toClsList(CDef.PicCls.listByGroup(groupName)); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return toClsList(CDef.PicMthdRcmdBreakKey.listByGroup(groupName)); }
            if (PicMthdRcmdFlg.name().equals(name())) { return toClsList(CDef.PicMthdRcmdFlg.listByGroup(groupName)); }
            if (PicMthdRcmdListOut.name().equals(name())) { return toClsList(CDef.PicMthdRcmdListOut.listByGroup(groupName)); }
            if (PickingFlg.name().equals(name())) { return toClsList(CDef.PickingFlg.listByGroup(groupName)); }
            if (PickingLocationFlg.name().equals(name())) { return toClsList(CDef.PickingLocationFlg.listByGroup(groupName)); }
            if (PickingStatus.name().equals(name())) { return toClsList(CDef.PickingStatus.listByGroup(groupName)); }
            if (PickingType.name().equals(name())) { return toClsList(CDef.PickingType.listByGroup(groupName)); }
            if (PostType.name().equals(name())) { return toClsList(CDef.PostType.listByGroup(groupName)); }
            if (PrintDataType.name().equals(name())) { return toClsList(CDef.PrintDataType.listByGroup(groupName)); }
            if (PrintErrorFlg.name().equals(name())) { return toClsList(CDef.PrintErrorFlg.listByGroup(groupName)); }
            if (PrintQueueStatus.name().equals(name())) { return toClsList(CDef.PrintQueueStatus.listByGroup(groupName)); }
            if (PrintResultClass.name().equals(name())) { return toClsList(CDef.PrintResultClass.listByGroup(groupName)); }
            if (PrintServiceStatus.name().equals(name())) { return toClsList(CDef.PrintServiceStatus.listByGroup(groupName)); }
            if (PrintStatus.name().equals(name())) { return toClsList(CDef.PrintStatus.listByGroup(groupName)); }
            if (PrintedFlg.name().equals(name())) { return toClsList(CDef.PrintedFlg.listByGroup(groupName)); }
            if (PriorityFlg.name().equals(name())) { return toClsList(CDef.PriorityFlg.listByGroup(groupName)); }
            if (ProductLabelJanBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelJanBarcode.listByGroup(groupName)); }
            if (ProductLabelOutUnit.name().equals(name())) { return toClsList(CDef.ProductLabelOutUnit.listByGroup(groupName)); }
            if (ProductLabelProdBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelProdBarcode.listByGroup(groupName)); }
            if (ProductPartPacking.name().equals(name())) { return toClsList(CDef.ProductPartPacking.listByGroup(groupName)); }
            if (ProductTypeCode.name().equals(name())) { return toClsList(CDef.ProductTypeCode.listByGroup(groupName)); }
            if (Qty0Display.name().equals(name())) { return toClsList(CDef.Qty0Display.listByGroup(groupName)); }
            if (ReasonType.name().equals(name())) { return toClsList(CDef.ReasonType.listByGroup(groupName)); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return toClsList(CDef.ReceiveDeliveryStatus.listByGroup(groupName)); }
            if (ReceiveFlg.name().equals(name())) { return toClsList(CDef.ReceiveFlg.listByGroup(groupName)); }
            if (ReceiveStatus.name().equals(name())) { return toClsList(CDef.ReceiveStatus.listByGroup(groupName)); }
            if (ReplenishAllocCls.name().equals(name())) { return toClsList(CDef.ReplenishAllocCls.listByGroup(groupName)); }
            if (ReplenishProductCdUnset.name().equals(name())) { return toClsList(CDef.ReplenishProductCdUnset.listByGroup(groupName)); }
            if (ReplenishSearchCls.name().equals(name())) { return toClsList(CDef.ReplenishSearchCls.listByGroup(groupName)); }
            if (ReplenishUnitCls.name().equals(name())) { return toClsList(CDef.ReplenishUnitCls.listByGroup(groupName)); }
            if (ReportLayoutItemType.name().equals(name())) { return toClsList(CDef.ReportLayoutItemType.listByGroup(groupName)); }
            if (RestockType.name().equals(name())) { return toClsList(CDef.RestockType.listByGroup(groupName)); }
            if (ResultAfterProductLabel.name().equals(name())) { return toClsList(CDef.ResultAfterProductLabel.listByGroup(groupName)); }
            if (ReverseValidFlg.name().equals(name())) { return toClsList(CDef.ReverseValidFlg.listByGroup(groupName)); }
            if (Select.name().equals(name())) { return toClsList(CDef.Select.listByGroup(groupName)); }
            if (SelectPrintServiceStatus.name().equals(name())) { return toClsList(CDef.SelectPrintServiceStatus.listByGroup(groupName)); }
            if (SerialOperationType.name().equals(name())) { return toClsList(CDef.SerialOperationType.listByGroup(groupName)); }
            if (TargetWindow.name().equals(name())) { return toClsList(CDef.TargetWindow.listByGroup(groupName)); }
            if (SettlementType.name().equals(name())) { return toClsList(CDef.SettlementType.listByGroup(groupName)); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return toClsList(CDef.SglRowInspAfterOutCls.listByGroup(groupName)); }
            if (SglRowPicFlg.name().equals(name())) { return toClsList(CDef.SglRowPicFlg.listByGroup(groupName)); }
            if (SheetCollate.name().equals(name())) { return toClsList(CDef.SheetCollate.listByGroup(groupName)); }
            if (ShippingFlg.name().equals(name())) { return toClsList(CDef.ShippingFlg.listByGroup(groupName)); }
            if (ShippingStatus.name().equals(name())) { return toClsList(CDef.ShippingStatus.listByGroup(groupName)); }
            if (ShippingStopFlg.name().equals(name())) { return toClsList(CDef.ShippingStopFlg.listByGroup(groupName)); }
            if (ShortStockDisplay.name().equals(name())) { return toClsList(CDef.ShortStockDisplay.listByGroup(groupName)); }
            if (ShpCheckCls.name().equals(name())) { return toClsList(CDef.ShpCheckCls.listByGroup(groupName)); }
            if (ShpCheckDisplay.name().equals(name())) { return toClsList(CDef.ShpCheckDisplay.listByGroup(groupName)); }
            if (SlipType.name().equals(name())) { return toClsList(CDef.SlipType.listByGroup(groupName)); }
            if (SoundPlayFlg.name().equals(name())) { return toClsList(CDef.SoundPlayFlg.listByGroup(groupName)); }
            if (StockAdjustFlg.name().equals(name())) { return toClsList(CDef.StockAdjustFlg.listByGroup(groupName)); }
            if (StockDisplayFld.name().equals(name())) { return toClsList(CDef.StockDisplayFld.listByGroup(groupName)); }
            if (StockExistOnlyFlg.name().equals(name())) { return toClsList(CDef.StockExistOnlyFlg.listByGroup(groupName)); }
            if (StockMoveFlg.name().equals(name())) { return toClsList(CDef.StockMoveFlg.listByGroup(groupName)); }
            if (StockNum0Display.name().equals(name())) { return toClsList(CDef.StockNum0Display.listByGroup(groupName)); }
            if (StockOutAllocCls.name().equals(name())) { return toClsList(CDef.StockOutAllocCls.listByGroup(groupName)); }
            if (StockOutAutoInstFlg.name().equals(name())) { return toClsList(CDef.StockOutAutoInstFlg.listByGroup(groupName)); }
            if (StockOutFlg.name().equals(name())) { return toClsList(CDef.StockOutFlg.listByGroup(groupName)); }
            if (StockOutInstCxlFlg.name().equals(name())) { return toClsList(CDef.StockOutInstCxlFlg.listByGroup(groupName)); }
            if (StockOutInstSplitFlg.name().equals(name())) { return toClsList(CDef.StockOutInstSplitFlg.listByGroup(groupName)); }
            if (StockQtyDisplay.name().equals(name())) { return toClsList(CDef.StockQtyDisplay.listByGroup(groupName)); }
            if (StockTakingInput.name().equals(name())) { return toClsList(CDef.StockTakingInput.listByGroup(groupName)); }
            if (StockTarget.name().equals(name())) { return toClsList(CDef.StockTarget.listByGroup(groupName)); }
            if (StoreDtFlg.name().equals(name())) { return toClsList(CDef.StoreDtFlg.listByGroup(groupName)); }
            if (StoreFlg.name().equals(name())) { return toClsList(CDef.StoreFlg.listByGroup(groupName)); }
            if (StoreNoDivideDisplay.name().equals(name())) { return toClsList(CDef.StoreNoDivideDisplay.listByGroup(groupName)); }
            if (StoreNoFlg.name().equals(name())) { return toClsList(CDef.StoreNoFlg.listByGroup(groupName)); }
            if (StoreNoMergeFlg.name().equals(name())) { return toClsList(CDef.StoreNoMergeFlg.listByGroup(groupName)); }
            if (SystemLogStatus.name().equals(name())) { return toClsList(CDef.SystemLogStatus.listByGroup(groupName)); }
            if (SystemLogType.name().equals(name())) { return toClsList(CDef.SystemLogType.listByGroup(groupName)); }
            if (SystemType.name().equals(name())) { return toClsList(CDef.SystemType.listByGroup(groupName)); }
            if (TagDeliveryOutFlg.name().equals(name())) { return toClsList(CDef.TagDeliveryOutFlg.listByGroup(groupName)); }
            if (TakingShippingDtFlg.name().equals(name())) { return toClsList(CDef.TakingShippingDtFlg.listByGroup(groupName)); }
            if (TakingShippingFlg.name().equals(name())) { return toClsList(CDef.TakingShippingFlg.listByGroup(groupName)); }
            if (TextAlign.name().equals(name())) { return toClsList(CDef.TextAlign.listByGroup(groupName)); }
            if (TotalPicFlg.name().equals(name())) { return toClsList(CDef.TotalPicFlg.listByGroup(groupName)); }
            if (TrackingNumberingUnit.name().equals(name())) { return toClsList(CDef.TrackingNumberingUnit.listByGroup(groupName)); }
            if (TransitDisplay.name().equals(name())) { return toClsList(CDef.TransitDisplay.listByGroup(groupName)); }
            if (Unmatch.name().equals(name())) { return toClsList(CDef.Unmatch.listByGroup(groupName)); }
            if (UpdCd.name().equals(name())) { return toClsList(CDef.UpdCd.listByGroup(groupName)); }
            if (UpdType.name().equals(name())) { return toClsList(CDef.UpdType.listByGroup(groupName)); }
            if (Updatable.name().equals(name())) { return toClsList(CDef.Updatable.listByGroup(groupName)); }
            if (UploadTableNm.name().equals(name())) { return toClsList(CDef.UploadTableNm.listByGroup(groupName)); }
            if (UseHtShipFlg.name().equals(name())) { return toClsList(CDef.UseHtShipFlg.listByGroup(groupName)); }
            if (UserEditable.name().equals(name())) { return toClsList(CDef.UserEditable.listByGroup(groupName)); }
            if (VendorFlg.name().equals(name())) { return toClsList(CDef.VendorFlg.listByGroup(groupName)); }
            if (Visible.name().equals(name())) { return toClsList(CDef.Visible.listByGroup(groupName)); }
            if (WorkFlg.name().equals(name())) { return toClsList(CDef.WorkFlg.listByGroup(groupName)); }
            if (WorkMessageFlg.name().equals(name())) { return toClsList(CDef.WorkMessageFlg.listByGroup(groupName)); }
            if (YamatoDelivTz.name().equals(name())) { return toClsList(CDef.YamatoDelivTz.listByGroup(groupName)); }
            if (YupackDelivTz.name().equals(name())) { return toClsList(CDef.YupackDelivTz.listByGroup(groupName)); }
            if (ZipFlg.name().equals(name())) { return toClsList(CDef.ZipFlg.listByGroup(groupName)); }
            if (ResultAfterProductTarget.name().equals(name())) { return toClsList(CDef.ResultAfterProductTarget.listByGroup(groupName)); }
            if (CopyTargetTable.name().equals(name())) { return toClsList(CDef.CopyTargetTable.listByGroup(groupName)); }
            if (InspectionLabelOutFlg.name().equals(name())) { return toClsList(CDef.InspectionLabelOutFlg.listByGroup(groupName)); }
            if (DecimalProductPacking.name().equals(name())) { return toClsList(CDef.DecimalProductPacking.listByGroup(groupName)); }
            if (DecimalExistFlg.name().equals(name())) { return toClsList(CDef.DecimalExistFlg.listByGroup(groupName)); }
            if (CasePickFlg.name().equals(name())) { return toClsList(CDef.CasePickFlg.listByGroup(groupName)); }
            if (EmReplenishShapeFlg.name().equals(name())) { return toClsList(CDef.EmReplenishShapeFlg.listByGroup(groupName)); }
            if (WorkStatus.name().equals(name())) { return toClsList(CDef.WorkStatus.listByGroup(groupName)); }
            if (WorkLogOutFlg.name().equals(name())) { return toClsList(CDef.WorkLogOutFlg.listByGroup(groupName)); }
            if (RoleControlClass.name().equals(name())) { return toClsList(CDef.RoleControlClass.listByGroup(groupName)); }
            if (BolOutFlg.name().equals(name())) { return toClsList(CDef.BolOutFlg.listByGroup(groupName)); }
            if (BolOutputTargetFlg.name().equals(name())) { return toClsList(CDef.BolOutputTargetFlg.listByGroup(groupName)); }
            if (PaymentTerm.name().equals(name())) { return toClsList(CDef.PaymentTerm.listByGroup(groupName)); }
            if (CesIntegrationFlg.name().equals(name())) { return toClsList(CDef.CesIntegrationFlg.listByGroup(groupName)); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return toClsList(CDef.PackingSlipAutoOutputFlg.listByGroup(groupName)); }
            if (FreightCls.name().equals(name())) { return toClsList(CDef.FreightCls.listByGroup(groupName)); }
            if (SatDeliveryFlg.name().equals(name())) { return toClsList(CDef.SatDeliveryFlg.listByGroup(groupName)); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return toClsList(CDef.ResidentialDeliveryFlg.listByGroup(groupName)); }
            if (CodFlg.name().equals(name())) { return toClsList(CDef.CodFlg.listByGroup(groupName)); }
            if (SignatureRequiredFlg.name().equals(name())) { return toClsList(CDef.SignatureRequiredFlg.listByGroup(groupName)); }
            if (SignatureReleaseFlg.name().equals(name())) { return toClsList(CDef.SignatureReleaseFlg.listByGroup(groupName)); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return toClsList(CDef.CallBeforeDeliveryFlg.listByGroup(groupName)); }
            if (FreezableProtectionFlg.name().equals(name())) { return toClsList(CDef.FreezableProtectionFlg.listByGroup(groupName)); }
            if (GuaranteedPlusFlg.name().equals(name())) { return toClsList(CDef.GuaranteedPlusFlg.listByGroup(groupName)); }
            if (ResidentialPickupFlg.name().equals(name())) { return toClsList(CDef.ResidentialPickupFlg.listByGroup(groupName)); }
            if (DoNotStackStackFlg.name().equals(name())) { return toClsList(CDef.DoNotStackStackFlg.listByGroup(groupName)); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessDeliveryFlg.listByGroup(groupName)); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessPickupFlg.listByGroup(groupName)); }
            if (OverSizedFlg.name().equals(name())) { return toClsList(CDef.OverSizedFlg.listByGroup(groupName)); }
            if (PoisonFlg.name().equals(name())) { return toClsList(CDef.PoisonFlg.listByGroup(groupName)); }
            if (FoogFlg.name().equals(name())) { return toClsList(CDef.FoogFlg.listByGroup(groupName)); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryPrepaidFlg.listByGroup(groupName)); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryCollectFlg.listByGroup(groupName)); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupPrepaidFlg.listByGroup(groupName)); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupCollectFlg.listByGroup(groupName)); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryPrepaidFlg.listByGroup(groupName)); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryCollectFlg.listByGroup(groupName)); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsidePickupPrepaidFlg.listByGroup(groupName)); }
            if (InsidePickupCollectFlg.name().equals(name())) { return toClsList(CDef.InsidePickupCollectFlg.listByGroup(groupName)); }
            if (RcmdPickingCls.name().equals(name())) { return toClsList(CDef.RcmdPickingCls.listByGroup(groupName)); }
            if (SglRowPicTarget.name().equals(name())) { return toClsList(CDef.SglRowPicTarget.listByGroup(groupName)); }
            if (CasePicTarget.name().equals(name())) { return toClsList(CDef.CasePicTarget.listByGroup(groupName)); }
            if (AttendanceLeavingRest.name().equals(name())) { return toClsList(CDef.AttendanceLeavingRest.listByGroup(groupName)); }
            if (UploadZipType.name().equals(name())) { return toClsList(CDef.UploadZipType.listByGroup(groupName)); }
            if (FwType.name().equals(name())) { return toClsList(CDef.FwType.listByGroup(groupName)); }
            if (McaType.name().equals(name())) { return toClsList(CDef.McaType.listByGroup(groupName)); }
            if (AccountFlg.name().equals(name())) { return toClsList(CDef.AccountFlg.listByGroup(groupName)); }
            if (AlarmReasonCls.name().equals(name())) { return toClsList(CDef.AlarmReasonCls.listByGroup(groupName)); }
            if (AlarmType.name().equals(name())) { return toClsList(CDef.AlarmType.listByGroup(groupName)); }
            if (AreaCls.name().equals(name())) { return toClsList(CDef.AreaCls.listByGroup(groupName)); }
            if (AssortStatus.name().equals(name())) { return toClsList(CDef.AssortStatus.listByGroup(groupName)); }
            if (BaseCls.name().equals(name())) { return toClsList(CDef.BaseCls.listByGroup(groupName)); }
            if (BoxType.name().equals(name())) { return toClsList(CDef.BoxType.listByGroup(groupName)); }
            if (CarrierType.name().equals(name())) { return toClsList(CDef.CarrierType.listByGroup(groupName)); }
            if (CarrierTypeCd.name().equals(name())) { return toClsList(CDef.CarrierTypeCd.listByGroup(groupName)); }
            if (CaseTypeCd.name().equals(name())) { return toClsList(CDef.CaseTypeCd.listByGroup(groupName)); }
            if (ClosingDt.name().equals(name())) { return toClsList(CDef.ClosingDt.listByGroup(groupName)); }
            if (CompletedHidden.name().equals(name())) { return toClsList(CDef.CompletedHidden.listByGroup(groupName)); }
            if (Condition.name().equals(name())) { return toClsList(CDef.Condition.listByGroup(groupName)); }
            if (Constract.name().equals(name())) { return toClsList(CDef.Constract.listByGroup(groupName)); }
            if (CsPsType.name().equals(name())) { return toClsList(CDef.CsPsType.listByGroup(groupName)); }
            if (DefaultStockType.name().equals(name())) { return toClsList(CDef.DefaultStockType.listByGroup(groupName)); }
            if (DelivCenterFrom.name().equals(name())) { return toClsList(CDef.DelivCenterFrom.listByGroup(groupName)); }
            if (DelivCenterTo.name().equals(name())) { return toClsList(CDef.DelivCenterTo.listByGroup(groupName)); }
            if (DeliveryDtUnspecified.name().equals(name())) { return toClsList(CDef.DeliveryDtUnspecified.listByGroup(groupName)); }
            if (DeliveryTimeZone.name().equals(name())) { return toClsList(CDef.DeliveryTimeZone.listByGroup(groupName)); }
            if (DeliveryTypeSendCls.name().equals(name())) { return toClsList(CDef.DeliveryTypeSendCls.listByGroup(groupName)); }
            if (DepositItemFlg.name().equals(name())) { return toClsList(CDef.DepositItemFlg.listByGroup(groupName)); }
            if (DepositType.name().equals(name())) { return toClsList(CDef.DepositType.listByGroup(groupName)); }
            if (DiffCls.name().equals(name())) { return toClsList(CDef.DiffCls.listByGroup(groupName)); }
            if (DirectDeliveryTypeCd.name().equals(name())) { return toClsList(CDef.DirectDeliveryTypeCd.listByGroup(groupName)); }
            if (EcOrder.name().equals(name())) { return toClsList(CDef.EcOrder.listByGroup(groupName)); }
            if (EcType.name().equals(name())) { return toClsList(CDef.EcType.listByGroup(groupName)); }
            if (ExecuteStatus.name().equals(name())) { return toClsList(CDef.ExecuteStatus.listByGroup(groupName)); }
            if (Fee.name().equals(name())) { return toClsList(CDef.Fee.listByGroup(groupName)); }
            if (Floor.name().equals(name())) { return toClsList(CDef.Floor.listByGroup(groupName)); }
            if (FloorCd.name().equals(name())) { return toClsList(CDef.FloorCd.listByGroup(groupName)); }
            if (FloorEndFlg.name().equals(name())) { return toClsList(CDef.FloorEndFlg.listByGroup(groupName)); }
            if (FloorTypeCd.name().equals(name())) { return toClsList(CDef.FloorTypeCd.listByGroup(groupName)); }
            if (HandOverStatus.name().equals(name())) { return toClsList(CDef.HandOverStatus.listByGroup(groupName)); }
            if (HandlingType.name().equals(name())) { return toClsList(CDef.HandlingType.listByGroup(groupName)); }
            if (HeavyItemFlg.name().equals(name())) { return toClsList(CDef.HeavyItemFlg.listByGroup(groupName)); }
            if (HeavyItemHadlingFlg.name().equals(name())) { return toClsList(CDef.HeavyItemHadlingFlg.listByGroup(groupName)); }
            if (HinmokuGroupCd.name().equals(name())) { return toClsList(CDef.HinmokuGroupCd.listByGroup(groupName)); }
            if (HolidayFlg.name().equals(name())) { return toClsList(CDef.HolidayFlg.listByGroup(groupName)); }
            if (IdManagAbolitionTypeCd.name().equals(name())) { return toClsList(CDef.IdManagAbolitionTypeCd.listByGroup(groupName)); }
            if (InsuranceFlg.name().equals(name())) { return toClsList(CDef.InsuranceFlg.listByGroup(groupName)); }
            if (InventoryDataStatus.name().equals(name())) { return toClsList(CDef.InventoryDataStatus.listByGroup(groupName)); }
            if (InventoryDiffCls.name().equals(name())) { return toClsList(CDef.InventoryDiffCls.listByGroup(groupName)); }
            if (InventoryInputCls.name().equals(name())) { return toClsList(CDef.InventoryInputCls.listByGroup(groupName)); }
            if (InventoryListOutCls.name().equals(name())) { return toClsList(CDef.InventoryListOutCls.listByGroup(groupName)); }
            if (InventoryListType.name().equals(name())) { return toClsList(CDef.InventoryListType.listByGroup(groupName)); }
            if (ItManagType.name().equals(name())) { return toClsList(CDef.ItManagType.listByGroup(groupName)); }
            if (ItemDensan.name().equals(name())) { return toClsList(CDef.ItemDensan.listByGroup(groupName)); }
            if (LargeItemFlg.name().equals(name())) { return toClsList(CDef.LargeItemFlg.listByGroup(groupName)); }
            if (LimitDtSplitTypeCd.name().equals(name())) { return toClsList(CDef.LimitDtSplitTypeCd.listByGroup(groupName)); }
            if (LimitDtUnmatchTypeCd.name().equals(name())) { return toClsList(CDef.LimitDtUnmatchTypeCd.listByGroup(groupName)); }
            if (LogiAttentionTypeCd.name().equals(name())) { return toClsList(CDef.LogiAttentionTypeCd.listByGroup(groupName)); }
            if (LogiSpecialTypeCd.name().equals(name())) { return toClsList(CDef.LogiSpecialTypeCd.listByGroup(groupName)); }
            if (LogiWeightFlg.name().equals(name())) { return toClsList(CDef.LogiWeightFlg.listByGroup(groupName)); }
            if (LotSplitTypeCd.name().equals(name())) { return toClsList(CDef.LotSplitTypeCd.listByGroup(groupName)); }
            if (LotUnmatchTypeCd.name().equals(name())) { return toClsList(CDef.LotUnmatchTypeCd.listByGroup(groupName)); }
            if (MaxStoreShape.name().equals(name())) { return toClsList(CDef.MaxStoreShape.listByGroup(groupName)); }
            if (MedicalManagFlg.name().equals(name())) { return toClsList(CDef.MedicalManagFlg.listByGroup(groupName)); }
            if (MoveDirection.name().equals(name())) { return toClsList(CDef.MoveDirection.listByGroup(groupName)); }
            if (NationalHolidayCarrier.name().equals(name())) { return toClsList(CDef.NationalHolidayCarrier.listByGroup(groupName)); }
            if (NationalHolidayFlg.name().equals(name())) { return toClsList(CDef.NationalHolidayFlg.listByGroup(groupName)); }
            if (NizoroeProcessId.name().equals(name())) { return toClsList(CDef.NizoroeProcessId.listByGroup(groupName)); }
            if (NizoroeProcessIdWms.name().equals(name())) { return toClsList(CDef.NizoroeProcessIdWms.listByGroup(groupName)); }
            if (NizoroeTime.name().equals(name())) { return toClsList(CDef.NizoroeTime.listByGroup(groupName)); }
            if (NizoroeType.name().equals(name())) { return toClsList(CDef.NizoroeType.listByGroup(groupName)); }
            if (NizoroeTypeWms.name().equals(name())) { return toClsList(CDef.NizoroeTypeWms.listByGroup(groupName)); }
            if (NoOkinawaFlightFlg.name().equals(name())) { return toClsList(CDef.NoOkinawaFlightFlg.listByGroup(groupName)); }
            if (OcrDateFormat.name().equals(name())) { return toClsList(CDef.OcrDateFormat.listByGroup(groupName)); }
            if (OutputListType.name().equals(name())) { return toClsList(CDef.OutputListType.listByGroup(groupName)); }
            if (OutputMonth.name().equals(name())) { return toClsList(CDef.OutputMonth.listByGroup(groupName)); }
            if (OutputStatus.name().equals(name())) { return toClsList(CDef.OutputStatus.listByGroup(groupName)); }
            if (PaymentTypeCd.name().equals(name())) { return toClsList(CDef.PaymentTypeCd.listByGroup(groupName)); }
            if (PickingPatternCd.name().equals(name())) { return toClsList(CDef.PickingPatternCd.listByGroup(groupName)); }
            if (Prefecture.name().equals(name())) { return toClsList(CDef.Prefecture.listByGroup(groupName)); }
            if (PriceDiffHidden.name().equals(name())) { return toClsList(CDef.PriceDiffHidden.listByGroup(groupName)); }
            if (ProdDtManagFlg.name().equals(name())) { return toClsList(CDef.ProdDtManagFlg.listByGroup(groupName)); }
            if (ProdDtSplitTypeCd.name().equals(name())) { return toClsList(CDef.ProdDtSplitTypeCd.listByGroup(groupName)); }
            if (ProdDtUnmatchTypeCd.name().equals(name())) { return toClsList(CDef.ProdDtUnmatchTypeCd.listByGroup(groupName)); }
            if (ProductCategoryConvertCls.name().equals(name())) { return toClsList(CDef.ProductCategoryConvertCls.listByGroup(groupName)); }
            if (ProductCategoryPlant.name().equals(name())) { return toClsList(CDef.ProductCategoryPlant.listByGroup(groupName)); }
            if (ProductCategoryType.name().equals(name())) { return toClsList(CDef.ProductCategoryType.listByGroup(groupName)); }
            if (ProductStoreStatus.name().equals(name())) { return toClsList(CDef.ProductStoreStatus.listByGroup(groupName)); }
            if (ProductUnitCls.name().equals(name())) { return toClsList(CDef.ProductUnitCls.listByGroup(groupName)); }
            if (ReceiveReason.name().equals(name())) { return toClsList(CDef.ReceiveReason.listByGroup(groupName)); }
            if (ReceiveReasonConvert.name().equals(name())) { return toClsList(CDef.ReceiveReasonConvert.listByGroup(groupName)); }
            if (ReceiveReasonDepositReceive.name().equals(name())) { return toClsList(CDef.ReceiveReasonDepositReceive.listByGroup(groupName)); }
            if (ReceiveStatus01.name().equals(name())) { return toClsList(CDef.ReceiveStatus01.listByGroup(groupName)); }
            if (RecommendLocationTypeCd.name().equals(name())) { return toClsList(CDef.RecommendLocationTypeCd.listByGroup(groupName)); }
            if (RelatedProducts.name().equals(name())) { return toClsList(CDef.RelatedProducts.listByGroup(groupName)); }
            if (RemainFlg.name().equals(name())) { return toClsList(CDef.RemainFlg.listByGroup(groupName)); }
            if (ReplenishShape.name().equals(name())) { return toClsList(CDef.ReplenishShape.listByGroup(groupName)); }
            if (SampleCls.name().equals(name())) { return toClsList(CDef.SampleCls.listByGroup(groupName)); }
            if (SearchReferenceDt.name().equals(name())) { return toClsList(CDef.SearchReferenceDt.listByGroup(groupName)); }
            if (SerialManagFlg.name().equals(name())) { return toClsList(CDef.SerialManagFlg.listByGroup(groupName)); }
            if (ShapeGrpTypeCd.name().equals(name())) { return toClsList(CDef.ShapeGrpTypeCd.listByGroup(groupName)); }
            if (SharedProductTypeCd.name().equals(name())) { return toClsList(CDef.SharedProductTypeCd.listByGroup(groupName)); }
            if (ShippingInspectionHidden.name().equals(name())) { return toClsList(CDef.ShippingInspectionHidden.listByGroup(groupName)); }
            if (ShippingInspectionStatus.name().equals(name())) { return toClsList(CDef.ShippingInspectionStatus.listByGroup(groupName)); }
            if (ShippingProcessType.name().equals(name())) { return toClsList(CDef.ShippingProcessType.listByGroup(groupName)); }
            if (ShippingProgress.name().equals(name())) { return toClsList(CDef.ShippingProgress.listByGroup(groupName)); }
            if (ShippingReason.name().equals(name())) { return toClsList(CDef.ShippingReason.listByGroup(groupName)); }
            if (ShippingReasonConvert.name().equals(name())) { return toClsList(CDef.ShippingReasonConvert.listByGroup(groupName)); }
            if (ShippingSlipType.name().equals(name())) { return toClsList(CDef.ShippingSlipType.listByGroup(groupName)); }
            if (ShippingType.name().equals(name())) { return toClsList(CDef.ShippingType.listByGroup(groupName)); }
            if (ShippingWorkType.name().equals(name())) { return toClsList(CDef.ShippingWorkType.listByGroup(groupName)); }
            if (SlipType2.name().equals(name())) { return toClsList(CDef.SlipType2.listByGroup(groupName)); }
            if (SpareTypeCd.name().equals(name())) { return toClsList(CDef.SpareTypeCd.listByGroup(groupName)); }
            if (SpecifiedNumOfShoes.name().equals(name())) { return toClsList(CDef.SpecifiedNumOfShoes.listByGroup(groupName)); }
            if (SplitDeliveryTypeCd.name().equals(name())) { return toClsList(CDef.SplitDeliveryTypeCd.listByGroup(groupName)); }
            if (StockDifference.name().equals(name())) { return toClsList(CDef.StockDifference.listByGroup(groupName)); }
            if (StockDisplayType.name().equals(name())) { return toClsList(CDef.StockDisplayType.listByGroup(groupName)); }
            if (StockExist.name().equals(name())) { return toClsList(CDef.StockExist.listByGroup(groupName)); }
            if (StockProcessType.name().equals(name())) { return toClsList(CDef.StockProcessType.listByGroup(groupName)); }
            if (StockRefCls.name().equals(name())) { return toClsList(CDef.StockRefCls.listByGroup(groupName)); }
            if (StockTakingStatus.name().equals(name())) { return toClsList(CDef.StockTakingStatus.listByGroup(groupName)); }
            if (StockZeroDisplay.name().equals(name())) { return toClsList(CDef.StockZeroDisplay.listByGroup(groupName)); }
            if (SuppliesVarietyFlg.name().equals(name())) { return toClsList(CDef.SuppliesVarietyFlg.listByGroup(groupName)); }
            if (TargetBase.name().equals(name())) { return toClsList(CDef.TargetBase.listByGroup(groupName)); }
            if (TargetItemCd.name().equals(name())) { return toClsList(CDef.TargetItemCd.listByGroup(groupName)); }
            if (TargetKoguchiCd.name().equals(name())) { return toClsList(CDef.TargetKoguchiCd.listByGroup(groupName)); }
            if (TargetSalesCd.name().equals(name())) { return toClsList(CDef.TargetSalesCd.listByGroup(groupName)); }
            if (UnitCls.name().equals(name())) { return toClsList(CDef.UnitCls.listByGroup(groupName)); }
            if (UrgentShippingTimeZone.name().equals(name())) { return toClsList(CDef.UrgentShippingTimeZone.listByGroup(groupName)); }
            if (WorkType.name().equals(name())) { return toClsList(CDef.WorkType.listByGroup(groupName)); }
            if (ReceiveLabelFlg.name().equals(name())) { return toClsList(CDef.ReceiveLabelFlg.listByGroup(groupName)); }
            if (ReceiveDtUnmatchFlg.name().equals(name())) { return toClsList(CDef.ReceiveDtUnmatchFlg.listByGroup(groupName)); }
            if (PrintFlg.name().equals(name())) { return toClsList(CDef.PrintFlg.listByGroup(groupName)); }
            if (ReceiveRemainFlg.name().equals(name())) { return toClsList(CDef.ReceiveRemainFlg.listByGroup(groupName)); }
            if (ShippingPickedHidden.name().equals(name())) { return toClsList(CDef.ShippingPickedHidden.listByGroup(groupName)); }
            if (CarrierDataOutFlg.name().equals(name())) { return toClsList(CDef.CarrierDataOutFlg.listByGroup(groupName)); }
            if (PllOutFlg.name().equals(name())) { return toClsList(CDef.PllOutFlg.listByGroup(groupName)); }
            if (DepositorCls.name().equals(name())) { return toClsList(CDef.DepositorCls.listByGroup(groupName)); }
            if (RplOutFlg.name().equals(name())) { return toClsList(CDef.RplOutFlg.listByGroup(groupName)); }
            if (RecordSendFlg.name().equals(name())) { return toClsList(CDef.RecordSendFlg.listByGroup(groupName)); }
            if (HandOverHidden.name().equals(name())) { return toClsList(CDef.HandOverHidden.listByGroup(groupName)); }
            if (ExternalWarehouseFlg.name().equals(name())) { return toClsList(CDef.ExternalWarehouseFlg.listByGroup(groupName)); }
            if (StandardPlantCls.name().equals(name())) { return toClsList(CDef.StandardPlantCls.listByGroup(groupName)); }
            if (LargeItemHadlingFlg.name().equals(name())) { return toClsList(CDef.LargeItemHadlingFlg.listByGroup(groupName)); }
            if (HolidayCarrierFlg.name().equals(name())) { return toClsList(CDef.HolidayCarrierFlg.listByGroup(groupName)); }
            if (OkinawaFlightFlg.name().equals(name())) { return toClsList(CDef.OkinawaFlightFlg.listByGroup(groupName)); }
            if (BaseDefaultCarrierFlg.name().equals(name())) { return toClsList(CDef.BaseDefaultCarrierFlg.listByGroup(groupName)); }
            if (SlipTypeCd.name().equals(name())) { return toClsList(CDef.SlipTypeCd.listByGroup(groupName)); }
            if (ProperFlg.name().equals(name())) { return toClsList(CDef.ProperFlg.listByGroup(groupName)); }
            if (CdlOutFlg.name().equals(name())) { return toClsList(CDef.CdlOutFlg.listByGroup(groupName)); }
            if (ErrorNum.name().equals(name())) { return toClsList(CDef.ErrorNum.listByGroup(groupName)); }
            if (CenterPicListCls1.name().equals(name())) { return toClsList(CDef.CenterPicListCls1.listByGroup(groupName)); }
            if (CenterPicListCls2.name().equals(name())) { return toClsList(CDef.CenterPicListCls2.listByGroup(groupName)); }
            if (CenterPicListCls3.name().equals(name())) { return toClsList(CDef.CenterPicListCls3.listByGroup(groupName)); }
            if (CenterSagawaDelivTz.name().equals(name())) { return toClsList(CDef.CenterSagawaDelivTz.listByGroup(groupName)); }
            if (CenterTransportTypeItem.name().equals(name())) { return toClsList(CDef.CenterTransportTypeItem.listByGroup(groupName)); }
            if (CenterSlipShapeCd.name().equals(name())) { return toClsList(CDef.CenterSlipShapeCd.listByGroup(groupName)); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return toClsList(CDef.CenterTransportTypeSpeed.listByGroup(groupName)); }
            if (CenterSealType.name().equals(name())) { return toClsList(CDef.CenterSealType.listByGroup(groupName)); }
            if (CenterTagClass.name().equals(name())) { return toClsList(CDef.CenterTagClass.listByGroup(groupName)); }
            if (CenterTagDataType.name().equals(name())) { return toClsList(CDef.CenterTagDataType.listByGroup(groupName)); }
            if (CenterTagType.name().equals(name())) { return toClsList(CDef.CenterTagType.listByGroup(groupName)); }
            if (CenterTagTypeAfter.name().equals(name())) { return toClsList(CDef.CenterTagTypeAfter.listByGroup(groupName)); }
            if (CenterApiBinsyuCode.name().equals(name())) { return toClsList(CDef.CenterApiBinsyuCode.listByGroup(groupName)); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiFlg.listByGroup(groupName)); }
            if (CenterApiDaibikiType.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiType.listByGroup(groupName)); }
            if (CenterApiEidomeFlg.name().equals(name())) { return toClsList(CDef.CenterApiEidomeFlg.listByGroup(groupName)); }
            if (CenterApiWeightCd.name().equals(name())) { return toClsList(CDef.CenterApiWeightCd.listByGroup(groupName)); }
            if (CenterOutputTargetFlg.name().equals(name())) { return toClsList(CDef.CenterOutputTargetFlg.listByGroup(groupName)); }
            if (CenterPrintCondition.name().equals(name())) { return toClsList(CDef.CenterPrintCondition.listByGroup(groupName)); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        public List<Classification> listOf(Collection<String> codeList) {
            if (ProcessTypeCd.name().equals(name())) { return toClsList(CDef.ProcessTypeCd.listOf(codeList)); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return toClsList(CDef.AfterDelivSlipOutTgt.listOf(codeList)); }
            if (AfterTagOutFlg.name().equals(name())) { return toClsList(CDef.AfterTagOutFlg.listOf(codeList)); }
            if (AllShippingFlg.name().equals(name())) { return toClsList(CDef.AllShippingFlg.listOf(codeList)); }
            if (AllcNgDisplay.name().equals(name())) { return toClsList(CDef.AllcNgDisplay.listOf(codeList)); }
            if (AllcNgFlg.name().equals(name())) { return toClsList(CDef.AllcNgFlg.listOf(codeList)); }
            if (AllocSortKey.name().equals(name())) { return toClsList(CDef.AllocSortKey.listOf(codeList)); }
            if (ArrivalStoreFormat.name().equals(name())) { return toClsList(CDef.ArrivalStoreFormat.listOf(codeList)); }
            if (AutoEmgSetFlg.name().equals(name())) { return toClsList(CDef.AutoEmgSetFlg.listOf(codeList)); }
            if (AutoEmgSetTgt.name().equals(name())) { return toClsList(CDef.AutoEmgSetTgt.listOf(codeList)); }
            if (AutoPrintTargetFlg.name().equals(name())) { return toClsList(CDef.AutoPrintTargetFlg.listOf(codeList)); }
            if (AutoShipInstFlg.name().equals(name())) { return toClsList(CDef.AutoShipInstFlg.listOf(codeList)); }
            if (BarcodeType.name().equals(name())) { return toClsList(CDef.BarcodeType.listOf(codeList)); }
            if (BatchProgressFlg.name().equals(name())) { return toClsList(CDef.BatchProgressFlg.listOf(codeList)); }
            if (BoxSelectSkip.name().equals(name())) { return toClsList(CDef.BoxSelectSkip.listOf(codeList)); }
            if (CancelDataDisplay.name().equals(name())) { return toClsList(CDef.CancelDataDisplay.listOf(codeList)); }
            if (CasePicFlg.name().equals(name())) { return toClsList(CDef.CasePicFlg.listOf(codeList)); }
            if (CenterClientCls.name().equals(name())) { return toClsList(CDef.CenterClientCls.listOf(codeList)); }
            if (CenterTransitFlg.name().equals(name())) { return toClsList(CDef.CenterTransitFlg.listOf(codeList)); }
            if (CharacterCd.name().equals(name())) { return toClsList(CDef.CharacterCd.listOf(codeList)); }
            if (ChargeQty0Display.name().equals(name())) { return toClsList(CDef.ChargeQty0Display.listOf(codeList)); }
            if (CheckDigit.name().equals(name())) { return toClsList(CDef.CheckDigit.listOf(codeList)); }
            if (CodCls.name().equals(name())) { return toClsList(CDef.CodCls.listOf(codeList)); }
            if (CodType.name().equals(name())) { return toClsList(CDef.CodType.listOf(codeList)); }
            if (CodeFlg.name().equals(name())) { return toClsList(CDef.CodeFlg.listOf(codeList)); }
            if (CodeType.name().equals(name())) { return toClsList(CDef.CodeType.listOf(codeList)); }
            if (ColType.name().equals(name())) { return toClsList(CDef.ColType.listOf(codeList)); }
            if (CommentFlg.name().equals(name())) { return toClsList(CDef.CommentFlg.listOf(codeList)); }
            if (CompanyFlg.name().equals(name())) { return toClsList(CDef.CompanyFlg.listOf(codeList)); }
            if (CoolCls.name().equals(name())) { return toClsList(CDef.CoolCls.listOf(codeList)); }
            if (CoolType.name().equals(name())) { return toClsList(CDef.CoolType.listOf(codeList)); }
            if (CorrectType.name().equals(name())) { return toClsList(CDef.CorrectType.listOf(codeList)); }
            if (DataInputCommitType.name().equals(name())) { return toClsList(CDef.DataInputCommitType.listOf(codeList)); }
            if (DataInputOperationType.name().equals(name())) { return toClsList(CDef.DataInputOperationType.listOf(codeList)); }
            if (DataInputProcessType.name().equals(name())) { return toClsList(CDef.DataInputProcessType.listOf(codeList)); }
            if (DataInputRange.name().equals(name())) { return toClsList(CDef.DataInputRange.listOf(codeList)); }
            if (DataInputType.name().equals(name())) { return toClsList(CDef.DataInputType.listOf(codeList)); }
            if (DataType.name().equals(name())) { return toClsList(CDef.DataType.listOf(codeList)); }
            if (Default.name().equals(name())) { return toClsList(CDef.Default.listOf(codeList)); }
            if (DefaultFlg.name().equals(name())) { return toClsList(CDef.DefaultFlg.listOf(codeList)); }
            if (DelFlg.name().equals(name())) { return toClsList(CDef.DelFlg.listOf(codeList)); }
            if (DeleteDataDisplay.name().equals(name())) { return toClsList(CDef.DeleteDataDisplay.listOf(codeList)); }
            if (DelivMatchFlg.name().equals(name())) { return toClsList(CDef.DelivMatchFlg.listOf(codeList)); }
            if (DelivTz.name().equals(name())) { return toClsList(CDef.DelivTz.listOf(codeList)); }
            if (DeliveryFlg.name().equals(name())) { return toClsList(CDef.DeliveryFlg.listOf(codeList)); }
            if (DepositFlg.name().equals(name())) { return toClsList(CDef.DepositFlg.listOf(codeList)); }
            if (DisplayRequired.name().equals(name())) { return toClsList(CDef.DisplayRequired.listOf(codeList)); }
            if (DtCls.name().equals(name())) { return toClsList(CDef.DtCls.listOf(codeList)); }
            if (Editable.name().equals(name())) { return toClsList(CDef.Editable.listOf(codeList)); }
            if (EmergencyDisplay.name().equals(name())) { return toClsList(CDef.EmergencyDisplay.listOf(codeList)); }
            if (EmergencyFlg.name().equals(name())) { return toClsList(CDef.EmergencyFlg.listOf(codeList)); }
            if (ErrorFlg.name().equals(name())) { return toClsList(CDef.ErrorFlg.listOf(codeList)); }
            if (ErrorProcessMet.name().equals(name())) { return toClsList(CDef.ErrorProcessMet.listOf(codeList)); }
            if (FixedPoint.name().equals(name())) { return toClsList(CDef.FixedPoint.listOf(codeList)); }
            if (ForceFixedFlg.name().equals(name())) { return toClsList(CDef.ForceFixedFlg.listOf(codeList)); }
            if (ForeignFlg.name().equals(name())) { return toClsList(CDef.ForeignFlg.listOf(codeList)); }
            if (GiftFlg.name().equals(name())) { return toClsList(CDef.GiftFlg.listOf(codeList)); }
            if (GiftStatementType.name().equals(name())) { return toClsList(CDef.GiftStatementType.listOf(codeList)); }
            if (HtCharReadFlg.name().equals(name())) { return toClsList(CDef.HtCharReadFlg.listOf(codeList)); }
            if (ImportFlg.name().equals(name())) { return toClsList(CDef.ImportFlg.listOf(codeList)); }
            if (InfoFlg.name().equals(name())) { return toClsList(CDef.InfoFlg.listOf(codeList)); }
            if (InoutType.name().equals(name())) { return toClsList(CDef.InoutType.listOf(codeList)); }
            if (InputType.name().equals(name())) { return toClsList(CDef.InputType.listOf(codeList)); }
            if (InspectionFlg.name().equals(name())) { return toClsList(CDef.InspectionFlg.listOf(codeList)); }
            if (InventoryLocationProduct.name().equals(name())) { return toClsList(CDef.InventoryLocationProduct.listOf(codeList)); }
            if (InvoiceCreateFlg.name().equals(name())) { return toClsList(CDef.InvoiceCreateFlg.listOf(codeList)); }
            if (ItemType.name().equals(name())) { return toClsList(CDef.ItemType.listOf(codeList)); }
            if (LastFlg.name().equals(name())) { return toClsList(CDef.LastFlg.listOf(codeList)); }
            if (LimitDtManagFlg.name().equals(name())) { return toClsList(CDef.LimitDtManagFlg.listOf(codeList)); }
            if (LimitDtReverseFlg.name().equals(name())) { return toClsList(CDef.LimitDtReverseFlg.listOf(codeList)); }
            if (LimitMessageCd.name().equals(name())) { return toClsList(CDef.LimitMessageCd.listOf(codeList)); }
            if (LineFeedCd.name().equals(name())) { return toClsList(CDef.LineFeedCd.listOf(codeList)); }
            if (ListOutFlg.name().equals(name())) { return toClsList(CDef.ListOutFlg.listOf(codeList)); }
            if (ListOutKbn.name().equals(name())) { return toClsList(CDef.ListOutKbn.listOf(codeList)); }
            if (ListOutFlgDisp.name().equals(name())) { return toClsList(CDef.ListOutFlgDisp.listOf(codeList)); }
            if (LoadingFlg.name().equals(name())) { return toClsList(CDef.LoadingFlg.listOf(codeList)); }
            if (LocationType.name().equals(name())) { return toClsList(CDef.LocationType.listOf(codeList)); }
            if (Lockout.name().equals(name())) { return toClsList(CDef.Lockout.listOf(codeList)); }
            if (LogDtlStatus.name().equals(name())) { return toClsList(CDef.LogDtlStatus.listOf(codeList)); }
            if (LogDtlType.name().equals(name())) { return toClsList(CDef.LogDtlType.listOf(codeList)); }
            if (LogStatus.name().equals(name())) { return toClsList(CDef.LogStatus.listOf(codeList)); }
            if (LotManagFlg.name().equals(name())) { return toClsList(CDef.LotManagFlg.listOf(codeList)); }
            if (LotReverseFlg.name().equals(name())) { return toClsList(CDef.LotReverseFlg.listOf(codeList)); }
            if (MergeCls.name().equals(name())) { return toClsList(CDef.MergeCls.listOf(codeList)); }
            if (MergeFlg.name().equals(name())) { return toClsList(CDef.MergeFlg.listOf(codeList)); }
            if (MessageType.name().equals(name())) { return toClsList(CDef.MessageType.listOf(codeList)); }
            if (MixedFlg.name().equals(name())) { return toClsList(CDef.MixedFlg.listOf(codeList)); }
            if (MoveInstStatus.name().equals(name())) { return toClsList(CDef.MoveInstStatus.listOf(codeList)); }
            if (MultiPicCls.name().equals(name())) { return toClsList(CDef.MultiPicCls.listOf(codeList)); }
            if (MultiPicFlg.name().equals(name())) { return toClsList(CDef.MultiPicFlg.listOf(codeList)); }
            if (Necessary.name().equals(name())) { return toClsList(CDef.Necessary.listOf(codeList)); }
            if (NoAllcDisplayFlg.name().equals(name())) { return toClsList(CDef.NoAllcDisplayFlg.listOf(codeList)); }
            if (NoConfirmedFlg.name().equals(name())) { return toClsList(CDef.NoConfirmedFlg.listOf(codeList)); }
            if (NoStockCls.name().equals(name())) { return toClsList(CDef.NoStockCls.listOf(codeList)); }
            if (NoStockOutFlg.name().equals(name())) { return toClsList(CDef.NoStockOutFlg.listOf(codeList)); }
            if (NoUpsideDownCls.name().equals(name())) { return toClsList(CDef.NoUpsideDownCls.listOf(codeList)); }
            if (NotCompletedFlg.name().equals(name())) { return toClsList(CDef.NotCompletedFlg.listOf(codeList)); }
            if (OnetimeFlg.name().equals(name())) { return toClsList(CDef.OnetimeFlg.listOf(codeList)); }
            if (OverStoreNumFlg.name().equals(name())) { return toClsList(CDef.OverStoreNumFlg.listOf(codeList)); }
            if (PackingCalCls.name().equals(name())) { return toClsList(CDef.PackingCalCls.listOf(codeList)); }
            if (PackingProcessCls.name().equals(name())) { return toClsList(CDef.PackingProcessCls.listOf(codeList)); }
            if (PackingShowFlg.name().equals(name())) { return toClsList(CDef.PackingShowFlg.listOf(codeList)); }
            if (PackingStatus.name().equals(name())) { return toClsList(CDef.PackingStatus.listOf(codeList)); }
            if (PasswordReset.name().equals(name())) { return toClsList(CDef.PasswordReset.listOf(codeList)); }
            if (PastStoreDtFlg.name().equals(name())) { return toClsList(CDef.PastStoreDtFlg.listOf(codeList)); }
            if (PhysicalDelete.name().equals(name())) { return toClsList(CDef.PhysicalDelete.listOf(codeList)); }
            if (PicCls.name().equals(name())) { return toClsList(CDef.PicCls.listOf(codeList)); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return toClsList(CDef.PicMthdRcmdBreakKey.listOf(codeList)); }
            if (PicMthdRcmdFlg.name().equals(name())) { return toClsList(CDef.PicMthdRcmdFlg.listOf(codeList)); }
            if (PicMthdRcmdListOut.name().equals(name())) { return toClsList(CDef.PicMthdRcmdListOut.listOf(codeList)); }
            if (PickingFlg.name().equals(name())) { return toClsList(CDef.PickingFlg.listOf(codeList)); }
            if (PickingLocationFlg.name().equals(name())) { return toClsList(CDef.PickingLocationFlg.listOf(codeList)); }
            if (PickingStatus.name().equals(name())) { return toClsList(CDef.PickingStatus.listOf(codeList)); }
            if (PickingType.name().equals(name())) { return toClsList(CDef.PickingType.listOf(codeList)); }
            if (PostType.name().equals(name())) { return toClsList(CDef.PostType.listOf(codeList)); }
            if (PrintDataType.name().equals(name())) { return toClsList(CDef.PrintDataType.listOf(codeList)); }
            if (PrintErrorFlg.name().equals(name())) { return toClsList(CDef.PrintErrorFlg.listOf(codeList)); }
            if (PrintQueueStatus.name().equals(name())) { return toClsList(CDef.PrintQueueStatus.listOf(codeList)); }
            if (PrintResultClass.name().equals(name())) { return toClsList(CDef.PrintResultClass.listOf(codeList)); }
            if (PrintServiceStatus.name().equals(name())) { return toClsList(CDef.PrintServiceStatus.listOf(codeList)); }
            if (PrintStatus.name().equals(name())) { return toClsList(CDef.PrintStatus.listOf(codeList)); }
            if (PrintedFlg.name().equals(name())) { return toClsList(CDef.PrintedFlg.listOf(codeList)); }
            if (PriorityFlg.name().equals(name())) { return toClsList(CDef.PriorityFlg.listOf(codeList)); }
            if (ProductLabelJanBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelJanBarcode.listOf(codeList)); }
            if (ProductLabelOutUnit.name().equals(name())) { return toClsList(CDef.ProductLabelOutUnit.listOf(codeList)); }
            if (ProductLabelProdBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelProdBarcode.listOf(codeList)); }
            if (ProductPartPacking.name().equals(name())) { return toClsList(CDef.ProductPartPacking.listOf(codeList)); }
            if (ProductTypeCode.name().equals(name())) { return toClsList(CDef.ProductTypeCode.listOf(codeList)); }
            if (Qty0Display.name().equals(name())) { return toClsList(CDef.Qty0Display.listOf(codeList)); }
            if (ReasonType.name().equals(name())) { return toClsList(CDef.ReasonType.listOf(codeList)); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return toClsList(CDef.ReceiveDeliveryStatus.listOf(codeList)); }
            if (ReceiveFlg.name().equals(name())) { return toClsList(CDef.ReceiveFlg.listOf(codeList)); }
            if (ReceiveStatus.name().equals(name())) { return toClsList(CDef.ReceiveStatus.listOf(codeList)); }
            if (ReplenishAllocCls.name().equals(name())) { return toClsList(CDef.ReplenishAllocCls.listOf(codeList)); }
            if (ReplenishProductCdUnset.name().equals(name())) { return toClsList(CDef.ReplenishProductCdUnset.listOf(codeList)); }
            if (ReplenishSearchCls.name().equals(name())) { return toClsList(CDef.ReplenishSearchCls.listOf(codeList)); }
            if (ReplenishUnitCls.name().equals(name())) { return toClsList(CDef.ReplenishUnitCls.listOf(codeList)); }
            if (ReportLayoutItemType.name().equals(name())) { return toClsList(CDef.ReportLayoutItemType.listOf(codeList)); }
            if (RestockType.name().equals(name())) { return toClsList(CDef.RestockType.listOf(codeList)); }
            if (ResultAfterProductLabel.name().equals(name())) { return toClsList(CDef.ResultAfterProductLabel.listOf(codeList)); }
            if (ReverseValidFlg.name().equals(name())) { return toClsList(CDef.ReverseValidFlg.listOf(codeList)); }
            if (Select.name().equals(name())) { return toClsList(CDef.Select.listOf(codeList)); }
            if (SelectPrintServiceStatus.name().equals(name())) { return toClsList(CDef.SelectPrintServiceStatus.listOf(codeList)); }
            if (SerialOperationType.name().equals(name())) { return toClsList(CDef.SerialOperationType.listOf(codeList)); }
            if (TargetWindow.name().equals(name())) { return toClsList(CDef.TargetWindow.listOf(codeList)); }
            if (SettlementType.name().equals(name())) { return toClsList(CDef.SettlementType.listOf(codeList)); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return toClsList(CDef.SglRowInspAfterOutCls.listOf(codeList)); }
            if (SglRowPicFlg.name().equals(name())) { return toClsList(CDef.SglRowPicFlg.listOf(codeList)); }
            if (SheetCollate.name().equals(name())) { return toClsList(CDef.SheetCollate.listOf(codeList)); }
            if (ShippingFlg.name().equals(name())) { return toClsList(CDef.ShippingFlg.listOf(codeList)); }
            if (ShippingStatus.name().equals(name())) { return toClsList(CDef.ShippingStatus.listOf(codeList)); }
            if (ShippingStopFlg.name().equals(name())) { return toClsList(CDef.ShippingStopFlg.listOf(codeList)); }
            if (ShortStockDisplay.name().equals(name())) { return toClsList(CDef.ShortStockDisplay.listOf(codeList)); }
            if (ShpCheckCls.name().equals(name())) { return toClsList(CDef.ShpCheckCls.listOf(codeList)); }
            if (ShpCheckDisplay.name().equals(name())) { return toClsList(CDef.ShpCheckDisplay.listOf(codeList)); }
            if (SlipType.name().equals(name())) { return toClsList(CDef.SlipType.listOf(codeList)); }
            if (SoundPlayFlg.name().equals(name())) { return toClsList(CDef.SoundPlayFlg.listOf(codeList)); }
            if (StockAdjustFlg.name().equals(name())) { return toClsList(CDef.StockAdjustFlg.listOf(codeList)); }
            if (StockDisplayFld.name().equals(name())) { return toClsList(CDef.StockDisplayFld.listOf(codeList)); }
            if (StockExistOnlyFlg.name().equals(name())) { return toClsList(CDef.StockExistOnlyFlg.listOf(codeList)); }
            if (StockMoveFlg.name().equals(name())) { return toClsList(CDef.StockMoveFlg.listOf(codeList)); }
            if (StockNum0Display.name().equals(name())) { return toClsList(CDef.StockNum0Display.listOf(codeList)); }
            if (StockOutAllocCls.name().equals(name())) { return toClsList(CDef.StockOutAllocCls.listOf(codeList)); }
            if (StockOutAutoInstFlg.name().equals(name())) { return toClsList(CDef.StockOutAutoInstFlg.listOf(codeList)); }
            if (StockOutFlg.name().equals(name())) { return toClsList(CDef.StockOutFlg.listOf(codeList)); }
            if (StockOutInstCxlFlg.name().equals(name())) { return toClsList(CDef.StockOutInstCxlFlg.listOf(codeList)); }
            if (StockOutInstSplitFlg.name().equals(name())) { return toClsList(CDef.StockOutInstSplitFlg.listOf(codeList)); }
            if (StockQtyDisplay.name().equals(name())) { return toClsList(CDef.StockQtyDisplay.listOf(codeList)); }
            if (StockTakingInput.name().equals(name())) { return toClsList(CDef.StockTakingInput.listOf(codeList)); }
            if (StockTarget.name().equals(name())) { return toClsList(CDef.StockTarget.listOf(codeList)); }
            if (StoreDtFlg.name().equals(name())) { return toClsList(CDef.StoreDtFlg.listOf(codeList)); }
            if (StoreFlg.name().equals(name())) { return toClsList(CDef.StoreFlg.listOf(codeList)); }
            if (StoreNoDivideDisplay.name().equals(name())) { return toClsList(CDef.StoreNoDivideDisplay.listOf(codeList)); }
            if (StoreNoFlg.name().equals(name())) { return toClsList(CDef.StoreNoFlg.listOf(codeList)); }
            if (StoreNoMergeFlg.name().equals(name())) { return toClsList(CDef.StoreNoMergeFlg.listOf(codeList)); }
            if (SystemLogStatus.name().equals(name())) { return toClsList(CDef.SystemLogStatus.listOf(codeList)); }
            if (SystemLogType.name().equals(name())) { return toClsList(CDef.SystemLogType.listOf(codeList)); }
            if (SystemType.name().equals(name())) { return toClsList(CDef.SystemType.listOf(codeList)); }
            if (TagDeliveryOutFlg.name().equals(name())) { return toClsList(CDef.TagDeliveryOutFlg.listOf(codeList)); }
            if (TakingShippingDtFlg.name().equals(name())) { return toClsList(CDef.TakingShippingDtFlg.listOf(codeList)); }
            if (TakingShippingFlg.name().equals(name())) { return toClsList(CDef.TakingShippingFlg.listOf(codeList)); }
            if (TextAlign.name().equals(name())) { return toClsList(CDef.TextAlign.listOf(codeList)); }
            if (TotalPicFlg.name().equals(name())) { return toClsList(CDef.TotalPicFlg.listOf(codeList)); }
            if (TrackingNumberingUnit.name().equals(name())) { return toClsList(CDef.TrackingNumberingUnit.listOf(codeList)); }
            if (TransitDisplay.name().equals(name())) { return toClsList(CDef.TransitDisplay.listOf(codeList)); }
            if (Unmatch.name().equals(name())) { return toClsList(CDef.Unmatch.listOf(codeList)); }
            if (UpdCd.name().equals(name())) { return toClsList(CDef.UpdCd.listOf(codeList)); }
            if (UpdType.name().equals(name())) { return toClsList(CDef.UpdType.listOf(codeList)); }
            if (Updatable.name().equals(name())) { return toClsList(CDef.Updatable.listOf(codeList)); }
            if (UploadTableNm.name().equals(name())) { return toClsList(CDef.UploadTableNm.listOf(codeList)); }
            if (UseHtShipFlg.name().equals(name())) { return toClsList(CDef.UseHtShipFlg.listOf(codeList)); }
            if (UserEditable.name().equals(name())) { return toClsList(CDef.UserEditable.listOf(codeList)); }
            if (VendorFlg.name().equals(name())) { return toClsList(CDef.VendorFlg.listOf(codeList)); }
            if (Visible.name().equals(name())) { return toClsList(CDef.Visible.listOf(codeList)); }
            if (WorkFlg.name().equals(name())) { return toClsList(CDef.WorkFlg.listOf(codeList)); }
            if (WorkMessageFlg.name().equals(name())) { return toClsList(CDef.WorkMessageFlg.listOf(codeList)); }
            if (YamatoDelivTz.name().equals(name())) { return toClsList(CDef.YamatoDelivTz.listOf(codeList)); }
            if (YupackDelivTz.name().equals(name())) { return toClsList(CDef.YupackDelivTz.listOf(codeList)); }
            if (ZipFlg.name().equals(name())) { return toClsList(CDef.ZipFlg.listOf(codeList)); }
            if (ResultAfterProductTarget.name().equals(name())) { return toClsList(CDef.ResultAfterProductTarget.listOf(codeList)); }
            if (CopyTargetTable.name().equals(name())) { return toClsList(CDef.CopyTargetTable.listOf(codeList)); }
            if (InspectionLabelOutFlg.name().equals(name())) { return toClsList(CDef.InspectionLabelOutFlg.listOf(codeList)); }
            if (DecimalProductPacking.name().equals(name())) { return toClsList(CDef.DecimalProductPacking.listOf(codeList)); }
            if (DecimalExistFlg.name().equals(name())) { return toClsList(CDef.DecimalExistFlg.listOf(codeList)); }
            if (CasePickFlg.name().equals(name())) { return toClsList(CDef.CasePickFlg.listOf(codeList)); }
            if (EmReplenishShapeFlg.name().equals(name())) { return toClsList(CDef.EmReplenishShapeFlg.listOf(codeList)); }
            if (WorkStatus.name().equals(name())) { return toClsList(CDef.WorkStatus.listOf(codeList)); }
            if (WorkLogOutFlg.name().equals(name())) { return toClsList(CDef.WorkLogOutFlg.listOf(codeList)); }
            if (RoleControlClass.name().equals(name())) { return toClsList(CDef.RoleControlClass.listOf(codeList)); }
            if (BolOutFlg.name().equals(name())) { return toClsList(CDef.BolOutFlg.listOf(codeList)); }
            if (BolOutputTargetFlg.name().equals(name())) { return toClsList(CDef.BolOutputTargetFlg.listOf(codeList)); }
            if (PaymentTerm.name().equals(name())) { return toClsList(CDef.PaymentTerm.listOf(codeList)); }
            if (CesIntegrationFlg.name().equals(name())) { return toClsList(CDef.CesIntegrationFlg.listOf(codeList)); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return toClsList(CDef.PackingSlipAutoOutputFlg.listOf(codeList)); }
            if (FreightCls.name().equals(name())) { return toClsList(CDef.FreightCls.listOf(codeList)); }
            if (SatDeliveryFlg.name().equals(name())) { return toClsList(CDef.SatDeliveryFlg.listOf(codeList)); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return toClsList(CDef.ResidentialDeliveryFlg.listOf(codeList)); }
            if (CodFlg.name().equals(name())) { return toClsList(CDef.CodFlg.listOf(codeList)); }
            if (SignatureRequiredFlg.name().equals(name())) { return toClsList(CDef.SignatureRequiredFlg.listOf(codeList)); }
            if (SignatureReleaseFlg.name().equals(name())) { return toClsList(CDef.SignatureReleaseFlg.listOf(codeList)); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return toClsList(CDef.CallBeforeDeliveryFlg.listOf(codeList)); }
            if (FreezableProtectionFlg.name().equals(name())) { return toClsList(CDef.FreezableProtectionFlg.listOf(codeList)); }
            if (GuaranteedPlusFlg.name().equals(name())) { return toClsList(CDef.GuaranteedPlusFlg.listOf(codeList)); }
            if (ResidentialPickupFlg.name().equals(name())) { return toClsList(CDef.ResidentialPickupFlg.listOf(codeList)); }
            if (DoNotStackStackFlg.name().equals(name())) { return toClsList(CDef.DoNotStackStackFlg.listOf(codeList)); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessDeliveryFlg.listOf(codeList)); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessPickupFlg.listOf(codeList)); }
            if (OverSizedFlg.name().equals(name())) { return toClsList(CDef.OverSizedFlg.listOf(codeList)); }
            if (PoisonFlg.name().equals(name())) { return toClsList(CDef.PoisonFlg.listOf(codeList)); }
            if (FoogFlg.name().equals(name())) { return toClsList(CDef.FoogFlg.listOf(codeList)); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryPrepaidFlg.listOf(codeList)); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryCollectFlg.listOf(codeList)); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupPrepaidFlg.listOf(codeList)); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupCollectFlg.listOf(codeList)); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryPrepaidFlg.listOf(codeList)); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryCollectFlg.listOf(codeList)); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsidePickupPrepaidFlg.listOf(codeList)); }
            if (InsidePickupCollectFlg.name().equals(name())) { return toClsList(CDef.InsidePickupCollectFlg.listOf(codeList)); }
            if (RcmdPickingCls.name().equals(name())) { return toClsList(CDef.RcmdPickingCls.listOf(codeList)); }
            if (SglRowPicTarget.name().equals(name())) { return toClsList(CDef.SglRowPicTarget.listOf(codeList)); }
            if (CasePicTarget.name().equals(name())) { return toClsList(CDef.CasePicTarget.listOf(codeList)); }
            if (AttendanceLeavingRest.name().equals(name())) { return toClsList(CDef.AttendanceLeavingRest.listOf(codeList)); }
            if (UploadZipType.name().equals(name())) { return toClsList(CDef.UploadZipType.listOf(codeList)); }
            if (FwType.name().equals(name())) { return toClsList(CDef.FwType.listOf(codeList)); }
            if (McaType.name().equals(name())) { return toClsList(CDef.McaType.listOf(codeList)); }
            if (AccountFlg.name().equals(name())) { return toClsList(CDef.AccountFlg.listOf(codeList)); }
            if (AlarmReasonCls.name().equals(name())) { return toClsList(CDef.AlarmReasonCls.listOf(codeList)); }
            if (AlarmType.name().equals(name())) { return toClsList(CDef.AlarmType.listOf(codeList)); }
            if (AreaCls.name().equals(name())) { return toClsList(CDef.AreaCls.listOf(codeList)); }
            if (AssortStatus.name().equals(name())) { return toClsList(CDef.AssortStatus.listOf(codeList)); }
            if (BaseCls.name().equals(name())) { return toClsList(CDef.BaseCls.listOf(codeList)); }
            if (BoxType.name().equals(name())) { return toClsList(CDef.BoxType.listOf(codeList)); }
            if (CarrierType.name().equals(name())) { return toClsList(CDef.CarrierType.listOf(codeList)); }
            if (CarrierTypeCd.name().equals(name())) { return toClsList(CDef.CarrierTypeCd.listOf(codeList)); }
            if (CaseTypeCd.name().equals(name())) { return toClsList(CDef.CaseTypeCd.listOf(codeList)); }
            if (ClosingDt.name().equals(name())) { return toClsList(CDef.ClosingDt.listOf(codeList)); }
            if (CompletedHidden.name().equals(name())) { return toClsList(CDef.CompletedHidden.listOf(codeList)); }
            if (Condition.name().equals(name())) { return toClsList(CDef.Condition.listOf(codeList)); }
            if (Constract.name().equals(name())) { return toClsList(CDef.Constract.listOf(codeList)); }
            if (CsPsType.name().equals(name())) { return toClsList(CDef.CsPsType.listOf(codeList)); }
            if (DefaultStockType.name().equals(name())) { return toClsList(CDef.DefaultStockType.listOf(codeList)); }
            if (DelivCenterFrom.name().equals(name())) { return toClsList(CDef.DelivCenterFrom.listOf(codeList)); }
            if (DelivCenterTo.name().equals(name())) { return toClsList(CDef.DelivCenterTo.listOf(codeList)); }
            if (DeliveryDtUnspecified.name().equals(name())) { return toClsList(CDef.DeliveryDtUnspecified.listOf(codeList)); }
            if (DeliveryTimeZone.name().equals(name())) { return toClsList(CDef.DeliveryTimeZone.listOf(codeList)); }
            if (DeliveryTypeSendCls.name().equals(name())) { return toClsList(CDef.DeliveryTypeSendCls.listOf(codeList)); }
            if (DepositItemFlg.name().equals(name())) { return toClsList(CDef.DepositItemFlg.listOf(codeList)); }
            if (DepositType.name().equals(name())) { return toClsList(CDef.DepositType.listOf(codeList)); }
            if (DiffCls.name().equals(name())) { return toClsList(CDef.DiffCls.listOf(codeList)); }
            if (DirectDeliveryTypeCd.name().equals(name())) { return toClsList(CDef.DirectDeliveryTypeCd.listOf(codeList)); }
            if (EcOrder.name().equals(name())) { return toClsList(CDef.EcOrder.listOf(codeList)); }
            if (EcType.name().equals(name())) { return toClsList(CDef.EcType.listOf(codeList)); }
            if (ExecuteStatus.name().equals(name())) { return toClsList(CDef.ExecuteStatus.listOf(codeList)); }
            if (Fee.name().equals(name())) { return toClsList(CDef.Fee.listOf(codeList)); }
            if (Floor.name().equals(name())) { return toClsList(CDef.Floor.listOf(codeList)); }
            if (FloorCd.name().equals(name())) { return toClsList(CDef.FloorCd.listOf(codeList)); }
            if (FloorEndFlg.name().equals(name())) { return toClsList(CDef.FloorEndFlg.listOf(codeList)); }
            if (FloorTypeCd.name().equals(name())) { return toClsList(CDef.FloorTypeCd.listOf(codeList)); }
            if (HandOverStatus.name().equals(name())) { return toClsList(CDef.HandOverStatus.listOf(codeList)); }
            if (HandlingType.name().equals(name())) { return toClsList(CDef.HandlingType.listOf(codeList)); }
            if (HeavyItemFlg.name().equals(name())) { return toClsList(CDef.HeavyItemFlg.listOf(codeList)); }
            if (HeavyItemHadlingFlg.name().equals(name())) { return toClsList(CDef.HeavyItemHadlingFlg.listOf(codeList)); }
            if (HinmokuGroupCd.name().equals(name())) { return toClsList(CDef.HinmokuGroupCd.listOf(codeList)); }
            if (HolidayFlg.name().equals(name())) { return toClsList(CDef.HolidayFlg.listOf(codeList)); }
            if (IdManagAbolitionTypeCd.name().equals(name())) { return toClsList(CDef.IdManagAbolitionTypeCd.listOf(codeList)); }
            if (InsuranceFlg.name().equals(name())) { return toClsList(CDef.InsuranceFlg.listOf(codeList)); }
            if (InventoryDataStatus.name().equals(name())) { return toClsList(CDef.InventoryDataStatus.listOf(codeList)); }
            if (InventoryDiffCls.name().equals(name())) { return toClsList(CDef.InventoryDiffCls.listOf(codeList)); }
            if (InventoryInputCls.name().equals(name())) { return toClsList(CDef.InventoryInputCls.listOf(codeList)); }
            if (InventoryListOutCls.name().equals(name())) { return toClsList(CDef.InventoryListOutCls.listOf(codeList)); }
            if (InventoryListType.name().equals(name())) { return toClsList(CDef.InventoryListType.listOf(codeList)); }
            if (ItManagType.name().equals(name())) { return toClsList(CDef.ItManagType.listOf(codeList)); }
            if (ItemDensan.name().equals(name())) { return toClsList(CDef.ItemDensan.listOf(codeList)); }
            if (LargeItemFlg.name().equals(name())) { return toClsList(CDef.LargeItemFlg.listOf(codeList)); }
            if (LimitDtSplitTypeCd.name().equals(name())) { return toClsList(CDef.LimitDtSplitTypeCd.listOf(codeList)); }
            if (LimitDtUnmatchTypeCd.name().equals(name())) { return toClsList(CDef.LimitDtUnmatchTypeCd.listOf(codeList)); }
            if (LogiAttentionTypeCd.name().equals(name())) { return toClsList(CDef.LogiAttentionTypeCd.listOf(codeList)); }
            if (LogiSpecialTypeCd.name().equals(name())) { return toClsList(CDef.LogiSpecialTypeCd.listOf(codeList)); }
            if (LogiWeightFlg.name().equals(name())) { return toClsList(CDef.LogiWeightFlg.listOf(codeList)); }
            if (LotSplitTypeCd.name().equals(name())) { return toClsList(CDef.LotSplitTypeCd.listOf(codeList)); }
            if (LotUnmatchTypeCd.name().equals(name())) { return toClsList(CDef.LotUnmatchTypeCd.listOf(codeList)); }
            if (MaxStoreShape.name().equals(name())) { return toClsList(CDef.MaxStoreShape.listOf(codeList)); }
            if (MedicalManagFlg.name().equals(name())) { return toClsList(CDef.MedicalManagFlg.listOf(codeList)); }
            if (MoveDirection.name().equals(name())) { return toClsList(CDef.MoveDirection.listOf(codeList)); }
            if (NationalHolidayCarrier.name().equals(name())) { return toClsList(CDef.NationalHolidayCarrier.listOf(codeList)); }
            if (NationalHolidayFlg.name().equals(name())) { return toClsList(CDef.NationalHolidayFlg.listOf(codeList)); }
            if (NizoroeProcessId.name().equals(name())) { return toClsList(CDef.NizoroeProcessId.listOf(codeList)); }
            if (NizoroeProcessIdWms.name().equals(name())) { return toClsList(CDef.NizoroeProcessIdWms.listOf(codeList)); }
            if (NizoroeTime.name().equals(name())) { return toClsList(CDef.NizoroeTime.listOf(codeList)); }
            if (NizoroeType.name().equals(name())) { return toClsList(CDef.NizoroeType.listOf(codeList)); }
            if (NizoroeTypeWms.name().equals(name())) { return toClsList(CDef.NizoroeTypeWms.listOf(codeList)); }
            if (NoOkinawaFlightFlg.name().equals(name())) { return toClsList(CDef.NoOkinawaFlightFlg.listOf(codeList)); }
            if (OcrDateFormat.name().equals(name())) { return toClsList(CDef.OcrDateFormat.listOf(codeList)); }
            if (OutputListType.name().equals(name())) { return toClsList(CDef.OutputListType.listOf(codeList)); }
            if (OutputMonth.name().equals(name())) { return toClsList(CDef.OutputMonth.listOf(codeList)); }
            if (OutputStatus.name().equals(name())) { return toClsList(CDef.OutputStatus.listOf(codeList)); }
            if (PaymentTypeCd.name().equals(name())) { return toClsList(CDef.PaymentTypeCd.listOf(codeList)); }
            if (PickingPatternCd.name().equals(name())) { return toClsList(CDef.PickingPatternCd.listOf(codeList)); }
            if (Prefecture.name().equals(name())) { return toClsList(CDef.Prefecture.listOf(codeList)); }
            if (PriceDiffHidden.name().equals(name())) { return toClsList(CDef.PriceDiffHidden.listOf(codeList)); }
            if (ProdDtManagFlg.name().equals(name())) { return toClsList(CDef.ProdDtManagFlg.listOf(codeList)); }
            if (ProdDtSplitTypeCd.name().equals(name())) { return toClsList(CDef.ProdDtSplitTypeCd.listOf(codeList)); }
            if (ProdDtUnmatchTypeCd.name().equals(name())) { return toClsList(CDef.ProdDtUnmatchTypeCd.listOf(codeList)); }
            if (ProductCategoryConvertCls.name().equals(name())) { return toClsList(CDef.ProductCategoryConvertCls.listOf(codeList)); }
            if (ProductCategoryPlant.name().equals(name())) { return toClsList(CDef.ProductCategoryPlant.listOf(codeList)); }
            if (ProductCategoryType.name().equals(name())) { return toClsList(CDef.ProductCategoryType.listOf(codeList)); }
            if (ProductStoreStatus.name().equals(name())) { return toClsList(CDef.ProductStoreStatus.listOf(codeList)); }
            if (ProductUnitCls.name().equals(name())) { return toClsList(CDef.ProductUnitCls.listOf(codeList)); }
            if (ReceiveReason.name().equals(name())) { return toClsList(CDef.ReceiveReason.listOf(codeList)); }
            if (ReceiveReasonConvert.name().equals(name())) { return toClsList(CDef.ReceiveReasonConvert.listOf(codeList)); }
            if (ReceiveReasonDepositReceive.name().equals(name())) { return toClsList(CDef.ReceiveReasonDepositReceive.listOf(codeList)); }
            if (ReceiveStatus01.name().equals(name())) { return toClsList(CDef.ReceiveStatus01.listOf(codeList)); }
            if (RecommendLocationTypeCd.name().equals(name())) { return toClsList(CDef.RecommendLocationTypeCd.listOf(codeList)); }
            if (RelatedProducts.name().equals(name())) { return toClsList(CDef.RelatedProducts.listOf(codeList)); }
            if (RemainFlg.name().equals(name())) { return toClsList(CDef.RemainFlg.listOf(codeList)); }
            if (ReplenishShape.name().equals(name())) { return toClsList(CDef.ReplenishShape.listOf(codeList)); }
            if (SampleCls.name().equals(name())) { return toClsList(CDef.SampleCls.listOf(codeList)); }
            if (SearchReferenceDt.name().equals(name())) { return toClsList(CDef.SearchReferenceDt.listOf(codeList)); }
            if (SerialManagFlg.name().equals(name())) { return toClsList(CDef.SerialManagFlg.listOf(codeList)); }
            if (ShapeGrpTypeCd.name().equals(name())) { return toClsList(CDef.ShapeGrpTypeCd.listOf(codeList)); }
            if (SharedProductTypeCd.name().equals(name())) { return toClsList(CDef.SharedProductTypeCd.listOf(codeList)); }
            if (ShippingInspectionHidden.name().equals(name())) { return toClsList(CDef.ShippingInspectionHidden.listOf(codeList)); }
            if (ShippingInspectionStatus.name().equals(name())) { return toClsList(CDef.ShippingInspectionStatus.listOf(codeList)); }
            if (ShippingProcessType.name().equals(name())) { return toClsList(CDef.ShippingProcessType.listOf(codeList)); }
            if (ShippingProgress.name().equals(name())) { return toClsList(CDef.ShippingProgress.listOf(codeList)); }
            if (ShippingReason.name().equals(name())) { return toClsList(CDef.ShippingReason.listOf(codeList)); }
            if (ShippingReasonConvert.name().equals(name())) { return toClsList(CDef.ShippingReasonConvert.listOf(codeList)); }
            if (ShippingSlipType.name().equals(name())) { return toClsList(CDef.ShippingSlipType.listOf(codeList)); }
            if (ShippingType.name().equals(name())) { return toClsList(CDef.ShippingType.listOf(codeList)); }
            if (ShippingWorkType.name().equals(name())) { return toClsList(CDef.ShippingWorkType.listOf(codeList)); }
            if (SlipType2.name().equals(name())) { return toClsList(CDef.SlipType2.listOf(codeList)); }
            if (SpareTypeCd.name().equals(name())) { return toClsList(CDef.SpareTypeCd.listOf(codeList)); }
            if (SpecifiedNumOfShoes.name().equals(name())) { return toClsList(CDef.SpecifiedNumOfShoes.listOf(codeList)); }
            if (SplitDeliveryTypeCd.name().equals(name())) { return toClsList(CDef.SplitDeliveryTypeCd.listOf(codeList)); }
            if (StockDifference.name().equals(name())) { return toClsList(CDef.StockDifference.listOf(codeList)); }
            if (StockDisplayType.name().equals(name())) { return toClsList(CDef.StockDisplayType.listOf(codeList)); }
            if (StockExist.name().equals(name())) { return toClsList(CDef.StockExist.listOf(codeList)); }
            if (StockProcessType.name().equals(name())) { return toClsList(CDef.StockProcessType.listOf(codeList)); }
            if (StockRefCls.name().equals(name())) { return toClsList(CDef.StockRefCls.listOf(codeList)); }
            if (StockTakingStatus.name().equals(name())) { return toClsList(CDef.StockTakingStatus.listOf(codeList)); }
            if (StockZeroDisplay.name().equals(name())) { return toClsList(CDef.StockZeroDisplay.listOf(codeList)); }
            if (SuppliesVarietyFlg.name().equals(name())) { return toClsList(CDef.SuppliesVarietyFlg.listOf(codeList)); }
            if (TargetBase.name().equals(name())) { return toClsList(CDef.TargetBase.listOf(codeList)); }
            if (TargetItemCd.name().equals(name())) { return toClsList(CDef.TargetItemCd.listOf(codeList)); }
            if (TargetKoguchiCd.name().equals(name())) { return toClsList(CDef.TargetKoguchiCd.listOf(codeList)); }
            if (TargetSalesCd.name().equals(name())) { return toClsList(CDef.TargetSalesCd.listOf(codeList)); }
            if (UnitCls.name().equals(name())) { return toClsList(CDef.UnitCls.listOf(codeList)); }
            if (UrgentShippingTimeZone.name().equals(name())) { return toClsList(CDef.UrgentShippingTimeZone.listOf(codeList)); }
            if (WorkType.name().equals(name())) { return toClsList(CDef.WorkType.listOf(codeList)); }
            if (ReceiveLabelFlg.name().equals(name())) { return toClsList(CDef.ReceiveLabelFlg.listOf(codeList)); }
            if (ReceiveDtUnmatchFlg.name().equals(name())) { return toClsList(CDef.ReceiveDtUnmatchFlg.listOf(codeList)); }
            if (PrintFlg.name().equals(name())) { return toClsList(CDef.PrintFlg.listOf(codeList)); }
            if (ReceiveRemainFlg.name().equals(name())) { return toClsList(CDef.ReceiveRemainFlg.listOf(codeList)); }
            if (ShippingPickedHidden.name().equals(name())) { return toClsList(CDef.ShippingPickedHidden.listOf(codeList)); }
            if (CarrierDataOutFlg.name().equals(name())) { return toClsList(CDef.CarrierDataOutFlg.listOf(codeList)); }
            if (PllOutFlg.name().equals(name())) { return toClsList(CDef.PllOutFlg.listOf(codeList)); }
            if (DepositorCls.name().equals(name())) { return toClsList(CDef.DepositorCls.listOf(codeList)); }
            if (RplOutFlg.name().equals(name())) { return toClsList(CDef.RplOutFlg.listOf(codeList)); }
            if (RecordSendFlg.name().equals(name())) { return toClsList(CDef.RecordSendFlg.listOf(codeList)); }
            if (HandOverHidden.name().equals(name())) { return toClsList(CDef.HandOverHidden.listOf(codeList)); }
            if (ExternalWarehouseFlg.name().equals(name())) { return toClsList(CDef.ExternalWarehouseFlg.listOf(codeList)); }
            if (StandardPlantCls.name().equals(name())) { return toClsList(CDef.StandardPlantCls.listOf(codeList)); }
            if (LargeItemHadlingFlg.name().equals(name())) { return toClsList(CDef.LargeItemHadlingFlg.listOf(codeList)); }
            if (HolidayCarrierFlg.name().equals(name())) { return toClsList(CDef.HolidayCarrierFlg.listOf(codeList)); }
            if (OkinawaFlightFlg.name().equals(name())) { return toClsList(CDef.OkinawaFlightFlg.listOf(codeList)); }
            if (BaseDefaultCarrierFlg.name().equals(name())) { return toClsList(CDef.BaseDefaultCarrierFlg.listOf(codeList)); }
            if (SlipTypeCd.name().equals(name())) { return toClsList(CDef.SlipTypeCd.listOf(codeList)); }
            if (ProperFlg.name().equals(name())) { return toClsList(CDef.ProperFlg.listOf(codeList)); }
            if (CdlOutFlg.name().equals(name())) { return toClsList(CDef.CdlOutFlg.listOf(codeList)); }
            if (ErrorNum.name().equals(name())) { return toClsList(CDef.ErrorNum.listOf(codeList)); }
            if (CenterPicListCls1.name().equals(name())) { return toClsList(CDef.CenterPicListCls1.listOf(codeList)); }
            if (CenterPicListCls2.name().equals(name())) { return toClsList(CDef.CenterPicListCls2.listOf(codeList)); }
            if (CenterPicListCls3.name().equals(name())) { return toClsList(CDef.CenterPicListCls3.listOf(codeList)); }
            if (CenterSagawaDelivTz.name().equals(name())) { return toClsList(CDef.CenterSagawaDelivTz.listOf(codeList)); }
            if (CenterTransportTypeItem.name().equals(name())) { return toClsList(CDef.CenterTransportTypeItem.listOf(codeList)); }
            if (CenterSlipShapeCd.name().equals(name())) { return toClsList(CDef.CenterSlipShapeCd.listOf(codeList)); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return toClsList(CDef.CenterTransportTypeSpeed.listOf(codeList)); }
            if (CenterSealType.name().equals(name())) { return toClsList(CDef.CenterSealType.listOf(codeList)); }
            if (CenterTagClass.name().equals(name())) { return toClsList(CDef.CenterTagClass.listOf(codeList)); }
            if (CenterTagDataType.name().equals(name())) { return toClsList(CDef.CenterTagDataType.listOf(codeList)); }
            if (CenterTagType.name().equals(name())) { return toClsList(CDef.CenterTagType.listOf(codeList)); }
            if (CenterTagTypeAfter.name().equals(name())) { return toClsList(CDef.CenterTagTypeAfter.listOf(codeList)); }
            if (CenterApiBinsyuCode.name().equals(name())) { return toClsList(CDef.CenterApiBinsyuCode.listOf(codeList)); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiFlg.listOf(codeList)); }
            if (CenterApiDaibikiType.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiType.listOf(codeList)); }
            if (CenterApiEidomeFlg.name().equals(name())) { return toClsList(CDef.CenterApiEidomeFlg.listOf(codeList)); }
            if (CenterApiWeightCd.name().equals(name())) { return toClsList(CDef.CenterApiWeightCd.listOf(codeList)); }
            if (CenterOutputTargetFlg.name().equals(name())) { return toClsList(CDef.CenterOutputTargetFlg.listOf(codeList)); }
            if (CenterPrintCondition.name().equals(name())) { return toClsList(CDef.CenterPrintCondition.listOf(codeList)); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        public List<Classification> groupOf(String groupName) { // old style
            if (ProcessTypeCd.name().equals(name())) { return toClsList(CDef.ProcessTypeCd.groupOf(groupName)); }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return toClsList(CDef.AfterDelivSlipOutTgt.groupOf(groupName)); }
            if (AfterTagOutFlg.name().equals(name())) { return toClsList(CDef.AfterTagOutFlg.groupOf(groupName)); }
            if (AllShippingFlg.name().equals(name())) { return toClsList(CDef.AllShippingFlg.groupOf(groupName)); }
            if (AllcNgDisplay.name().equals(name())) { return toClsList(CDef.AllcNgDisplay.groupOf(groupName)); }
            if (AllcNgFlg.name().equals(name())) { return toClsList(CDef.AllcNgFlg.groupOf(groupName)); }
            if (AllocSortKey.name().equals(name())) { return toClsList(CDef.AllocSortKey.groupOf(groupName)); }
            if (ArrivalStoreFormat.name().equals(name())) { return toClsList(CDef.ArrivalStoreFormat.groupOf(groupName)); }
            if (AutoEmgSetFlg.name().equals(name())) { return toClsList(CDef.AutoEmgSetFlg.groupOf(groupName)); }
            if (AutoEmgSetTgt.name().equals(name())) { return toClsList(CDef.AutoEmgSetTgt.groupOf(groupName)); }
            if (AutoPrintTargetFlg.name().equals(name())) { return toClsList(CDef.AutoPrintTargetFlg.groupOf(groupName)); }
            if (AutoShipInstFlg.name().equals(name())) { return toClsList(CDef.AutoShipInstFlg.groupOf(groupName)); }
            if (BarcodeType.name().equals(name())) { return toClsList(CDef.BarcodeType.groupOf(groupName)); }
            if (BatchProgressFlg.name().equals(name())) { return toClsList(CDef.BatchProgressFlg.groupOf(groupName)); }
            if (BoxSelectSkip.name().equals(name())) { return toClsList(CDef.BoxSelectSkip.groupOf(groupName)); }
            if (CancelDataDisplay.name().equals(name())) { return toClsList(CDef.CancelDataDisplay.groupOf(groupName)); }
            if (CasePicFlg.name().equals(name())) { return toClsList(CDef.CasePicFlg.groupOf(groupName)); }
            if (CenterClientCls.name().equals(name())) { return toClsList(CDef.CenterClientCls.groupOf(groupName)); }
            if (CenterTransitFlg.name().equals(name())) { return toClsList(CDef.CenterTransitFlg.groupOf(groupName)); }
            if (CharacterCd.name().equals(name())) { return toClsList(CDef.CharacterCd.groupOf(groupName)); }
            if (ChargeQty0Display.name().equals(name())) { return toClsList(CDef.ChargeQty0Display.groupOf(groupName)); }
            if (CheckDigit.name().equals(name())) { return toClsList(CDef.CheckDigit.groupOf(groupName)); }
            if (CodCls.name().equals(name())) { return toClsList(CDef.CodCls.groupOf(groupName)); }
            if (CodType.name().equals(name())) { return toClsList(CDef.CodType.groupOf(groupName)); }
            if (CodeFlg.name().equals(name())) { return toClsList(CDef.CodeFlg.groupOf(groupName)); }
            if (CodeType.name().equals(name())) { return toClsList(CDef.CodeType.groupOf(groupName)); }
            if (ColType.name().equals(name())) { return toClsList(CDef.ColType.groupOf(groupName)); }
            if (CommentFlg.name().equals(name())) { return toClsList(CDef.CommentFlg.groupOf(groupName)); }
            if (CompanyFlg.name().equals(name())) { return toClsList(CDef.CompanyFlg.groupOf(groupName)); }
            if (CoolCls.name().equals(name())) { return toClsList(CDef.CoolCls.groupOf(groupName)); }
            if (CoolType.name().equals(name())) { return toClsList(CDef.CoolType.groupOf(groupName)); }
            if (CorrectType.name().equals(name())) { return toClsList(CDef.CorrectType.groupOf(groupName)); }
            if (DataInputCommitType.name().equals(name())) { return toClsList(CDef.DataInputCommitType.groupOf(groupName)); }
            if (DataInputOperationType.name().equals(name())) { return toClsList(CDef.DataInputOperationType.groupOf(groupName)); }
            if (DataInputProcessType.name().equals(name())) { return toClsList(CDef.DataInputProcessType.groupOf(groupName)); }
            if (DataInputRange.name().equals(name())) { return toClsList(CDef.DataInputRange.groupOf(groupName)); }
            if (DataInputType.name().equals(name())) { return toClsList(CDef.DataInputType.groupOf(groupName)); }
            if (DataType.name().equals(name())) { return toClsList(CDef.DataType.groupOf(groupName)); }
            if (Default.name().equals(name())) { return toClsList(CDef.Default.groupOf(groupName)); }
            if (DefaultFlg.name().equals(name())) { return toClsList(CDef.DefaultFlg.groupOf(groupName)); }
            if (DelFlg.name().equals(name())) { return toClsList(CDef.DelFlg.groupOf(groupName)); }
            if (DeleteDataDisplay.name().equals(name())) { return toClsList(CDef.DeleteDataDisplay.groupOf(groupName)); }
            if (DelivMatchFlg.name().equals(name())) { return toClsList(CDef.DelivMatchFlg.groupOf(groupName)); }
            if (DelivTz.name().equals(name())) { return toClsList(CDef.DelivTz.groupOf(groupName)); }
            if (DeliveryFlg.name().equals(name())) { return toClsList(CDef.DeliveryFlg.groupOf(groupName)); }
            if (DepositFlg.name().equals(name())) { return toClsList(CDef.DepositFlg.groupOf(groupName)); }
            if (DisplayRequired.name().equals(name())) { return toClsList(CDef.DisplayRequired.groupOf(groupName)); }
            if (DtCls.name().equals(name())) { return toClsList(CDef.DtCls.groupOf(groupName)); }
            if (Editable.name().equals(name())) { return toClsList(CDef.Editable.groupOf(groupName)); }
            if (EmergencyDisplay.name().equals(name())) { return toClsList(CDef.EmergencyDisplay.groupOf(groupName)); }
            if (EmergencyFlg.name().equals(name())) { return toClsList(CDef.EmergencyFlg.groupOf(groupName)); }
            if (ErrorFlg.name().equals(name())) { return toClsList(CDef.ErrorFlg.groupOf(groupName)); }
            if (ErrorProcessMet.name().equals(name())) { return toClsList(CDef.ErrorProcessMet.groupOf(groupName)); }
            if (FixedPoint.name().equals(name())) { return toClsList(CDef.FixedPoint.groupOf(groupName)); }
            if (ForceFixedFlg.name().equals(name())) { return toClsList(CDef.ForceFixedFlg.groupOf(groupName)); }
            if (ForeignFlg.name().equals(name())) { return toClsList(CDef.ForeignFlg.groupOf(groupName)); }
            if (GiftFlg.name().equals(name())) { return toClsList(CDef.GiftFlg.groupOf(groupName)); }
            if (GiftStatementType.name().equals(name())) { return toClsList(CDef.GiftStatementType.groupOf(groupName)); }
            if (HtCharReadFlg.name().equals(name())) { return toClsList(CDef.HtCharReadFlg.groupOf(groupName)); }
            if (ImportFlg.name().equals(name())) { return toClsList(CDef.ImportFlg.groupOf(groupName)); }
            if (InfoFlg.name().equals(name())) { return toClsList(CDef.InfoFlg.groupOf(groupName)); }
            if (InoutType.name().equals(name())) { return toClsList(CDef.InoutType.groupOf(groupName)); }
            if (InputType.name().equals(name())) { return toClsList(CDef.InputType.groupOf(groupName)); }
            if (InspectionFlg.name().equals(name())) { return toClsList(CDef.InspectionFlg.groupOf(groupName)); }
            if (InventoryLocationProduct.name().equals(name())) { return toClsList(CDef.InventoryLocationProduct.groupOf(groupName)); }
            if (InvoiceCreateFlg.name().equals(name())) { return toClsList(CDef.InvoiceCreateFlg.groupOf(groupName)); }
            if (ItemType.name().equals(name())) { return toClsList(CDef.ItemType.groupOf(groupName)); }
            if (LastFlg.name().equals(name())) { return toClsList(CDef.LastFlg.groupOf(groupName)); }
            if (LimitDtManagFlg.name().equals(name())) { return toClsList(CDef.LimitDtManagFlg.groupOf(groupName)); }
            if (LimitDtReverseFlg.name().equals(name())) { return toClsList(CDef.LimitDtReverseFlg.groupOf(groupName)); }
            if (LimitMessageCd.name().equals(name())) { return toClsList(CDef.LimitMessageCd.groupOf(groupName)); }
            if (LineFeedCd.name().equals(name())) { return toClsList(CDef.LineFeedCd.groupOf(groupName)); }
            if (ListOutFlg.name().equals(name())) { return toClsList(CDef.ListOutFlg.groupOf(groupName)); }
            if (ListOutKbn.name().equals(name())) { return toClsList(CDef.ListOutKbn.groupOf(groupName)); }
            if (ListOutFlgDisp.name().equals(name())) { return toClsList(CDef.ListOutFlgDisp.groupOf(groupName)); }
            if (LoadingFlg.name().equals(name())) { return toClsList(CDef.LoadingFlg.groupOf(groupName)); }
            if (LocationType.name().equals(name())) { return toClsList(CDef.LocationType.groupOf(groupName)); }
            if (Lockout.name().equals(name())) { return toClsList(CDef.Lockout.groupOf(groupName)); }
            if (LogDtlStatus.name().equals(name())) { return toClsList(CDef.LogDtlStatus.groupOf(groupName)); }
            if (LogDtlType.name().equals(name())) { return toClsList(CDef.LogDtlType.groupOf(groupName)); }
            if (LogStatus.name().equals(name())) { return toClsList(CDef.LogStatus.groupOf(groupName)); }
            if (LotManagFlg.name().equals(name())) { return toClsList(CDef.LotManagFlg.groupOf(groupName)); }
            if (LotReverseFlg.name().equals(name())) { return toClsList(CDef.LotReverseFlg.groupOf(groupName)); }
            if (MergeCls.name().equals(name())) { return toClsList(CDef.MergeCls.groupOf(groupName)); }
            if (MergeFlg.name().equals(name())) { return toClsList(CDef.MergeFlg.groupOf(groupName)); }
            if (MessageType.name().equals(name())) { return toClsList(CDef.MessageType.groupOf(groupName)); }
            if (MixedFlg.name().equals(name())) { return toClsList(CDef.MixedFlg.groupOf(groupName)); }
            if (MoveInstStatus.name().equals(name())) { return toClsList(CDef.MoveInstStatus.groupOf(groupName)); }
            if (MultiPicCls.name().equals(name())) { return toClsList(CDef.MultiPicCls.groupOf(groupName)); }
            if (MultiPicFlg.name().equals(name())) { return toClsList(CDef.MultiPicFlg.groupOf(groupName)); }
            if (Necessary.name().equals(name())) { return toClsList(CDef.Necessary.groupOf(groupName)); }
            if (NoAllcDisplayFlg.name().equals(name())) { return toClsList(CDef.NoAllcDisplayFlg.groupOf(groupName)); }
            if (NoConfirmedFlg.name().equals(name())) { return toClsList(CDef.NoConfirmedFlg.groupOf(groupName)); }
            if (NoStockCls.name().equals(name())) { return toClsList(CDef.NoStockCls.groupOf(groupName)); }
            if (NoStockOutFlg.name().equals(name())) { return toClsList(CDef.NoStockOutFlg.groupOf(groupName)); }
            if (NoUpsideDownCls.name().equals(name())) { return toClsList(CDef.NoUpsideDownCls.groupOf(groupName)); }
            if (NotCompletedFlg.name().equals(name())) { return toClsList(CDef.NotCompletedFlg.groupOf(groupName)); }
            if (OnetimeFlg.name().equals(name())) { return toClsList(CDef.OnetimeFlg.groupOf(groupName)); }
            if (OverStoreNumFlg.name().equals(name())) { return toClsList(CDef.OverStoreNumFlg.groupOf(groupName)); }
            if (PackingCalCls.name().equals(name())) { return toClsList(CDef.PackingCalCls.groupOf(groupName)); }
            if (PackingProcessCls.name().equals(name())) { return toClsList(CDef.PackingProcessCls.groupOf(groupName)); }
            if (PackingShowFlg.name().equals(name())) { return toClsList(CDef.PackingShowFlg.groupOf(groupName)); }
            if (PackingStatus.name().equals(name())) { return toClsList(CDef.PackingStatus.groupOf(groupName)); }
            if (PasswordReset.name().equals(name())) { return toClsList(CDef.PasswordReset.groupOf(groupName)); }
            if (PastStoreDtFlg.name().equals(name())) { return toClsList(CDef.PastStoreDtFlg.groupOf(groupName)); }
            if (PhysicalDelete.name().equals(name())) { return toClsList(CDef.PhysicalDelete.groupOf(groupName)); }
            if (PicCls.name().equals(name())) { return toClsList(CDef.PicCls.groupOf(groupName)); }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return toClsList(CDef.PicMthdRcmdBreakKey.groupOf(groupName)); }
            if (PicMthdRcmdFlg.name().equals(name())) { return toClsList(CDef.PicMthdRcmdFlg.groupOf(groupName)); }
            if (PicMthdRcmdListOut.name().equals(name())) { return toClsList(CDef.PicMthdRcmdListOut.groupOf(groupName)); }
            if (PickingFlg.name().equals(name())) { return toClsList(CDef.PickingFlg.groupOf(groupName)); }
            if (PickingLocationFlg.name().equals(name())) { return toClsList(CDef.PickingLocationFlg.groupOf(groupName)); }
            if (PickingStatus.name().equals(name())) { return toClsList(CDef.PickingStatus.groupOf(groupName)); }
            if (PickingType.name().equals(name())) { return toClsList(CDef.PickingType.groupOf(groupName)); }
            if (PostType.name().equals(name())) { return toClsList(CDef.PostType.groupOf(groupName)); }
            if (PrintDataType.name().equals(name())) { return toClsList(CDef.PrintDataType.groupOf(groupName)); }
            if (PrintErrorFlg.name().equals(name())) { return toClsList(CDef.PrintErrorFlg.groupOf(groupName)); }
            if (PrintQueueStatus.name().equals(name())) { return toClsList(CDef.PrintQueueStatus.groupOf(groupName)); }
            if (PrintResultClass.name().equals(name())) { return toClsList(CDef.PrintResultClass.groupOf(groupName)); }
            if (PrintServiceStatus.name().equals(name())) { return toClsList(CDef.PrintServiceStatus.groupOf(groupName)); }
            if (PrintStatus.name().equals(name())) { return toClsList(CDef.PrintStatus.groupOf(groupName)); }
            if (PrintedFlg.name().equals(name())) { return toClsList(CDef.PrintedFlg.groupOf(groupName)); }
            if (PriorityFlg.name().equals(name())) { return toClsList(CDef.PriorityFlg.groupOf(groupName)); }
            if (ProductLabelJanBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelJanBarcode.groupOf(groupName)); }
            if (ProductLabelOutUnit.name().equals(name())) { return toClsList(CDef.ProductLabelOutUnit.groupOf(groupName)); }
            if (ProductLabelProdBarcode.name().equals(name())) { return toClsList(CDef.ProductLabelProdBarcode.groupOf(groupName)); }
            if (ProductPartPacking.name().equals(name())) { return toClsList(CDef.ProductPartPacking.groupOf(groupName)); }
            if (ProductTypeCode.name().equals(name())) { return toClsList(CDef.ProductTypeCode.groupOf(groupName)); }
            if (Qty0Display.name().equals(name())) { return toClsList(CDef.Qty0Display.groupOf(groupName)); }
            if (ReasonType.name().equals(name())) { return toClsList(CDef.ReasonType.groupOf(groupName)); }
            if (ReceiveDeliveryStatus.name().equals(name())) { return toClsList(CDef.ReceiveDeliveryStatus.groupOf(groupName)); }
            if (ReceiveFlg.name().equals(name())) { return toClsList(CDef.ReceiveFlg.groupOf(groupName)); }
            if (ReceiveStatus.name().equals(name())) { return toClsList(CDef.ReceiveStatus.groupOf(groupName)); }
            if (ReplenishAllocCls.name().equals(name())) { return toClsList(CDef.ReplenishAllocCls.groupOf(groupName)); }
            if (ReplenishProductCdUnset.name().equals(name())) { return toClsList(CDef.ReplenishProductCdUnset.groupOf(groupName)); }
            if (ReplenishSearchCls.name().equals(name())) { return toClsList(CDef.ReplenishSearchCls.groupOf(groupName)); }
            if (ReplenishUnitCls.name().equals(name())) { return toClsList(CDef.ReplenishUnitCls.groupOf(groupName)); }
            if (ReportLayoutItemType.name().equals(name())) { return toClsList(CDef.ReportLayoutItemType.groupOf(groupName)); }
            if (RestockType.name().equals(name())) { return toClsList(CDef.RestockType.groupOf(groupName)); }
            if (ResultAfterProductLabel.name().equals(name())) { return toClsList(CDef.ResultAfterProductLabel.groupOf(groupName)); }
            if (ReverseValidFlg.name().equals(name())) { return toClsList(CDef.ReverseValidFlg.groupOf(groupName)); }
            if (Select.name().equals(name())) { return toClsList(CDef.Select.groupOf(groupName)); }
            if (SelectPrintServiceStatus.name().equals(name())) { return toClsList(CDef.SelectPrintServiceStatus.groupOf(groupName)); }
            if (SerialOperationType.name().equals(name())) { return toClsList(CDef.SerialOperationType.groupOf(groupName)); }
            if (TargetWindow.name().equals(name())) { return toClsList(CDef.TargetWindow.groupOf(groupName)); }
            if (SettlementType.name().equals(name())) { return toClsList(CDef.SettlementType.groupOf(groupName)); }
            if (SglRowInspAfterOutCls.name().equals(name())) { return toClsList(CDef.SglRowInspAfterOutCls.groupOf(groupName)); }
            if (SglRowPicFlg.name().equals(name())) { return toClsList(CDef.SglRowPicFlg.groupOf(groupName)); }
            if (SheetCollate.name().equals(name())) { return toClsList(CDef.SheetCollate.groupOf(groupName)); }
            if (ShippingFlg.name().equals(name())) { return toClsList(CDef.ShippingFlg.groupOf(groupName)); }
            if (ShippingStatus.name().equals(name())) { return toClsList(CDef.ShippingStatus.groupOf(groupName)); }
            if (ShippingStopFlg.name().equals(name())) { return toClsList(CDef.ShippingStopFlg.groupOf(groupName)); }
            if (ShortStockDisplay.name().equals(name())) { return toClsList(CDef.ShortStockDisplay.groupOf(groupName)); }
            if (ShpCheckCls.name().equals(name())) { return toClsList(CDef.ShpCheckCls.groupOf(groupName)); }
            if (ShpCheckDisplay.name().equals(name())) { return toClsList(CDef.ShpCheckDisplay.groupOf(groupName)); }
            if (SlipType.name().equals(name())) { return toClsList(CDef.SlipType.groupOf(groupName)); }
            if (SoundPlayFlg.name().equals(name())) { return toClsList(CDef.SoundPlayFlg.groupOf(groupName)); }
            if (StockAdjustFlg.name().equals(name())) { return toClsList(CDef.StockAdjustFlg.groupOf(groupName)); }
            if (StockDisplayFld.name().equals(name())) { return toClsList(CDef.StockDisplayFld.groupOf(groupName)); }
            if (StockExistOnlyFlg.name().equals(name())) { return toClsList(CDef.StockExistOnlyFlg.groupOf(groupName)); }
            if (StockMoveFlg.name().equals(name())) { return toClsList(CDef.StockMoveFlg.groupOf(groupName)); }
            if (StockNum0Display.name().equals(name())) { return toClsList(CDef.StockNum0Display.groupOf(groupName)); }
            if (StockOutAllocCls.name().equals(name())) { return toClsList(CDef.StockOutAllocCls.groupOf(groupName)); }
            if (StockOutAutoInstFlg.name().equals(name())) { return toClsList(CDef.StockOutAutoInstFlg.groupOf(groupName)); }
            if (StockOutFlg.name().equals(name())) { return toClsList(CDef.StockOutFlg.groupOf(groupName)); }
            if (StockOutInstCxlFlg.name().equals(name())) { return toClsList(CDef.StockOutInstCxlFlg.groupOf(groupName)); }
            if (StockOutInstSplitFlg.name().equals(name())) { return toClsList(CDef.StockOutInstSplitFlg.groupOf(groupName)); }
            if (StockQtyDisplay.name().equals(name())) { return toClsList(CDef.StockQtyDisplay.groupOf(groupName)); }
            if (StockTakingInput.name().equals(name())) { return toClsList(CDef.StockTakingInput.groupOf(groupName)); }
            if (StockTarget.name().equals(name())) { return toClsList(CDef.StockTarget.groupOf(groupName)); }
            if (StoreDtFlg.name().equals(name())) { return toClsList(CDef.StoreDtFlg.groupOf(groupName)); }
            if (StoreFlg.name().equals(name())) { return toClsList(CDef.StoreFlg.groupOf(groupName)); }
            if (StoreNoDivideDisplay.name().equals(name())) { return toClsList(CDef.StoreNoDivideDisplay.groupOf(groupName)); }
            if (StoreNoFlg.name().equals(name())) { return toClsList(CDef.StoreNoFlg.groupOf(groupName)); }
            if (StoreNoMergeFlg.name().equals(name())) { return toClsList(CDef.StoreNoMergeFlg.groupOf(groupName)); }
            if (SystemLogStatus.name().equals(name())) { return toClsList(CDef.SystemLogStatus.groupOf(groupName)); }
            if (SystemLogType.name().equals(name())) { return toClsList(CDef.SystemLogType.groupOf(groupName)); }
            if (SystemType.name().equals(name())) { return toClsList(CDef.SystemType.groupOf(groupName)); }
            if (TagDeliveryOutFlg.name().equals(name())) { return toClsList(CDef.TagDeliveryOutFlg.groupOf(groupName)); }
            if (TakingShippingDtFlg.name().equals(name())) { return toClsList(CDef.TakingShippingDtFlg.groupOf(groupName)); }
            if (TakingShippingFlg.name().equals(name())) { return toClsList(CDef.TakingShippingFlg.groupOf(groupName)); }
            if (TextAlign.name().equals(name())) { return toClsList(CDef.TextAlign.groupOf(groupName)); }
            if (TotalPicFlg.name().equals(name())) { return toClsList(CDef.TotalPicFlg.groupOf(groupName)); }
            if (TrackingNumberingUnit.name().equals(name())) { return toClsList(CDef.TrackingNumberingUnit.groupOf(groupName)); }
            if (TransitDisplay.name().equals(name())) { return toClsList(CDef.TransitDisplay.groupOf(groupName)); }
            if (Unmatch.name().equals(name())) { return toClsList(CDef.Unmatch.groupOf(groupName)); }
            if (UpdCd.name().equals(name())) { return toClsList(CDef.UpdCd.groupOf(groupName)); }
            if (UpdType.name().equals(name())) { return toClsList(CDef.UpdType.groupOf(groupName)); }
            if (Updatable.name().equals(name())) { return toClsList(CDef.Updatable.groupOf(groupName)); }
            if (UploadTableNm.name().equals(name())) { return toClsList(CDef.UploadTableNm.groupOf(groupName)); }
            if (UseHtShipFlg.name().equals(name())) { return toClsList(CDef.UseHtShipFlg.groupOf(groupName)); }
            if (UserEditable.name().equals(name())) { return toClsList(CDef.UserEditable.groupOf(groupName)); }
            if (VendorFlg.name().equals(name())) { return toClsList(CDef.VendorFlg.groupOf(groupName)); }
            if (Visible.name().equals(name())) { return toClsList(CDef.Visible.groupOf(groupName)); }
            if (WorkFlg.name().equals(name())) { return toClsList(CDef.WorkFlg.groupOf(groupName)); }
            if (WorkMessageFlg.name().equals(name())) { return toClsList(CDef.WorkMessageFlg.groupOf(groupName)); }
            if (YamatoDelivTz.name().equals(name())) { return toClsList(CDef.YamatoDelivTz.groupOf(groupName)); }
            if (YupackDelivTz.name().equals(name())) { return toClsList(CDef.YupackDelivTz.groupOf(groupName)); }
            if (ZipFlg.name().equals(name())) { return toClsList(CDef.ZipFlg.groupOf(groupName)); }
            if (ResultAfterProductTarget.name().equals(name())) { return toClsList(CDef.ResultAfterProductTarget.groupOf(groupName)); }
            if (CopyTargetTable.name().equals(name())) { return toClsList(CDef.CopyTargetTable.groupOf(groupName)); }
            if (InspectionLabelOutFlg.name().equals(name())) { return toClsList(CDef.InspectionLabelOutFlg.groupOf(groupName)); }
            if (DecimalProductPacking.name().equals(name())) { return toClsList(CDef.DecimalProductPacking.groupOf(groupName)); }
            if (DecimalExistFlg.name().equals(name())) { return toClsList(CDef.DecimalExistFlg.groupOf(groupName)); }
            if (CasePickFlg.name().equals(name())) { return toClsList(CDef.CasePickFlg.groupOf(groupName)); }
            if (EmReplenishShapeFlg.name().equals(name())) { return toClsList(CDef.EmReplenishShapeFlg.groupOf(groupName)); }
            if (WorkStatus.name().equals(name())) { return toClsList(CDef.WorkStatus.groupOf(groupName)); }
            if (WorkLogOutFlg.name().equals(name())) { return toClsList(CDef.WorkLogOutFlg.groupOf(groupName)); }
            if (RoleControlClass.name().equals(name())) { return toClsList(CDef.RoleControlClass.groupOf(groupName)); }
            if (BolOutFlg.name().equals(name())) { return toClsList(CDef.BolOutFlg.groupOf(groupName)); }
            if (BolOutputTargetFlg.name().equals(name())) { return toClsList(CDef.BolOutputTargetFlg.groupOf(groupName)); }
            if (PaymentTerm.name().equals(name())) { return toClsList(CDef.PaymentTerm.groupOf(groupName)); }
            if (CesIntegrationFlg.name().equals(name())) { return toClsList(CDef.CesIntegrationFlg.groupOf(groupName)); }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return toClsList(CDef.PackingSlipAutoOutputFlg.groupOf(groupName)); }
            if (FreightCls.name().equals(name())) { return toClsList(CDef.FreightCls.groupOf(groupName)); }
            if (SatDeliveryFlg.name().equals(name())) { return toClsList(CDef.SatDeliveryFlg.groupOf(groupName)); }
            if (ResidentialDeliveryFlg.name().equals(name())) { return toClsList(CDef.ResidentialDeliveryFlg.groupOf(groupName)); }
            if (CodFlg.name().equals(name())) { return toClsList(CDef.CodFlg.groupOf(groupName)); }
            if (SignatureRequiredFlg.name().equals(name())) { return toClsList(CDef.SignatureRequiredFlg.groupOf(groupName)); }
            if (SignatureReleaseFlg.name().equals(name())) { return toClsList(CDef.SignatureReleaseFlg.groupOf(groupName)); }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return toClsList(CDef.CallBeforeDeliveryFlg.groupOf(groupName)); }
            if (FreezableProtectionFlg.name().equals(name())) { return toClsList(CDef.FreezableProtectionFlg.groupOf(groupName)); }
            if (GuaranteedPlusFlg.name().equals(name())) { return toClsList(CDef.GuaranteedPlusFlg.groupOf(groupName)); }
            if (ResidentialPickupFlg.name().equals(name())) { return toClsList(CDef.ResidentialPickupFlg.groupOf(groupName)); }
            if (DoNotStackStackFlg.name().equals(name())) { return toClsList(CDef.DoNotStackStackFlg.groupOf(groupName)); }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessDeliveryFlg.groupOf(groupName)); }
            if (LimitedAccessPickupFlg.name().equals(name())) { return toClsList(CDef.LimitedAccessPickupFlg.groupOf(groupName)); }
            if (OverSizedFlg.name().equals(name())) { return toClsList(CDef.OverSizedFlg.groupOf(groupName)); }
            if (PoisonFlg.name().equals(name())) { return toClsList(CDef.PoisonFlg.groupOf(groupName)); }
            if (FoogFlg.name().equals(name())) { return toClsList(CDef.FoogFlg.groupOf(groupName)); }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryPrepaidFlg.groupOf(groupName)); }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgateDeliveryCollectFlg.groupOf(groupName)); }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupPrepaidFlg.groupOf(groupName)); }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return toClsList(CDef.LiftgatePickupCollectFlg.groupOf(groupName)); }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryPrepaidFlg.groupOf(groupName)); }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return toClsList(CDef.InsideDeliveryCollectFlg.groupOf(groupName)); }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return toClsList(CDef.InsidePickupPrepaidFlg.groupOf(groupName)); }
            if (InsidePickupCollectFlg.name().equals(name())) { return toClsList(CDef.InsidePickupCollectFlg.groupOf(groupName)); }
            if (RcmdPickingCls.name().equals(name())) { return toClsList(CDef.RcmdPickingCls.groupOf(groupName)); }
            if (SglRowPicTarget.name().equals(name())) { return toClsList(CDef.SglRowPicTarget.groupOf(groupName)); }
            if (CasePicTarget.name().equals(name())) { return toClsList(CDef.CasePicTarget.groupOf(groupName)); }
            if (AttendanceLeavingRest.name().equals(name())) { return toClsList(CDef.AttendanceLeavingRest.groupOf(groupName)); }
            if (UploadZipType.name().equals(name())) { return toClsList(CDef.UploadZipType.groupOf(groupName)); }
            if (FwType.name().equals(name())) { return toClsList(CDef.FwType.groupOf(groupName)); }
            if (McaType.name().equals(name())) { return toClsList(CDef.McaType.groupOf(groupName)); }
            if (AccountFlg.name().equals(name())) { return toClsList(CDef.AccountFlg.groupOf(groupName)); }
            if (AlarmReasonCls.name().equals(name())) { return toClsList(CDef.AlarmReasonCls.groupOf(groupName)); }
            if (AlarmType.name().equals(name())) { return toClsList(CDef.AlarmType.groupOf(groupName)); }
            if (AreaCls.name().equals(name())) { return toClsList(CDef.AreaCls.groupOf(groupName)); }
            if (AssortStatus.name().equals(name())) { return toClsList(CDef.AssortStatus.groupOf(groupName)); }
            if (BaseCls.name().equals(name())) { return toClsList(CDef.BaseCls.groupOf(groupName)); }
            if (BoxType.name().equals(name())) { return toClsList(CDef.BoxType.groupOf(groupName)); }
            if (CarrierType.name().equals(name())) { return toClsList(CDef.CarrierType.groupOf(groupName)); }
            if (CarrierTypeCd.name().equals(name())) { return toClsList(CDef.CarrierTypeCd.groupOf(groupName)); }
            if (CaseTypeCd.name().equals(name())) { return toClsList(CDef.CaseTypeCd.groupOf(groupName)); }
            if (ClosingDt.name().equals(name())) { return toClsList(CDef.ClosingDt.groupOf(groupName)); }
            if (CompletedHidden.name().equals(name())) { return toClsList(CDef.CompletedHidden.groupOf(groupName)); }
            if (Condition.name().equals(name())) { return toClsList(CDef.Condition.groupOf(groupName)); }
            if (Constract.name().equals(name())) { return toClsList(CDef.Constract.groupOf(groupName)); }
            if (CsPsType.name().equals(name())) { return toClsList(CDef.CsPsType.groupOf(groupName)); }
            if (DefaultStockType.name().equals(name())) { return toClsList(CDef.DefaultStockType.groupOf(groupName)); }
            if (DelivCenterFrom.name().equals(name())) { return toClsList(CDef.DelivCenterFrom.groupOf(groupName)); }
            if (DelivCenterTo.name().equals(name())) { return toClsList(CDef.DelivCenterTo.groupOf(groupName)); }
            if (DeliveryDtUnspecified.name().equals(name())) { return toClsList(CDef.DeliveryDtUnspecified.groupOf(groupName)); }
            if (DeliveryTimeZone.name().equals(name())) { return toClsList(CDef.DeliveryTimeZone.groupOf(groupName)); }
            if (DeliveryTypeSendCls.name().equals(name())) { return toClsList(CDef.DeliveryTypeSendCls.groupOf(groupName)); }
            if (DepositItemFlg.name().equals(name())) { return toClsList(CDef.DepositItemFlg.groupOf(groupName)); }
            if (DepositType.name().equals(name())) { return toClsList(CDef.DepositType.groupOf(groupName)); }
            if (DiffCls.name().equals(name())) { return toClsList(CDef.DiffCls.groupOf(groupName)); }
            if (DirectDeliveryTypeCd.name().equals(name())) { return toClsList(CDef.DirectDeliveryTypeCd.groupOf(groupName)); }
            if (EcOrder.name().equals(name())) { return toClsList(CDef.EcOrder.groupOf(groupName)); }
            if (EcType.name().equals(name())) { return toClsList(CDef.EcType.groupOf(groupName)); }
            if (ExecuteStatus.name().equals(name())) { return toClsList(CDef.ExecuteStatus.groupOf(groupName)); }
            if (Fee.name().equals(name())) { return toClsList(CDef.Fee.groupOf(groupName)); }
            if (Floor.name().equals(name())) { return toClsList(CDef.Floor.groupOf(groupName)); }
            if (FloorCd.name().equals(name())) { return toClsList(CDef.FloorCd.groupOf(groupName)); }
            if (FloorEndFlg.name().equals(name())) { return toClsList(CDef.FloorEndFlg.groupOf(groupName)); }
            if (FloorTypeCd.name().equals(name())) { return toClsList(CDef.FloorTypeCd.groupOf(groupName)); }
            if (HandOverStatus.name().equals(name())) { return toClsList(CDef.HandOverStatus.groupOf(groupName)); }
            if (HandlingType.name().equals(name())) { return toClsList(CDef.HandlingType.groupOf(groupName)); }
            if (HeavyItemFlg.name().equals(name())) { return toClsList(CDef.HeavyItemFlg.groupOf(groupName)); }
            if (HeavyItemHadlingFlg.name().equals(name())) { return toClsList(CDef.HeavyItemHadlingFlg.groupOf(groupName)); }
            if (HinmokuGroupCd.name().equals(name())) { return toClsList(CDef.HinmokuGroupCd.groupOf(groupName)); }
            if (HolidayFlg.name().equals(name())) { return toClsList(CDef.HolidayFlg.groupOf(groupName)); }
            if (IdManagAbolitionTypeCd.name().equals(name())) { return toClsList(CDef.IdManagAbolitionTypeCd.groupOf(groupName)); }
            if (InsuranceFlg.name().equals(name())) { return toClsList(CDef.InsuranceFlg.groupOf(groupName)); }
            if (InventoryDataStatus.name().equals(name())) { return toClsList(CDef.InventoryDataStatus.groupOf(groupName)); }
            if (InventoryDiffCls.name().equals(name())) { return toClsList(CDef.InventoryDiffCls.groupOf(groupName)); }
            if (InventoryInputCls.name().equals(name())) { return toClsList(CDef.InventoryInputCls.groupOf(groupName)); }
            if (InventoryListOutCls.name().equals(name())) { return toClsList(CDef.InventoryListOutCls.groupOf(groupName)); }
            if (InventoryListType.name().equals(name())) { return toClsList(CDef.InventoryListType.groupOf(groupName)); }
            if (ItManagType.name().equals(name())) { return toClsList(CDef.ItManagType.groupOf(groupName)); }
            if (ItemDensan.name().equals(name())) { return toClsList(CDef.ItemDensan.groupOf(groupName)); }
            if (LargeItemFlg.name().equals(name())) { return toClsList(CDef.LargeItemFlg.groupOf(groupName)); }
            if (LimitDtSplitTypeCd.name().equals(name())) { return toClsList(CDef.LimitDtSplitTypeCd.groupOf(groupName)); }
            if (LimitDtUnmatchTypeCd.name().equals(name())) { return toClsList(CDef.LimitDtUnmatchTypeCd.groupOf(groupName)); }
            if (LogiAttentionTypeCd.name().equals(name())) { return toClsList(CDef.LogiAttentionTypeCd.groupOf(groupName)); }
            if (LogiSpecialTypeCd.name().equals(name())) { return toClsList(CDef.LogiSpecialTypeCd.groupOf(groupName)); }
            if (LogiWeightFlg.name().equals(name())) { return toClsList(CDef.LogiWeightFlg.groupOf(groupName)); }
            if (LotSplitTypeCd.name().equals(name())) { return toClsList(CDef.LotSplitTypeCd.groupOf(groupName)); }
            if (LotUnmatchTypeCd.name().equals(name())) { return toClsList(CDef.LotUnmatchTypeCd.groupOf(groupName)); }
            if (MaxStoreShape.name().equals(name())) { return toClsList(CDef.MaxStoreShape.groupOf(groupName)); }
            if (MedicalManagFlg.name().equals(name())) { return toClsList(CDef.MedicalManagFlg.groupOf(groupName)); }
            if (MoveDirection.name().equals(name())) { return toClsList(CDef.MoveDirection.groupOf(groupName)); }
            if (NationalHolidayCarrier.name().equals(name())) { return toClsList(CDef.NationalHolidayCarrier.groupOf(groupName)); }
            if (NationalHolidayFlg.name().equals(name())) { return toClsList(CDef.NationalHolidayFlg.groupOf(groupName)); }
            if (NizoroeProcessId.name().equals(name())) { return toClsList(CDef.NizoroeProcessId.groupOf(groupName)); }
            if (NizoroeProcessIdWms.name().equals(name())) { return toClsList(CDef.NizoroeProcessIdWms.groupOf(groupName)); }
            if (NizoroeTime.name().equals(name())) { return toClsList(CDef.NizoroeTime.groupOf(groupName)); }
            if (NizoroeType.name().equals(name())) { return toClsList(CDef.NizoroeType.groupOf(groupName)); }
            if (NizoroeTypeWms.name().equals(name())) { return toClsList(CDef.NizoroeTypeWms.groupOf(groupName)); }
            if (NoOkinawaFlightFlg.name().equals(name())) { return toClsList(CDef.NoOkinawaFlightFlg.groupOf(groupName)); }
            if (OcrDateFormat.name().equals(name())) { return toClsList(CDef.OcrDateFormat.groupOf(groupName)); }
            if (OutputListType.name().equals(name())) { return toClsList(CDef.OutputListType.groupOf(groupName)); }
            if (OutputMonth.name().equals(name())) { return toClsList(CDef.OutputMonth.groupOf(groupName)); }
            if (OutputStatus.name().equals(name())) { return toClsList(CDef.OutputStatus.groupOf(groupName)); }
            if (PaymentTypeCd.name().equals(name())) { return toClsList(CDef.PaymentTypeCd.groupOf(groupName)); }
            if (PickingPatternCd.name().equals(name())) { return toClsList(CDef.PickingPatternCd.groupOf(groupName)); }
            if (Prefecture.name().equals(name())) { return toClsList(CDef.Prefecture.groupOf(groupName)); }
            if (PriceDiffHidden.name().equals(name())) { return toClsList(CDef.PriceDiffHidden.groupOf(groupName)); }
            if (ProdDtManagFlg.name().equals(name())) { return toClsList(CDef.ProdDtManagFlg.groupOf(groupName)); }
            if (ProdDtSplitTypeCd.name().equals(name())) { return toClsList(CDef.ProdDtSplitTypeCd.groupOf(groupName)); }
            if (ProdDtUnmatchTypeCd.name().equals(name())) { return toClsList(CDef.ProdDtUnmatchTypeCd.groupOf(groupName)); }
            if (ProductCategoryConvertCls.name().equals(name())) { return toClsList(CDef.ProductCategoryConvertCls.groupOf(groupName)); }
            if (ProductCategoryPlant.name().equals(name())) { return toClsList(CDef.ProductCategoryPlant.groupOf(groupName)); }
            if (ProductCategoryType.name().equals(name())) { return toClsList(CDef.ProductCategoryType.groupOf(groupName)); }
            if (ProductStoreStatus.name().equals(name())) { return toClsList(CDef.ProductStoreStatus.groupOf(groupName)); }
            if (ProductUnitCls.name().equals(name())) { return toClsList(CDef.ProductUnitCls.groupOf(groupName)); }
            if (ReceiveReason.name().equals(name())) { return toClsList(CDef.ReceiveReason.groupOf(groupName)); }
            if (ReceiveReasonConvert.name().equals(name())) { return toClsList(CDef.ReceiveReasonConvert.groupOf(groupName)); }
            if (ReceiveReasonDepositReceive.name().equals(name())) { return toClsList(CDef.ReceiveReasonDepositReceive.groupOf(groupName)); }
            if (ReceiveStatus01.name().equals(name())) { return toClsList(CDef.ReceiveStatus01.groupOf(groupName)); }
            if (RecommendLocationTypeCd.name().equals(name())) { return toClsList(CDef.RecommendLocationTypeCd.groupOf(groupName)); }
            if (RelatedProducts.name().equals(name())) { return toClsList(CDef.RelatedProducts.groupOf(groupName)); }
            if (RemainFlg.name().equals(name())) { return toClsList(CDef.RemainFlg.groupOf(groupName)); }
            if (ReplenishShape.name().equals(name())) { return toClsList(CDef.ReplenishShape.groupOf(groupName)); }
            if (SampleCls.name().equals(name())) { return toClsList(CDef.SampleCls.groupOf(groupName)); }
            if (SearchReferenceDt.name().equals(name())) { return toClsList(CDef.SearchReferenceDt.groupOf(groupName)); }
            if (SerialManagFlg.name().equals(name())) { return toClsList(CDef.SerialManagFlg.groupOf(groupName)); }
            if (ShapeGrpTypeCd.name().equals(name())) { return toClsList(CDef.ShapeGrpTypeCd.groupOf(groupName)); }
            if (SharedProductTypeCd.name().equals(name())) { return toClsList(CDef.SharedProductTypeCd.groupOf(groupName)); }
            if (ShippingInspectionHidden.name().equals(name())) { return toClsList(CDef.ShippingInspectionHidden.groupOf(groupName)); }
            if (ShippingInspectionStatus.name().equals(name())) { return toClsList(CDef.ShippingInspectionStatus.groupOf(groupName)); }
            if (ShippingProcessType.name().equals(name())) { return toClsList(CDef.ShippingProcessType.groupOf(groupName)); }
            if (ShippingProgress.name().equals(name())) { return toClsList(CDef.ShippingProgress.groupOf(groupName)); }
            if (ShippingReason.name().equals(name())) { return toClsList(CDef.ShippingReason.groupOf(groupName)); }
            if (ShippingReasonConvert.name().equals(name())) { return toClsList(CDef.ShippingReasonConvert.groupOf(groupName)); }
            if (ShippingSlipType.name().equals(name())) { return toClsList(CDef.ShippingSlipType.groupOf(groupName)); }
            if (ShippingType.name().equals(name())) { return toClsList(CDef.ShippingType.groupOf(groupName)); }
            if (ShippingWorkType.name().equals(name())) { return toClsList(CDef.ShippingWorkType.groupOf(groupName)); }
            if (SlipType2.name().equals(name())) { return toClsList(CDef.SlipType2.groupOf(groupName)); }
            if (SpareTypeCd.name().equals(name())) { return toClsList(CDef.SpareTypeCd.groupOf(groupName)); }
            if (SpecifiedNumOfShoes.name().equals(name())) { return toClsList(CDef.SpecifiedNumOfShoes.groupOf(groupName)); }
            if (SplitDeliveryTypeCd.name().equals(name())) { return toClsList(CDef.SplitDeliveryTypeCd.groupOf(groupName)); }
            if (StockDifference.name().equals(name())) { return toClsList(CDef.StockDifference.groupOf(groupName)); }
            if (StockDisplayType.name().equals(name())) { return toClsList(CDef.StockDisplayType.groupOf(groupName)); }
            if (StockExist.name().equals(name())) { return toClsList(CDef.StockExist.groupOf(groupName)); }
            if (StockProcessType.name().equals(name())) { return toClsList(CDef.StockProcessType.groupOf(groupName)); }
            if (StockRefCls.name().equals(name())) { return toClsList(CDef.StockRefCls.groupOf(groupName)); }
            if (StockTakingStatus.name().equals(name())) { return toClsList(CDef.StockTakingStatus.groupOf(groupName)); }
            if (StockZeroDisplay.name().equals(name())) { return toClsList(CDef.StockZeroDisplay.groupOf(groupName)); }
            if (SuppliesVarietyFlg.name().equals(name())) { return toClsList(CDef.SuppliesVarietyFlg.groupOf(groupName)); }
            if (TargetBase.name().equals(name())) { return toClsList(CDef.TargetBase.groupOf(groupName)); }
            if (TargetItemCd.name().equals(name())) { return toClsList(CDef.TargetItemCd.groupOf(groupName)); }
            if (TargetKoguchiCd.name().equals(name())) { return toClsList(CDef.TargetKoguchiCd.groupOf(groupName)); }
            if (TargetSalesCd.name().equals(name())) { return toClsList(CDef.TargetSalesCd.groupOf(groupName)); }
            if (UnitCls.name().equals(name())) { return toClsList(CDef.UnitCls.groupOf(groupName)); }
            if (UrgentShippingTimeZone.name().equals(name())) { return toClsList(CDef.UrgentShippingTimeZone.groupOf(groupName)); }
            if (WorkType.name().equals(name())) { return toClsList(CDef.WorkType.groupOf(groupName)); }
            if (ReceiveLabelFlg.name().equals(name())) { return toClsList(CDef.ReceiveLabelFlg.groupOf(groupName)); }
            if (ReceiveDtUnmatchFlg.name().equals(name())) { return toClsList(CDef.ReceiveDtUnmatchFlg.groupOf(groupName)); }
            if (PrintFlg.name().equals(name())) { return toClsList(CDef.PrintFlg.groupOf(groupName)); }
            if (ReceiveRemainFlg.name().equals(name())) { return toClsList(CDef.ReceiveRemainFlg.groupOf(groupName)); }
            if (ShippingPickedHidden.name().equals(name())) { return toClsList(CDef.ShippingPickedHidden.groupOf(groupName)); }
            if (CarrierDataOutFlg.name().equals(name())) { return toClsList(CDef.CarrierDataOutFlg.groupOf(groupName)); }
            if (PllOutFlg.name().equals(name())) { return toClsList(CDef.PllOutFlg.groupOf(groupName)); }
            if (DepositorCls.name().equals(name())) { return toClsList(CDef.DepositorCls.groupOf(groupName)); }
            if (RplOutFlg.name().equals(name())) { return toClsList(CDef.RplOutFlg.groupOf(groupName)); }
            if (RecordSendFlg.name().equals(name())) { return toClsList(CDef.RecordSendFlg.groupOf(groupName)); }
            if (HandOverHidden.name().equals(name())) { return toClsList(CDef.HandOverHidden.groupOf(groupName)); }
            if (ExternalWarehouseFlg.name().equals(name())) { return toClsList(CDef.ExternalWarehouseFlg.groupOf(groupName)); }
            if (StandardPlantCls.name().equals(name())) { return toClsList(CDef.StandardPlantCls.groupOf(groupName)); }
            if (LargeItemHadlingFlg.name().equals(name())) { return toClsList(CDef.LargeItemHadlingFlg.groupOf(groupName)); }
            if (HolidayCarrierFlg.name().equals(name())) { return toClsList(CDef.HolidayCarrierFlg.groupOf(groupName)); }
            if (OkinawaFlightFlg.name().equals(name())) { return toClsList(CDef.OkinawaFlightFlg.groupOf(groupName)); }
            if (BaseDefaultCarrierFlg.name().equals(name())) { return toClsList(CDef.BaseDefaultCarrierFlg.groupOf(groupName)); }
            if (SlipTypeCd.name().equals(name())) { return toClsList(CDef.SlipTypeCd.groupOf(groupName)); }
            if (ProperFlg.name().equals(name())) { return toClsList(CDef.ProperFlg.groupOf(groupName)); }
            if (CdlOutFlg.name().equals(name())) { return toClsList(CDef.CdlOutFlg.groupOf(groupName)); }
            if (ErrorNum.name().equals(name())) { return toClsList(CDef.ErrorNum.groupOf(groupName)); }
            if (CenterPicListCls1.name().equals(name())) { return toClsList(CDef.CenterPicListCls1.groupOf(groupName)); }
            if (CenterPicListCls2.name().equals(name())) { return toClsList(CDef.CenterPicListCls2.groupOf(groupName)); }
            if (CenterPicListCls3.name().equals(name())) { return toClsList(CDef.CenterPicListCls3.groupOf(groupName)); }
            if (CenterSagawaDelivTz.name().equals(name())) { return toClsList(CDef.CenterSagawaDelivTz.groupOf(groupName)); }
            if (CenterTransportTypeItem.name().equals(name())) { return toClsList(CDef.CenterTransportTypeItem.groupOf(groupName)); }
            if (CenterSlipShapeCd.name().equals(name())) { return toClsList(CDef.CenterSlipShapeCd.groupOf(groupName)); }
            if (CenterTransportTypeSpeed.name().equals(name())) { return toClsList(CDef.CenterTransportTypeSpeed.groupOf(groupName)); }
            if (CenterSealType.name().equals(name())) { return toClsList(CDef.CenterSealType.groupOf(groupName)); }
            if (CenterTagClass.name().equals(name())) { return toClsList(CDef.CenterTagClass.groupOf(groupName)); }
            if (CenterTagDataType.name().equals(name())) { return toClsList(CDef.CenterTagDataType.groupOf(groupName)); }
            if (CenterTagType.name().equals(name())) { return toClsList(CDef.CenterTagType.groupOf(groupName)); }
            if (CenterTagTypeAfter.name().equals(name())) { return toClsList(CDef.CenterTagTypeAfter.groupOf(groupName)); }
            if (CenterApiBinsyuCode.name().equals(name())) { return toClsList(CDef.CenterApiBinsyuCode.groupOf(groupName)); }
            if (CenterApiDaibikiFlg.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiFlg.groupOf(groupName)); }
            if (CenterApiDaibikiType.name().equals(name())) { return toClsList(CDef.CenterApiDaibikiType.groupOf(groupName)); }
            if (CenterApiEidomeFlg.name().equals(name())) { return toClsList(CDef.CenterApiEidomeFlg.groupOf(groupName)); }
            if (CenterApiWeightCd.name().equals(name())) { return toClsList(CDef.CenterApiWeightCd.groupOf(groupName)); }
            if (CenterOutputTargetFlg.name().equals(name())) { return toClsList(CDef.CenterOutputTargetFlg.groupOf(groupName)); }
            if (CenterPrintCondition.name().equals(name())) { return toClsList(CDef.CenterPrintCondition.groupOf(groupName)); }
            throw new IllegalStateException("Unknown definition: " + this); // basically unreachable
        }

        @SuppressWarnings("unchecked")
        private List<Classification> toClsList(List<?> clsList) {
            return (List<Classification>)clsList;
        }

        public ClassificationCodeType codeType() {
            if (ProcessTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return ClassificationCodeType.String; }
            if (AfterTagOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (AllShippingFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (AllcNgDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (AllcNgFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (AllocSortKey.name().equals(name())) { return ClassificationCodeType.String; }
            if (ArrivalStoreFormat.name().equals(name())) { return ClassificationCodeType.String; }
            if (AutoEmgSetFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (AutoEmgSetTgt.name().equals(name())) { return ClassificationCodeType.String; }
            if (AutoPrintTargetFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (AutoShipInstFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (BarcodeType.name().equals(name())) { return ClassificationCodeType.String; }
            if (BatchProgressFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (BoxSelectSkip.name().equals(name())) { return ClassificationCodeType.String; }
            if (CancelDataDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (CasePicFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterClientCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterTransitFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CharacterCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (ChargeQty0Display.name().equals(name())) { return ClassificationCodeType.String; }
            if (CheckDigit.name().equals(name())) { return ClassificationCodeType.String; }
            if (CodCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (CodType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CodeFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CodeType.name().equals(name())) { return ClassificationCodeType.String; }
            if (ColType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CommentFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CompanyFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CoolCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (CoolType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CorrectType.name().equals(name())) { return ClassificationCodeType.String; }
            if (DataInputCommitType.name().equals(name())) { return ClassificationCodeType.String; }
            if (DataInputOperationType.name().equals(name())) { return ClassificationCodeType.String; }
            if (DataInputProcessType.name().equals(name())) { return ClassificationCodeType.String; }
            if (DataInputRange.name().equals(name())) { return ClassificationCodeType.String; }
            if (DataInputType.name().equals(name())) { return ClassificationCodeType.String; }
            if (DataType.name().equals(name())) { return ClassificationCodeType.String; }
            if (Default.name().equals(name())) { return ClassificationCodeType.String; }
            if (DefaultFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DelFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DeleteDataDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (DelivMatchFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DelivTz.name().equals(name())) { return ClassificationCodeType.String; }
            if (DeliveryFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DepositFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DisplayRequired.name().equals(name())) { return ClassificationCodeType.String; }
            if (DtCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (Editable.name().equals(name())) { return ClassificationCodeType.String; }
            if (EmergencyDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (EmergencyFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ErrorFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ErrorProcessMet.name().equals(name())) { return ClassificationCodeType.String; }
            if (FixedPoint.name().equals(name())) { return ClassificationCodeType.String; }
            if (ForceFixedFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ForeignFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (GiftFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (GiftStatementType.name().equals(name())) { return ClassificationCodeType.String; }
            if (HtCharReadFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ImportFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InfoFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InoutType.name().equals(name())) { return ClassificationCodeType.String; }
            if (InputType.name().equals(name())) { return ClassificationCodeType.String; }
            if (InspectionFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InventoryLocationProduct.name().equals(name())) { return ClassificationCodeType.String; }
            if (InvoiceCreateFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ItemType.name().equals(name())) { return ClassificationCodeType.String; }
            if (LastFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LimitDtManagFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LimitDtReverseFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LimitMessageCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (LineFeedCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (ListOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ListOutKbn.name().equals(name())) { return ClassificationCodeType.String; }
            if (ListOutFlgDisp.name().equals(name())) { return ClassificationCodeType.String; }
            if (LoadingFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LocationType.name().equals(name())) { return ClassificationCodeType.String; }
            if (Lockout.name().equals(name())) { return ClassificationCodeType.String; }
            if (LogDtlStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (LogDtlType.name().equals(name())) { return ClassificationCodeType.String; }
            if (LogStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (LotManagFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LotReverseFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (MergeCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (MergeFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (MessageType.name().equals(name())) { return ClassificationCodeType.String; }
            if (MixedFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (MoveInstStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (MultiPicCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (MultiPicFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Necessary.name().equals(name())) { return ClassificationCodeType.String; }
            if (NoAllcDisplayFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (NoConfirmedFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (NoStockCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (NoStockOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (NoUpsideDownCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (NotCompletedFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (OnetimeFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (OverStoreNumFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PackingCalCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (PackingProcessCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (PackingShowFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PackingStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (PasswordReset.name().equals(name())) { return ClassificationCodeType.String; }
            if (PastStoreDtFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PhysicalDelete.name().equals(name())) { return ClassificationCodeType.String; }
            if (PicCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return ClassificationCodeType.String; }
            if (PicMthdRcmdFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PicMthdRcmdListOut.name().equals(name())) { return ClassificationCodeType.String; }
            if (PickingFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PickingLocationFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PickingStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (PickingType.name().equals(name())) { return ClassificationCodeType.String; }
            if (PostType.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrintDataType.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrintErrorFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrintQueueStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrintResultClass.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrintServiceStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrintStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrintedFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PriorityFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProductLabelJanBarcode.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProductLabelOutUnit.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProductLabelProdBarcode.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProductPartPacking.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProductTypeCode.name().equals(name())) { return ClassificationCodeType.String; }
            if (Qty0Display.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReasonType.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReceiveDeliveryStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReceiveFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReceiveStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReplenishAllocCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReplenishProductCdUnset.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReplenishSearchCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReplenishUnitCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReportLayoutItemType.name().equals(name())) { return ClassificationCodeType.String; }
            if (RestockType.name().equals(name())) { return ClassificationCodeType.String; }
            if (ResultAfterProductLabel.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReverseValidFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Select.name().equals(name())) { return ClassificationCodeType.String; }
            if (SelectPrintServiceStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (SerialOperationType.name().equals(name())) { return ClassificationCodeType.String; }
            if (TargetWindow.name().equals(name())) { return ClassificationCodeType.String; }
            if (SettlementType.name().equals(name())) { return ClassificationCodeType.String; }
            if (SglRowInspAfterOutCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (SglRowPicFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (SheetCollate.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingStopFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShortStockDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShpCheckCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShpCheckDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (SlipType.name().equals(name())) { return ClassificationCodeType.String; }
            if (SoundPlayFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockAdjustFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockDisplayFld.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockExistOnlyFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockMoveFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockNum0Display.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockOutAllocCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockOutAutoInstFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockOutInstCxlFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockOutInstSplitFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockQtyDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockTakingInput.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockTarget.name().equals(name())) { return ClassificationCodeType.String; }
            if (StoreDtFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StoreFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StoreNoDivideDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (StoreNoFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StoreNoMergeFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (SystemLogStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (SystemLogType.name().equals(name())) { return ClassificationCodeType.String; }
            if (SystemType.name().equals(name())) { return ClassificationCodeType.String; }
            if (TagDeliveryOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (TakingShippingDtFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (TakingShippingFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (TextAlign.name().equals(name())) { return ClassificationCodeType.String; }
            if (TotalPicFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (TrackingNumberingUnit.name().equals(name())) { return ClassificationCodeType.String; }
            if (TransitDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (Unmatch.name().equals(name())) { return ClassificationCodeType.String; }
            if (UpdCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (UpdType.name().equals(name())) { return ClassificationCodeType.String; }
            if (Updatable.name().equals(name())) { return ClassificationCodeType.String; }
            if (UploadTableNm.name().equals(name())) { return ClassificationCodeType.String; }
            if (UseHtShipFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (UserEditable.name().equals(name())) { return ClassificationCodeType.String; }
            if (VendorFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (Visible.name().equals(name())) { return ClassificationCodeType.String; }
            if (WorkFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (WorkMessageFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (YamatoDelivTz.name().equals(name())) { return ClassificationCodeType.String; }
            if (YupackDelivTz.name().equals(name())) { return ClassificationCodeType.String; }
            if (ZipFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ResultAfterProductTarget.name().equals(name())) { return ClassificationCodeType.String; }
            if (CopyTargetTable.name().equals(name())) { return ClassificationCodeType.String; }
            if (InspectionLabelOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DecimalProductPacking.name().equals(name())) { return ClassificationCodeType.String; }
            if (DecimalExistFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CasePickFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (EmReplenishShapeFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (WorkStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (WorkLogOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (RoleControlClass.name().equals(name())) { return ClassificationCodeType.String; }
            if (BolOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (BolOutputTargetFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PaymentTerm.name().equals(name())) { return ClassificationCodeType.String; }
            if (CesIntegrationFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (FreightCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (SatDeliveryFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ResidentialDeliveryFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CodFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (SignatureRequiredFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (SignatureReleaseFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (FreezableProtectionFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (GuaranteedPlusFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ResidentialPickupFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DoNotStackStackFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LimitedAccessPickupFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (OverSizedFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PoisonFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (FoogFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InsidePickupCollectFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (RcmdPickingCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (SglRowPicTarget.name().equals(name())) { return ClassificationCodeType.String; }
            if (CasePicTarget.name().equals(name())) { return ClassificationCodeType.String; }
            if (AttendanceLeavingRest.name().equals(name())) { return ClassificationCodeType.String; }
            if (UploadZipType.name().equals(name())) { return ClassificationCodeType.String; }
            if (FwType.name().equals(name())) { return ClassificationCodeType.String; }
            if (McaType.name().equals(name())) { return ClassificationCodeType.String; }
            if (AccountFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (AlarmReasonCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (AlarmType.name().equals(name())) { return ClassificationCodeType.String; }
            if (AreaCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (AssortStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (BaseCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (BoxType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CarrierType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CarrierTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (CaseTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (ClosingDt.name().equals(name())) { return ClassificationCodeType.String; }
            if (CompletedHidden.name().equals(name())) { return ClassificationCodeType.String; }
            if (Condition.name().equals(name())) { return ClassificationCodeType.String; }
            if (Constract.name().equals(name())) { return ClassificationCodeType.String; }
            if (CsPsType.name().equals(name())) { return ClassificationCodeType.String; }
            if (DefaultStockType.name().equals(name())) { return ClassificationCodeType.String; }
            if (DelivCenterFrom.name().equals(name())) { return ClassificationCodeType.String; }
            if (DelivCenterTo.name().equals(name())) { return ClassificationCodeType.String; }
            if (DeliveryDtUnspecified.name().equals(name())) { return ClassificationCodeType.String; }
            if (DeliveryTimeZone.name().equals(name())) { return ClassificationCodeType.String; }
            if (DeliveryTypeSendCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (DepositItemFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DepositType.name().equals(name())) { return ClassificationCodeType.String; }
            if (DiffCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (DirectDeliveryTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (EcOrder.name().equals(name())) { return ClassificationCodeType.String; }
            if (EcType.name().equals(name())) { return ClassificationCodeType.String; }
            if (ExecuteStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (Fee.name().equals(name())) { return ClassificationCodeType.String; }
            if (Floor.name().equals(name())) { return ClassificationCodeType.String; }
            if (FloorCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (FloorEndFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (FloorTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (HandOverStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (HandlingType.name().equals(name())) { return ClassificationCodeType.String; }
            if (HeavyItemFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (HeavyItemHadlingFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (HinmokuGroupCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (HolidayFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (IdManagAbolitionTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (InsuranceFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (InventoryDataStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (InventoryDiffCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (InventoryInputCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (InventoryListOutCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (InventoryListType.name().equals(name())) { return ClassificationCodeType.String; }
            if (ItManagType.name().equals(name())) { return ClassificationCodeType.String; }
            if (ItemDensan.name().equals(name())) { return ClassificationCodeType.String; }
            if (LargeItemFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LimitDtSplitTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (LimitDtUnmatchTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (LogiAttentionTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (LogiSpecialTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (LogiWeightFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (LotSplitTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (LotUnmatchTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (MaxStoreShape.name().equals(name())) { return ClassificationCodeType.String; }
            if (MedicalManagFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (MoveDirection.name().equals(name())) { return ClassificationCodeType.String; }
            if (NationalHolidayCarrier.name().equals(name())) { return ClassificationCodeType.String; }
            if (NationalHolidayFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (NizoroeProcessId.name().equals(name())) { return ClassificationCodeType.String; }
            if (NizoroeProcessIdWms.name().equals(name())) { return ClassificationCodeType.String; }
            if (NizoroeTime.name().equals(name())) { return ClassificationCodeType.String; }
            if (NizoroeType.name().equals(name())) { return ClassificationCodeType.String; }
            if (NizoroeTypeWms.name().equals(name())) { return ClassificationCodeType.String; }
            if (NoOkinawaFlightFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (OcrDateFormat.name().equals(name())) { return ClassificationCodeType.String; }
            if (OutputListType.name().equals(name())) { return ClassificationCodeType.String; }
            if (OutputMonth.name().equals(name())) { return ClassificationCodeType.String; }
            if (OutputStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (PaymentTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (PickingPatternCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (Prefecture.name().equals(name())) { return ClassificationCodeType.String; }
            if (PriceDiffHidden.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProdDtManagFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProdDtSplitTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProdDtUnmatchTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProductCategoryConvertCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProductCategoryPlant.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProductCategoryType.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProductStoreStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProductUnitCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReceiveReason.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReceiveReasonConvert.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReceiveReasonDepositReceive.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReceiveStatus01.name().equals(name())) { return ClassificationCodeType.String; }
            if (RecommendLocationTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (RelatedProducts.name().equals(name())) { return ClassificationCodeType.String; }
            if (RemainFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReplenishShape.name().equals(name())) { return ClassificationCodeType.String; }
            if (SampleCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (SearchReferenceDt.name().equals(name())) { return ClassificationCodeType.String; }
            if (SerialManagFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShapeGrpTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (SharedProductTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingInspectionHidden.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingInspectionStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingProcessType.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingProgress.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingReason.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingReasonConvert.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingSlipType.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingType.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingWorkType.name().equals(name())) { return ClassificationCodeType.String; }
            if (SlipType2.name().equals(name())) { return ClassificationCodeType.String; }
            if (SpareTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (SpecifiedNumOfShoes.name().equals(name())) { return ClassificationCodeType.String; }
            if (SplitDeliveryTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockDifference.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockDisplayType.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockExist.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockProcessType.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockRefCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockTakingStatus.name().equals(name())) { return ClassificationCodeType.String; }
            if (StockZeroDisplay.name().equals(name())) { return ClassificationCodeType.String; }
            if (SuppliesVarietyFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (TargetBase.name().equals(name())) { return ClassificationCodeType.String; }
            if (TargetItemCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (TargetKoguchiCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (TargetSalesCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (UnitCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (UrgentShippingTimeZone.name().equals(name())) { return ClassificationCodeType.String; }
            if (WorkType.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReceiveLabelFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReceiveDtUnmatchFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PrintFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ReceiveRemainFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ShippingPickedHidden.name().equals(name())) { return ClassificationCodeType.String; }
            if (CarrierDataOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (PllOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (DepositorCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (RplOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (RecordSendFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (HandOverHidden.name().equals(name())) { return ClassificationCodeType.String; }
            if (ExternalWarehouseFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (StandardPlantCls.name().equals(name())) { return ClassificationCodeType.String; }
            if (LargeItemHadlingFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (HolidayCarrierFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (OkinawaFlightFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (BaseDefaultCarrierFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (SlipTypeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (ProperFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CdlOutFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (ErrorNum.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterPicListCls1.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterPicListCls2.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterPicListCls3.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterSagawaDelivTz.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterTransportTypeItem.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterSlipShapeCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterTransportTypeSpeed.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterSealType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterTagClass.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterTagDataType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterTagType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterTagTypeAfter.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterApiBinsyuCode.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterApiDaibikiFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterApiDaibikiType.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterApiEidomeFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterApiWeightCd.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterOutputTargetFlg.name().equals(name())) { return ClassificationCodeType.String; }
            if (CenterPrintCondition.name().equals(name())) { return ClassificationCodeType.String; }
            return ClassificationCodeType.String; // as default
        }

        public ClassificationUndefinedHandlingType undefinedHandlingType() {
            if (ProcessTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AfterDelivSlipOutTgt.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AfterTagOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AllShippingFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AllcNgDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AllcNgFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AllocSortKey.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ArrivalStoreFormat.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AutoEmgSetFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AutoEmgSetTgt.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AutoPrintTargetFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AutoShipInstFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (BarcodeType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (BatchProgressFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (BoxSelectSkip.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CancelDataDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CasePicFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterClientCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterTransitFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CharacterCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ChargeQty0Display.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CheckDigit.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CodCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CodType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CodeFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CodeType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ColType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CommentFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CompanyFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CoolCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CoolType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CorrectType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DataInputCommitType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DataInputOperationType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DataInputProcessType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DataInputRange.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DataInputType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DataType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Default.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DefaultFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DelFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DeleteDataDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DelivMatchFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DelivTz.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DeliveryFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DepositFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DisplayRequired.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DtCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Editable.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (EmergencyDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (EmergencyFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ErrorFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ErrorProcessMet.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (FixedPoint.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ForceFixedFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ForeignFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (GiftFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (GiftStatementType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (HtCharReadFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ImportFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InfoFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InoutType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InputType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InspectionFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InventoryLocationProduct.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InvoiceCreateFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ItemType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LastFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LimitDtManagFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LimitDtReverseFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LimitMessageCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LineFeedCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ListOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ListOutKbn.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ListOutFlgDisp.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LoadingFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LocationType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Lockout.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LogDtlStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LogDtlType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LogStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LotManagFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LotReverseFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MergeCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MergeFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MessageType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MixedFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MoveInstStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MultiPicCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MultiPicFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Necessary.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NoAllcDisplayFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NoConfirmedFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NoStockCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NoStockOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NoUpsideDownCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NotCompletedFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (OnetimeFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (OverStoreNumFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PackingCalCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PackingProcessCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PackingShowFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PackingStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PasswordReset.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PastStoreDtFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PhysicalDelete.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PicCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PicMthdRcmdBreakKey.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PicMthdRcmdFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PicMthdRcmdListOut.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PickingFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PickingLocationFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PickingStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PickingType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PostType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrintDataType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrintErrorFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrintQueueStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrintResultClass.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrintServiceStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrintStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrintedFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PriorityFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProductLabelJanBarcode.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProductLabelOutUnit.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProductLabelProdBarcode.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProductPartPacking.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProductTypeCode.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Qty0Display.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReasonType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReceiveDeliveryStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReceiveFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReceiveStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReplenishAllocCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReplenishProductCdUnset.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReplenishSearchCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReplenishUnitCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReportLayoutItemType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (RestockType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ResultAfterProductLabel.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReverseValidFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Select.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SelectPrintServiceStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SerialOperationType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TargetWindow.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SettlementType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SglRowInspAfterOutCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SglRowPicFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SheetCollate.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingStopFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShortStockDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShpCheckCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShpCheckDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SlipType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SoundPlayFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockAdjustFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockDisplayFld.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockExistOnlyFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockMoveFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockNum0Display.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockOutAllocCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockOutAutoInstFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockOutInstCxlFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockOutInstSplitFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockQtyDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockTakingInput.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockTarget.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StoreDtFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StoreFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StoreNoDivideDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StoreNoFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StoreNoMergeFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SystemLogStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SystemLogType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SystemType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TagDeliveryOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TakingShippingDtFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TakingShippingFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TextAlign.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TotalPicFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TrackingNumberingUnit.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TransitDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Unmatch.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (UpdCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (UpdType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Updatable.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (UploadTableNm.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (UseHtShipFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (UserEditable.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (VendorFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Visible.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (WorkFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (WorkMessageFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (YamatoDelivTz.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (YupackDelivTz.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ZipFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ResultAfterProductTarget.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CopyTargetTable.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InspectionLabelOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DecimalProductPacking.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DecimalExistFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CasePickFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (EmReplenishShapeFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (WorkStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (WorkLogOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (RoleControlClass.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (BolOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (BolOutputTargetFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PaymentTerm.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CesIntegrationFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PackingSlipAutoOutputFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (FreightCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SatDeliveryFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ResidentialDeliveryFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CodFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SignatureRequiredFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SignatureReleaseFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CallBeforeDeliveryFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (FreezableProtectionFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (GuaranteedPlusFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ResidentialPickupFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DoNotStackStackFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LimitedAccessDeliveryFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LimitedAccessPickupFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (OverSizedFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PoisonFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (FoogFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LiftgateDeliveryPrepaidFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LiftgateDeliveryCollectFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LiftgatePickupPrepaidFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LiftgatePickupCollectFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InsideDeliveryPrepaidFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InsideDeliveryCollectFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InsidePickupPrepaidFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InsidePickupCollectFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (RcmdPickingCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SglRowPicTarget.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CasePicTarget.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AttendanceLeavingRest.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (UploadZipType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (FwType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (McaType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AccountFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AlarmReasonCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AlarmType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AreaCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (AssortStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (BaseCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (BoxType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CarrierType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CarrierTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CaseTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ClosingDt.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CompletedHidden.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Condition.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Constract.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CsPsType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DefaultStockType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DelivCenterFrom.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DelivCenterTo.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DeliveryDtUnspecified.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DeliveryTimeZone.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DeliveryTypeSendCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DepositItemFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DepositType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DiffCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DirectDeliveryTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (EcOrder.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (EcType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ExecuteStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Fee.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Floor.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (FloorCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (FloorEndFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (FloorTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (HandOverStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (HandlingType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (HeavyItemFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (HeavyItemHadlingFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (HinmokuGroupCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (HolidayFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (IdManagAbolitionTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InsuranceFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InventoryDataStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InventoryDiffCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InventoryInputCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InventoryListOutCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (InventoryListType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ItManagType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ItemDensan.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LargeItemFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LimitDtSplitTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LimitDtUnmatchTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LogiAttentionTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LogiSpecialTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LogiWeightFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LotSplitTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LotUnmatchTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MaxStoreShape.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MedicalManagFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (MoveDirection.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NationalHolidayCarrier.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NationalHolidayFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NizoroeProcessId.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NizoroeProcessIdWms.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NizoroeTime.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NizoroeType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NizoroeTypeWms.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (NoOkinawaFlightFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (OcrDateFormat.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (OutputListType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (OutputMonth.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (OutputStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PaymentTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PickingPatternCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (Prefecture.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PriceDiffHidden.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProdDtManagFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProdDtSplitTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProdDtUnmatchTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProductCategoryConvertCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProductCategoryPlant.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProductCategoryType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProductStoreStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProductUnitCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReceiveReason.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReceiveReasonConvert.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReceiveReasonDepositReceive.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReceiveStatus01.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (RecommendLocationTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (RelatedProducts.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (RemainFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReplenishShape.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SampleCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SearchReferenceDt.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SerialManagFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShapeGrpTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SharedProductTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingInspectionHidden.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingInspectionStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingProcessType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingProgress.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingReason.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingReasonConvert.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingSlipType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingWorkType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SlipType2.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SpareTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SpecifiedNumOfShoes.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SplitDeliveryTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockDifference.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockDisplayType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockExist.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockProcessType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockRefCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockTakingStatus.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StockZeroDisplay.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SuppliesVarietyFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TargetBase.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TargetItemCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TargetKoguchiCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (TargetSalesCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (UnitCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (UrgentShippingTimeZone.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (WorkType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReceiveLabelFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReceiveDtUnmatchFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PrintFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ReceiveRemainFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ShippingPickedHidden.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CarrierDataOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (PllOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (DepositorCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (RplOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (RecordSendFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (HandOverHidden.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ExternalWarehouseFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (StandardPlantCls.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (LargeItemHadlingFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (HolidayCarrierFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (OkinawaFlightFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (BaseDefaultCarrierFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (SlipTypeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ProperFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CdlOutFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (ErrorNum.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterPicListCls1.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterPicListCls2.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterPicListCls3.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterSagawaDelivTz.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterTransportTypeItem.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterSlipShapeCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterTransportTypeSpeed.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterSealType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterTagClass.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterTagDataType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterTagType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterTagTypeAfter.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterApiBinsyuCode.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterApiDaibikiFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterApiDaibikiType.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterApiEidomeFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterApiWeightCd.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterOutputTargetFlg.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            if (CenterPrintCondition.name().equals(name())) { return ClassificationUndefinedHandlingType.LOGGING; }
            return ClassificationUndefinedHandlingType.LOGGING; // as default
        }

        public static OptionalThing<CDef.DefMeta> find(String classificationName) { // instead of valueOf()
            if (classificationName == null) { throw new IllegalArgumentException("The argument 'classificationName' should not be null."); }
            if (ProcessTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProcessTypeCd); }
            if (AfterDelivSlipOutTgt.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AfterDelivSlipOutTgt); }
            if (AfterTagOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AfterTagOutFlg); }
            if (AllShippingFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AllShippingFlg); }
            if (AllcNgDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AllcNgDisplay); }
            if (AllcNgFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AllcNgFlg); }
            if (AllocSortKey.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AllocSortKey); }
            if (ArrivalStoreFormat.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ArrivalStoreFormat); }
            if (AutoEmgSetFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AutoEmgSetFlg); }
            if (AutoEmgSetTgt.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AutoEmgSetTgt); }
            if (AutoPrintTargetFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AutoPrintTargetFlg); }
            if (AutoShipInstFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AutoShipInstFlg); }
            if (BarcodeType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.BarcodeType); }
            if (BatchProgressFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.BatchProgressFlg); }
            if (BoxSelectSkip.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.BoxSelectSkip); }
            if (CancelDataDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CancelDataDisplay); }
            if (CasePicFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CasePicFlg); }
            if (CenterClientCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterClientCls); }
            if (CenterTransitFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterTransitFlg); }
            if (CharacterCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CharacterCd); }
            if (ChargeQty0Display.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ChargeQty0Display); }
            if (CheckDigit.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CheckDigit); }
            if (CodCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CodCls); }
            if (CodType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CodType); }
            if (CodeFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CodeFlg); }
            if (CodeType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CodeType); }
            if (ColType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ColType); }
            if (CommentFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CommentFlg); }
            if (CompanyFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CompanyFlg); }
            if (CoolCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CoolCls); }
            if (CoolType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CoolType); }
            if (CorrectType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CorrectType); }
            if (DataInputCommitType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DataInputCommitType); }
            if (DataInputOperationType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DataInputOperationType); }
            if (DataInputProcessType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DataInputProcessType); }
            if (DataInputRange.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DataInputRange); }
            if (DataInputType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DataInputType); }
            if (DataType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DataType); }
            if (Default.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Default); }
            if (DefaultFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DefaultFlg); }
            if (DelFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DelFlg); }
            if (DeleteDataDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DeleteDataDisplay); }
            if (DelivMatchFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DelivMatchFlg); }
            if (DelivTz.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DelivTz); }
            if (DeliveryFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DeliveryFlg); }
            if (DepositFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DepositFlg); }
            if (DisplayRequired.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DisplayRequired); }
            if (DtCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DtCls); }
            if (Editable.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Editable); }
            if (EmergencyDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.EmergencyDisplay); }
            if (EmergencyFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.EmergencyFlg); }
            if (ErrorFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ErrorFlg); }
            if (ErrorProcessMet.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ErrorProcessMet); }
            if (FixedPoint.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.FixedPoint); }
            if (ForceFixedFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ForceFixedFlg); }
            if (ForeignFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ForeignFlg); }
            if (GiftFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.GiftFlg); }
            if (GiftStatementType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.GiftStatementType); }
            if (HtCharReadFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.HtCharReadFlg); }
            if (ImportFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ImportFlg); }
            if (InfoFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InfoFlg); }
            if (InoutType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InoutType); }
            if (InputType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InputType); }
            if (InspectionFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InspectionFlg); }
            if (InventoryLocationProduct.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InventoryLocationProduct); }
            if (InvoiceCreateFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InvoiceCreateFlg); }
            if (ItemType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ItemType); }
            if (LastFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LastFlg); }
            if (LimitDtManagFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LimitDtManagFlg); }
            if (LimitDtReverseFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LimitDtReverseFlg); }
            if (LimitMessageCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LimitMessageCd); }
            if (LineFeedCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LineFeedCd); }
            if (ListOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ListOutFlg); }
            if (ListOutKbn.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ListOutKbn); }
            if (ListOutFlgDisp.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ListOutFlgDisp); }
            if (LoadingFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LoadingFlg); }
            if (LocationType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LocationType); }
            if (Lockout.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Lockout); }
            if (LogDtlStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LogDtlStatus); }
            if (LogDtlType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LogDtlType); }
            if (LogStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LogStatus); }
            if (LotManagFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LotManagFlg); }
            if (LotReverseFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LotReverseFlg); }
            if (MergeCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MergeCls); }
            if (MergeFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MergeFlg); }
            if (MessageType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MessageType); }
            if (MixedFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MixedFlg); }
            if (MoveInstStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MoveInstStatus); }
            if (MultiPicCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MultiPicCls); }
            if (MultiPicFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MultiPicFlg); }
            if (Necessary.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Necessary); }
            if (NoAllcDisplayFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NoAllcDisplayFlg); }
            if (NoConfirmedFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NoConfirmedFlg); }
            if (NoStockCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NoStockCls); }
            if (NoStockOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NoStockOutFlg); }
            if (NoUpsideDownCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NoUpsideDownCls); }
            if (NotCompletedFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NotCompletedFlg); }
            if (OnetimeFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.OnetimeFlg); }
            if (OverStoreNumFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.OverStoreNumFlg); }
            if (PackingCalCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PackingCalCls); }
            if (PackingProcessCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PackingProcessCls); }
            if (PackingShowFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PackingShowFlg); }
            if (PackingStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PackingStatus); }
            if (PasswordReset.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PasswordReset); }
            if (PastStoreDtFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PastStoreDtFlg); }
            if (PhysicalDelete.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PhysicalDelete); }
            if (PicCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PicCls); }
            if (PicMthdRcmdBreakKey.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PicMthdRcmdBreakKey); }
            if (PicMthdRcmdFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PicMthdRcmdFlg); }
            if (PicMthdRcmdListOut.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PicMthdRcmdListOut); }
            if (PickingFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PickingFlg); }
            if (PickingLocationFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PickingLocationFlg); }
            if (PickingStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PickingStatus); }
            if (PickingType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PickingType); }
            if (PostType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PostType); }
            if (PrintDataType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrintDataType); }
            if (PrintErrorFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrintErrorFlg); }
            if (PrintQueueStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrintQueueStatus); }
            if (PrintResultClass.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrintResultClass); }
            if (PrintServiceStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrintServiceStatus); }
            if (PrintStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrintStatus); }
            if (PrintedFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrintedFlg); }
            if (PriorityFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PriorityFlg); }
            if (ProductLabelJanBarcode.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProductLabelJanBarcode); }
            if (ProductLabelOutUnit.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProductLabelOutUnit); }
            if (ProductLabelProdBarcode.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProductLabelProdBarcode); }
            if (ProductPartPacking.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProductPartPacking); }
            if (ProductTypeCode.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProductTypeCode); }
            if (Qty0Display.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Qty0Display); }
            if (ReasonType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReasonType); }
            if (ReceiveDeliveryStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReceiveDeliveryStatus); }
            if (ReceiveFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReceiveFlg); }
            if (ReceiveStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReceiveStatus); }
            if (ReplenishAllocCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReplenishAllocCls); }
            if (ReplenishProductCdUnset.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReplenishProductCdUnset); }
            if (ReplenishSearchCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReplenishSearchCls); }
            if (ReplenishUnitCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReplenishUnitCls); }
            if (ReportLayoutItemType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReportLayoutItemType); }
            if (RestockType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.RestockType); }
            if (ResultAfterProductLabel.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ResultAfterProductLabel); }
            if (ReverseValidFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReverseValidFlg); }
            if (Select.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Select); }
            if (SelectPrintServiceStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SelectPrintServiceStatus); }
            if (SerialOperationType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SerialOperationType); }
            if (TargetWindow.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TargetWindow); }
            if (SettlementType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SettlementType); }
            if (SglRowInspAfterOutCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SglRowInspAfterOutCls); }
            if (SglRowPicFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SglRowPicFlg); }
            if (SheetCollate.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SheetCollate); }
            if (ShippingFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingFlg); }
            if (ShippingStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingStatus); }
            if (ShippingStopFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingStopFlg); }
            if (ShortStockDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShortStockDisplay); }
            if (ShpCheckCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShpCheckCls); }
            if (ShpCheckDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShpCheckDisplay); }
            if (SlipType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SlipType); }
            if (SoundPlayFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SoundPlayFlg); }
            if (StockAdjustFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockAdjustFlg); }
            if (StockDisplayFld.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockDisplayFld); }
            if (StockExistOnlyFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockExistOnlyFlg); }
            if (StockMoveFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockMoveFlg); }
            if (StockNum0Display.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockNum0Display); }
            if (StockOutAllocCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockOutAllocCls); }
            if (StockOutAutoInstFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockOutAutoInstFlg); }
            if (StockOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockOutFlg); }
            if (StockOutInstCxlFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockOutInstCxlFlg); }
            if (StockOutInstSplitFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockOutInstSplitFlg); }
            if (StockQtyDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockQtyDisplay); }
            if (StockTakingInput.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockTakingInput); }
            if (StockTarget.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockTarget); }
            if (StoreDtFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StoreDtFlg); }
            if (StoreFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StoreFlg); }
            if (StoreNoDivideDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StoreNoDivideDisplay); }
            if (StoreNoFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StoreNoFlg); }
            if (StoreNoMergeFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StoreNoMergeFlg); }
            if (SystemLogStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SystemLogStatus); }
            if (SystemLogType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SystemLogType); }
            if (SystemType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SystemType); }
            if (TagDeliveryOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TagDeliveryOutFlg); }
            if (TakingShippingDtFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TakingShippingDtFlg); }
            if (TakingShippingFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TakingShippingFlg); }
            if (TextAlign.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TextAlign); }
            if (TotalPicFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TotalPicFlg); }
            if (TrackingNumberingUnit.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TrackingNumberingUnit); }
            if (TransitDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TransitDisplay); }
            if (Unmatch.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Unmatch); }
            if (UpdCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.UpdCd); }
            if (UpdType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.UpdType); }
            if (Updatable.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Updatable); }
            if (UploadTableNm.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.UploadTableNm); }
            if (UseHtShipFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.UseHtShipFlg); }
            if (UserEditable.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.UserEditable); }
            if (VendorFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.VendorFlg); }
            if (Visible.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Visible); }
            if (WorkFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.WorkFlg); }
            if (WorkMessageFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.WorkMessageFlg); }
            if (YamatoDelivTz.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.YamatoDelivTz); }
            if (YupackDelivTz.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.YupackDelivTz); }
            if (ZipFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ZipFlg); }
            if (ResultAfterProductTarget.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ResultAfterProductTarget); }
            if (CopyTargetTable.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CopyTargetTable); }
            if (InspectionLabelOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InspectionLabelOutFlg); }
            if (DecimalProductPacking.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DecimalProductPacking); }
            if (DecimalExistFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DecimalExistFlg); }
            if (CasePickFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CasePickFlg); }
            if (EmReplenishShapeFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.EmReplenishShapeFlg); }
            if (WorkStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.WorkStatus); }
            if (WorkLogOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.WorkLogOutFlg); }
            if (RoleControlClass.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.RoleControlClass); }
            if (BolOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.BolOutFlg); }
            if (BolOutputTargetFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.BolOutputTargetFlg); }
            if (PaymentTerm.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PaymentTerm); }
            if (CesIntegrationFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CesIntegrationFlg); }
            if (PackingSlipAutoOutputFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PackingSlipAutoOutputFlg); }
            if (FreightCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.FreightCls); }
            if (SatDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SatDeliveryFlg); }
            if (ResidentialDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ResidentialDeliveryFlg); }
            if (CodFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CodFlg); }
            if (SignatureRequiredFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SignatureRequiredFlg); }
            if (SignatureReleaseFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SignatureReleaseFlg); }
            if (CallBeforeDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CallBeforeDeliveryFlg); }
            if (FreezableProtectionFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.FreezableProtectionFlg); }
            if (GuaranteedPlusFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.GuaranteedPlusFlg); }
            if (ResidentialPickupFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ResidentialPickupFlg); }
            if (DoNotStackStackFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DoNotStackStackFlg); }
            if (LimitedAccessDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LimitedAccessDeliveryFlg); }
            if (LimitedAccessPickupFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LimitedAccessPickupFlg); }
            if (OverSizedFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.OverSizedFlg); }
            if (PoisonFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PoisonFlg); }
            if (FoogFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.FoogFlg); }
            if (LiftgateDeliveryPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LiftgateDeliveryPrepaidFlg); }
            if (LiftgateDeliveryCollectFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LiftgateDeliveryCollectFlg); }
            if (LiftgatePickupPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LiftgatePickupPrepaidFlg); }
            if (LiftgatePickupCollectFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LiftgatePickupCollectFlg); }
            if (InsideDeliveryPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InsideDeliveryPrepaidFlg); }
            if (InsideDeliveryCollectFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InsideDeliveryCollectFlg); }
            if (InsidePickupPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InsidePickupPrepaidFlg); }
            if (InsidePickupCollectFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InsidePickupCollectFlg); }
            if (RcmdPickingCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.RcmdPickingCls); }
            if (SglRowPicTarget.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SglRowPicTarget); }
            if (CasePicTarget.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CasePicTarget); }
            if (AttendanceLeavingRest.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AttendanceLeavingRest); }
            if (UploadZipType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.UploadZipType); }
            if (FwType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.FwType); }
            if (McaType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.McaType); }
            if (AccountFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AccountFlg); }
            if (AlarmReasonCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AlarmReasonCls); }
            if (AlarmType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AlarmType); }
            if (AreaCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AreaCls); }
            if (AssortStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.AssortStatus); }
            if (BaseCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.BaseCls); }
            if (BoxType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.BoxType); }
            if (CarrierType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CarrierType); }
            if (CarrierTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CarrierTypeCd); }
            if (CaseTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CaseTypeCd); }
            if (ClosingDt.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ClosingDt); }
            if (CompletedHidden.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CompletedHidden); }
            if (Condition.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Condition); }
            if (Constract.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Constract); }
            if (CsPsType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CsPsType); }
            if (DefaultStockType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DefaultStockType); }
            if (DelivCenterFrom.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DelivCenterFrom); }
            if (DelivCenterTo.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DelivCenterTo); }
            if (DeliveryDtUnspecified.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DeliveryDtUnspecified); }
            if (DeliveryTimeZone.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DeliveryTimeZone); }
            if (DeliveryTypeSendCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DeliveryTypeSendCls); }
            if (DepositItemFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DepositItemFlg); }
            if (DepositType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DepositType); }
            if (DiffCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DiffCls); }
            if (DirectDeliveryTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DirectDeliveryTypeCd); }
            if (EcOrder.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.EcOrder); }
            if (EcType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.EcType); }
            if (ExecuteStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ExecuteStatus); }
            if (Fee.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Fee); }
            if (Floor.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Floor); }
            if (FloorCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.FloorCd); }
            if (FloorEndFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.FloorEndFlg); }
            if (FloorTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.FloorTypeCd); }
            if (HandOverStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.HandOverStatus); }
            if (HandlingType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.HandlingType); }
            if (HeavyItemFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.HeavyItemFlg); }
            if (HeavyItemHadlingFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.HeavyItemHadlingFlg); }
            if (HinmokuGroupCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.HinmokuGroupCd); }
            if (HolidayFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.HolidayFlg); }
            if (IdManagAbolitionTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.IdManagAbolitionTypeCd); }
            if (InsuranceFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InsuranceFlg); }
            if (InventoryDataStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InventoryDataStatus); }
            if (InventoryDiffCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InventoryDiffCls); }
            if (InventoryInputCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InventoryInputCls); }
            if (InventoryListOutCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InventoryListOutCls); }
            if (InventoryListType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.InventoryListType); }
            if (ItManagType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ItManagType); }
            if (ItemDensan.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ItemDensan); }
            if (LargeItemFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LargeItemFlg); }
            if (LimitDtSplitTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LimitDtSplitTypeCd); }
            if (LimitDtUnmatchTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LimitDtUnmatchTypeCd); }
            if (LogiAttentionTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LogiAttentionTypeCd); }
            if (LogiSpecialTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LogiSpecialTypeCd); }
            if (LogiWeightFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LogiWeightFlg); }
            if (LotSplitTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LotSplitTypeCd); }
            if (LotUnmatchTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LotUnmatchTypeCd); }
            if (MaxStoreShape.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MaxStoreShape); }
            if (MedicalManagFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MedicalManagFlg); }
            if (MoveDirection.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.MoveDirection); }
            if (NationalHolidayCarrier.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NationalHolidayCarrier); }
            if (NationalHolidayFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NationalHolidayFlg); }
            if (NizoroeProcessId.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NizoroeProcessId); }
            if (NizoroeProcessIdWms.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NizoroeProcessIdWms); }
            if (NizoroeTime.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NizoroeTime); }
            if (NizoroeType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NizoroeType); }
            if (NizoroeTypeWms.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NizoroeTypeWms); }
            if (NoOkinawaFlightFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.NoOkinawaFlightFlg); }
            if (OcrDateFormat.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.OcrDateFormat); }
            if (OutputListType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.OutputListType); }
            if (OutputMonth.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.OutputMonth); }
            if (OutputStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.OutputStatus); }
            if (PaymentTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PaymentTypeCd); }
            if (PickingPatternCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PickingPatternCd); }
            if (Prefecture.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.Prefecture); }
            if (PriceDiffHidden.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PriceDiffHidden); }
            if (ProdDtManagFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProdDtManagFlg); }
            if (ProdDtSplitTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProdDtSplitTypeCd); }
            if (ProdDtUnmatchTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProdDtUnmatchTypeCd); }
            if (ProductCategoryConvertCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProductCategoryConvertCls); }
            if (ProductCategoryPlant.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProductCategoryPlant); }
            if (ProductCategoryType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProductCategoryType); }
            if (ProductStoreStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProductStoreStatus); }
            if (ProductUnitCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProductUnitCls); }
            if (ReceiveReason.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReceiveReason); }
            if (ReceiveReasonConvert.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReceiveReasonConvert); }
            if (ReceiveReasonDepositReceive.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReceiveReasonDepositReceive); }
            if (ReceiveStatus01.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReceiveStatus01); }
            if (RecommendLocationTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.RecommendLocationTypeCd); }
            if (RelatedProducts.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.RelatedProducts); }
            if (RemainFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.RemainFlg); }
            if (ReplenishShape.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReplenishShape); }
            if (SampleCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SampleCls); }
            if (SearchReferenceDt.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SearchReferenceDt); }
            if (SerialManagFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SerialManagFlg); }
            if (ShapeGrpTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShapeGrpTypeCd); }
            if (SharedProductTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SharedProductTypeCd); }
            if (ShippingInspectionHidden.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingInspectionHidden); }
            if (ShippingInspectionStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingInspectionStatus); }
            if (ShippingProcessType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingProcessType); }
            if (ShippingProgress.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingProgress); }
            if (ShippingReason.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingReason); }
            if (ShippingReasonConvert.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingReasonConvert); }
            if (ShippingSlipType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingSlipType); }
            if (ShippingType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingType); }
            if (ShippingWorkType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingWorkType); }
            if (SlipType2.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SlipType2); }
            if (SpareTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SpareTypeCd); }
            if (SpecifiedNumOfShoes.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SpecifiedNumOfShoes); }
            if (SplitDeliveryTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SplitDeliveryTypeCd); }
            if (StockDifference.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockDifference); }
            if (StockDisplayType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockDisplayType); }
            if (StockExist.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockExist); }
            if (StockProcessType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockProcessType); }
            if (StockRefCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockRefCls); }
            if (StockTakingStatus.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockTakingStatus); }
            if (StockZeroDisplay.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StockZeroDisplay); }
            if (SuppliesVarietyFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SuppliesVarietyFlg); }
            if (TargetBase.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TargetBase); }
            if (TargetItemCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TargetItemCd); }
            if (TargetKoguchiCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TargetKoguchiCd); }
            if (TargetSalesCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.TargetSalesCd); }
            if (UnitCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.UnitCls); }
            if (UrgentShippingTimeZone.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.UrgentShippingTimeZone); }
            if (WorkType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.WorkType); }
            if (ReceiveLabelFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReceiveLabelFlg); }
            if (ReceiveDtUnmatchFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReceiveDtUnmatchFlg); }
            if (PrintFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PrintFlg); }
            if (ReceiveRemainFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ReceiveRemainFlg); }
            if (ShippingPickedHidden.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ShippingPickedHidden); }
            if (CarrierDataOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CarrierDataOutFlg); }
            if (PllOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.PllOutFlg); }
            if (DepositorCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.DepositorCls); }
            if (RplOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.RplOutFlg); }
            if (RecordSendFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.RecordSendFlg); }
            if (HandOverHidden.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.HandOverHidden); }
            if (ExternalWarehouseFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ExternalWarehouseFlg); }
            if (StandardPlantCls.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.StandardPlantCls); }
            if (LargeItemHadlingFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.LargeItemHadlingFlg); }
            if (HolidayCarrierFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.HolidayCarrierFlg); }
            if (OkinawaFlightFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.OkinawaFlightFlg); }
            if (BaseDefaultCarrierFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.BaseDefaultCarrierFlg); }
            if (SlipTypeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.SlipTypeCd); }
            if (ProperFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ProperFlg); }
            if (CdlOutFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CdlOutFlg); }
            if (ErrorNum.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.ErrorNum); }
            if (CenterPicListCls1.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterPicListCls1); }
            if (CenterPicListCls2.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterPicListCls2); }
            if (CenterPicListCls3.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterPicListCls3); }
            if (CenterSagawaDelivTz.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterSagawaDelivTz); }
            if (CenterTransportTypeItem.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterTransportTypeItem); }
            if (CenterSlipShapeCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterSlipShapeCd); }
            if (CenterTransportTypeSpeed.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterTransportTypeSpeed); }
            if (CenterSealType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterSealType); }
            if (CenterTagClass.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterTagClass); }
            if (CenterTagDataType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterTagDataType); }
            if (CenterTagType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterTagType); }
            if (CenterTagTypeAfter.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterTagTypeAfter); }
            if (CenterApiBinsyuCode.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterApiBinsyuCode); }
            if (CenterApiDaibikiFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterApiDaibikiFlg); }
            if (CenterApiDaibikiType.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterApiDaibikiType); }
            if (CenterApiEidomeFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterApiEidomeFlg); }
            if (CenterApiWeightCd.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterApiWeightCd); }
            if (CenterOutputTargetFlg.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterOutputTargetFlg); }
            if (CenterPrintCondition.name().equalsIgnoreCase(classificationName)) { return OptionalThing.of(CDef.DefMeta.CenterPrintCondition); }
            return OptionalThing.ofNullable(null, () -> {
                throw new ClassificationNotFoundException("Unknown classification: " + classificationName);
            });
        }

        public static CDef.DefMeta meta(String classificationName) { // old style so use find(name)
            if (classificationName == null) { throw new IllegalArgumentException("The argument 'classificationName' should not be null."); }
            if (ProcessTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProcessTypeCd; }
            if (AfterDelivSlipOutTgt.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AfterDelivSlipOutTgt; }
            if (AfterTagOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AfterTagOutFlg; }
            if (AllShippingFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AllShippingFlg; }
            if (AllcNgDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AllcNgDisplay; }
            if (AllcNgFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AllcNgFlg; }
            if (AllocSortKey.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AllocSortKey; }
            if (ArrivalStoreFormat.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ArrivalStoreFormat; }
            if (AutoEmgSetFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AutoEmgSetFlg; }
            if (AutoEmgSetTgt.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AutoEmgSetTgt; }
            if (AutoPrintTargetFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AutoPrintTargetFlg; }
            if (AutoShipInstFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AutoShipInstFlg; }
            if (BarcodeType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.BarcodeType; }
            if (BatchProgressFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.BatchProgressFlg; }
            if (BoxSelectSkip.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.BoxSelectSkip; }
            if (CancelDataDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CancelDataDisplay; }
            if (CasePicFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CasePicFlg; }
            if (CenterClientCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterClientCls; }
            if (CenterTransitFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterTransitFlg; }
            if (CharacterCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CharacterCd; }
            if (ChargeQty0Display.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ChargeQty0Display; }
            if (CheckDigit.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CheckDigit; }
            if (CodCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CodCls; }
            if (CodType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CodType; }
            if (CodeFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CodeFlg; }
            if (CodeType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CodeType; }
            if (ColType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ColType; }
            if (CommentFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CommentFlg; }
            if (CompanyFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CompanyFlg; }
            if (CoolCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CoolCls; }
            if (CoolType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CoolType; }
            if (CorrectType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CorrectType; }
            if (DataInputCommitType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DataInputCommitType; }
            if (DataInputOperationType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DataInputOperationType; }
            if (DataInputProcessType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DataInputProcessType; }
            if (DataInputRange.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DataInputRange; }
            if (DataInputType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DataInputType; }
            if (DataType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DataType; }
            if (Default.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Default; }
            if (DefaultFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DefaultFlg; }
            if (DelFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DelFlg; }
            if (DeleteDataDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DeleteDataDisplay; }
            if (DelivMatchFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DelivMatchFlg; }
            if (DelivTz.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DelivTz; }
            if (DeliveryFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DeliveryFlg; }
            if (DepositFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DepositFlg; }
            if (DisplayRequired.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DisplayRequired; }
            if (DtCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DtCls; }
            if (Editable.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Editable; }
            if (EmergencyDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.EmergencyDisplay; }
            if (EmergencyFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.EmergencyFlg; }
            if (ErrorFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ErrorFlg; }
            if (ErrorProcessMet.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ErrorProcessMet; }
            if (FixedPoint.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.FixedPoint; }
            if (ForceFixedFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ForceFixedFlg; }
            if (ForeignFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ForeignFlg; }
            if (GiftFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.GiftFlg; }
            if (GiftStatementType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.GiftStatementType; }
            if (HtCharReadFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.HtCharReadFlg; }
            if (ImportFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ImportFlg; }
            if (InfoFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InfoFlg; }
            if (InoutType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InoutType; }
            if (InputType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InputType; }
            if (InspectionFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InspectionFlg; }
            if (InventoryLocationProduct.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InventoryLocationProduct; }
            if (InvoiceCreateFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InvoiceCreateFlg; }
            if (ItemType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ItemType; }
            if (LastFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LastFlg; }
            if (LimitDtManagFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LimitDtManagFlg; }
            if (LimitDtReverseFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LimitDtReverseFlg; }
            if (LimitMessageCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LimitMessageCd; }
            if (LineFeedCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LineFeedCd; }
            if (ListOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ListOutFlg; }
            if (ListOutKbn.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ListOutKbn; }
            if (ListOutFlgDisp.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ListOutFlgDisp; }
            if (LoadingFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LoadingFlg; }
            if (LocationType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LocationType; }
            if (Lockout.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Lockout; }
            if (LogDtlStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LogDtlStatus; }
            if (LogDtlType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LogDtlType; }
            if (LogStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LogStatus; }
            if (LotManagFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LotManagFlg; }
            if (LotReverseFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LotReverseFlg; }
            if (MergeCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MergeCls; }
            if (MergeFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MergeFlg; }
            if (MessageType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MessageType; }
            if (MixedFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MixedFlg; }
            if (MoveInstStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MoveInstStatus; }
            if (MultiPicCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MultiPicCls; }
            if (MultiPicFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MultiPicFlg; }
            if (Necessary.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Necessary; }
            if (NoAllcDisplayFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NoAllcDisplayFlg; }
            if (NoConfirmedFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NoConfirmedFlg; }
            if (NoStockCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NoStockCls; }
            if (NoStockOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NoStockOutFlg; }
            if (NoUpsideDownCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NoUpsideDownCls; }
            if (NotCompletedFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NotCompletedFlg; }
            if (OnetimeFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.OnetimeFlg; }
            if (OverStoreNumFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.OverStoreNumFlg; }
            if (PackingCalCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PackingCalCls; }
            if (PackingProcessCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PackingProcessCls; }
            if (PackingShowFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PackingShowFlg; }
            if (PackingStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PackingStatus; }
            if (PasswordReset.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PasswordReset; }
            if (PastStoreDtFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PastStoreDtFlg; }
            if (PhysicalDelete.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PhysicalDelete; }
            if (PicCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PicCls; }
            if (PicMthdRcmdBreakKey.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PicMthdRcmdBreakKey; }
            if (PicMthdRcmdFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PicMthdRcmdFlg; }
            if (PicMthdRcmdListOut.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PicMthdRcmdListOut; }
            if (PickingFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PickingFlg; }
            if (PickingLocationFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PickingLocationFlg; }
            if (PickingStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PickingStatus; }
            if (PickingType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PickingType; }
            if (PostType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PostType; }
            if (PrintDataType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrintDataType; }
            if (PrintErrorFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrintErrorFlg; }
            if (PrintQueueStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrintQueueStatus; }
            if (PrintResultClass.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrintResultClass; }
            if (PrintServiceStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrintServiceStatus; }
            if (PrintStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrintStatus; }
            if (PrintedFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrintedFlg; }
            if (PriorityFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PriorityFlg; }
            if (ProductLabelJanBarcode.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProductLabelJanBarcode; }
            if (ProductLabelOutUnit.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProductLabelOutUnit; }
            if (ProductLabelProdBarcode.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProductLabelProdBarcode; }
            if (ProductPartPacking.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProductPartPacking; }
            if (ProductTypeCode.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProductTypeCode; }
            if (Qty0Display.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Qty0Display; }
            if (ReasonType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReasonType; }
            if (ReceiveDeliveryStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReceiveDeliveryStatus; }
            if (ReceiveFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReceiveFlg; }
            if (ReceiveStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReceiveStatus; }
            if (ReplenishAllocCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReplenishAllocCls; }
            if (ReplenishProductCdUnset.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReplenishProductCdUnset; }
            if (ReplenishSearchCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReplenishSearchCls; }
            if (ReplenishUnitCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReplenishUnitCls; }
            if (ReportLayoutItemType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReportLayoutItemType; }
            if (RestockType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.RestockType; }
            if (ResultAfterProductLabel.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ResultAfterProductLabel; }
            if (ReverseValidFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReverseValidFlg; }
            if (Select.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Select; }
            if (SelectPrintServiceStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SelectPrintServiceStatus; }
            if (SerialOperationType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SerialOperationType; }
            if (TargetWindow.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TargetWindow; }
            if (SettlementType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SettlementType; }
            if (SglRowInspAfterOutCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SglRowInspAfterOutCls; }
            if (SglRowPicFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SglRowPicFlg; }
            if (SheetCollate.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SheetCollate; }
            if (ShippingFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingFlg; }
            if (ShippingStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingStatus; }
            if (ShippingStopFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingStopFlg; }
            if (ShortStockDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShortStockDisplay; }
            if (ShpCheckCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShpCheckCls; }
            if (ShpCheckDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShpCheckDisplay; }
            if (SlipType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SlipType; }
            if (SoundPlayFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SoundPlayFlg; }
            if (StockAdjustFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockAdjustFlg; }
            if (StockDisplayFld.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockDisplayFld; }
            if (StockExistOnlyFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockExistOnlyFlg; }
            if (StockMoveFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockMoveFlg; }
            if (StockNum0Display.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockNum0Display; }
            if (StockOutAllocCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockOutAllocCls; }
            if (StockOutAutoInstFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockOutAutoInstFlg; }
            if (StockOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockOutFlg; }
            if (StockOutInstCxlFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockOutInstCxlFlg; }
            if (StockOutInstSplitFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockOutInstSplitFlg; }
            if (StockQtyDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockQtyDisplay; }
            if (StockTakingInput.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockTakingInput; }
            if (StockTarget.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockTarget; }
            if (StoreDtFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StoreDtFlg; }
            if (StoreFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StoreFlg; }
            if (StoreNoDivideDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StoreNoDivideDisplay; }
            if (StoreNoFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StoreNoFlg; }
            if (StoreNoMergeFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StoreNoMergeFlg; }
            if (SystemLogStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SystemLogStatus; }
            if (SystemLogType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SystemLogType; }
            if (SystemType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SystemType; }
            if (TagDeliveryOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TagDeliveryOutFlg; }
            if (TakingShippingDtFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TakingShippingDtFlg; }
            if (TakingShippingFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TakingShippingFlg; }
            if (TextAlign.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TextAlign; }
            if (TotalPicFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TotalPicFlg; }
            if (TrackingNumberingUnit.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TrackingNumberingUnit; }
            if (TransitDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TransitDisplay; }
            if (Unmatch.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Unmatch; }
            if (UpdCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.UpdCd; }
            if (UpdType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.UpdType; }
            if (Updatable.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Updatable; }
            if (UploadTableNm.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.UploadTableNm; }
            if (UseHtShipFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.UseHtShipFlg; }
            if (UserEditable.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.UserEditable; }
            if (VendorFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.VendorFlg; }
            if (Visible.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Visible; }
            if (WorkFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.WorkFlg; }
            if (WorkMessageFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.WorkMessageFlg; }
            if (YamatoDelivTz.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.YamatoDelivTz; }
            if (YupackDelivTz.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.YupackDelivTz; }
            if (ZipFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ZipFlg; }
            if (ResultAfterProductTarget.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ResultAfterProductTarget; }
            if (CopyTargetTable.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CopyTargetTable; }
            if (InspectionLabelOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InspectionLabelOutFlg; }
            if (DecimalProductPacking.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DecimalProductPacking; }
            if (DecimalExistFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DecimalExistFlg; }
            if (CasePickFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CasePickFlg; }
            if (EmReplenishShapeFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.EmReplenishShapeFlg; }
            if (WorkStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.WorkStatus; }
            if (WorkLogOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.WorkLogOutFlg; }
            if (RoleControlClass.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.RoleControlClass; }
            if (BolOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.BolOutFlg; }
            if (BolOutputTargetFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.BolOutputTargetFlg; }
            if (PaymentTerm.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PaymentTerm; }
            if (CesIntegrationFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CesIntegrationFlg; }
            if (PackingSlipAutoOutputFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PackingSlipAutoOutputFlg; }
            if (FreightCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.FreightCls; }
            if (SatDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SatDeliveryFlg; }
            if (ResidentialDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ResidentialDeliveryFlg; }
            if (CodFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CodFlg; }
            if (SignatureRequiredFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SignatureRequiredFlg; }
            if (SignatureReleaseFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SignatureReleaseFlg; }
            if (CallBeforeDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CallBeforeDeliveryFlg; }
            if (FreezableProtectionFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.FreezableProtectionFlg; }
            if (GuaranteedPlusFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.GuaranteedPlusFlg; }
            if (ResidentialPickupFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ResidentialPickupFlg; }
            if (DoNotStackStackFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DoNotStackStackFlg; }
            if (LimitedAccessDeliveryFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LimitedAccessDeliveryFlg; }
            if (LimitedAccessPickupFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LimitedAccessPickupFlg; }
            if (OverSizedFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.OverSizedFlg; }
            if (PoisonFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PoisonFlg; }
            if (FoogFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.FoogFlg; }
            if (LiftgateDeliveryPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LiftgateDeliveryPrepaidFlg; }
            if (LiftgateDeliveryCollectFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LiftgateDeliveryCollectFlg; }
            if (LiftgatePickupPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LiftgatePickupPrepaidFlg; }
            if (LiftgatePickupCollectFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LiftgatePickupCollectFlg; }
            if (InsideDeliveryPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InsideDeliveryPrepaidFlg; }
            if (InsideDeliveryCollectFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InsideDeliveryCollectFlg; }
            if (InsidePickupPrepaidFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InsidePickupPrepaidFlg; }
            if (InsidePickupCollectFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InsidePickupCollectFlg; }
            if (RcmdPickingCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.RcmdPickingCls; }
            if (SglRowPicTarget.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SglRowPicTarget; }
            if (CasePicTarget.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CasePicTarget; }
            if (AttendanceLeavingRest.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AttendanceLeavingRest; }
            if (UploadZipType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.UploadZipType; }
            if (FwType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.FwType; }
            if (McaType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.McaType; }
            if (AccountFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AccountFlg; }
            if (AlarmReasonCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AlarmReasonCls; }
            if (AlarmType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AlarmType; }
            if (AreaCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AreaCls; }
            if (AssortStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.AssortStatus; }
            if (BaseCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.BaseCls; }
            if (BoxType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.BoxType; }
            if (CarrierType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CarrierType; }
            if (CarrierTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CarrierTypeCd; }
            if (CaseTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CaseTypeCd; }
            if (ClosingDt.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ClosingDt; }
            if (CompletedHidden.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CompletedHidden; }
            if (Condition.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Condition; }
            if (Constract.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Constract; }
            if (CsPsType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CsPsType; }
            if (DefaultStockType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DefaultStockType; }
            if (DelivCenterFrom.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DelivCenterFrom; }
            if (DelivCenterTo.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DelivCenterTo; }
            if (DeliveryDtUnspecified.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DeliveryDtUnspecified; }
            if (DeliveryTimeZone.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DeliveryTimeZone; }
            if (DeliveryTypeSendCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DeliveryTypeSendCls; }
            if (DepositItemFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DepositItemFlg; }
            if (DepositType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DepositType; }
            if (DiffCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DiffCls; }
            if (DirectDeliveryTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DirectDeliveryTypeCd; }
            if (EcOrder.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.EcOrder; }
            if (EcType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.EcType; }
            if (ExecuteStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ExecuteStatus; }
            if (Fee.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Fee; }
            if (Floor.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Floor; }
            if (FloorCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.FloorCd; }
            if (FloorEndFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.FloorEndFlg; }
            if (FloorTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.FloorTypeCd; }
            if (HandOverStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.HandOverStatus; }
            if (HandlingType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.HandlingType; }
            if (HeavyItemFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.HeavyItemFlg; }
            if (HeavyItemHadlingFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.HeavyItemHadlingFlg; }
            if (HinmokuGroupCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.HinmokuGroupCd; }
            if (HolidayFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.HolidayFlg; }
            if (IdManagAbolitionTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.IdManagAbolitionTypeCd; }
            if (InsuranceFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InsuranceFlg; }
            if (InventoryDataStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InventoryDataStatus; }
            if (InventoryDiffCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InventoryDiffCls; }
            if (InventoryInputCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InventoryInputCls; }
            if (InventoryListOutCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InventoryListOutCls; }
            if (InventoryListType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.InventoryListType; }
            if (ItManagType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ItManagType; }
            if (ItemDensan.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ItemDensan; }
            if (LargeItemFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LargeItemFlg; }
            if (LimitDtSplitTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LimitDtSplitTypeCd; }
            if (LimitDtUnmatchTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LimitDtUnmatchTypeCd; }
            if (LogiAttentionTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LogiAttentionTypeCd; }
            if (LogiSpecialTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LogiSpecialTypeCd; }
            if (LogiWeightFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LogiWeightFlg; }
            if (LotSplitTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LotSplitTypeCd; }
            if (LotUnmatchTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LotUnmatchTypeCd; }
            if (MaxStoreShape.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MaxStoreShape; }
            if (MedicalManagFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MedicalManagFlg; }
            if (MoveDirection.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.MoveDirection; }
            if (NationalHolidayCarrier.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NationalHolidayCarrier; }
            if (NationalHolidayFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NationalHolidayFlg; }
            if (NizoroeProcessId.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NizoroeProcessId; }
            if (NizoroeProcessIdWms.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NizoroeProcessIdWms; }
            if (NizoroeTime.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NizoroeTime; }
            if (NizoroeType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NizoroeType; }
            if (NizoroeTypeWms.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NizoroeTypeWms; }
            if (NoOkinawaFlightFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.NoOkinawaFlightFlg; }
            if (OcrDateFormat.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.OcrDateFormat; }
            if (OutputListType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.OutputListType; }
            if (OutputMonth.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.OutputMonth; }
            if (OutputStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.OutputStatus; }
            if (PaymentTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PaymentTypeCd; }
            if (PickingPatternCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PickingPatternCd; }
            if (Prefecture.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.Prefecture; }
            if (PriceDiffHidden.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PriceDiffHidden; }
            if (ProdDtManagFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProdDtManagFlg; }
            if (ProdDtSplitTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProdDtSplitTypeCd; }
            if (ProdDtUnmatchTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProdDtUnmatchTypeCd; }
            if (ProductCategoryConvertCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProductCategoryConvertCls; }
            if (ProductCategoryPlant.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProductCategoryPlant; }
            if (ProductCategoryType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProductCategoryType; }
            if (ProductStoreStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProductStoreStatus; }
            if (ProductUnitCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProductUnitCls; }
            if (ReceiveReason.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReceiveReason; }
            if (ReceiveReasonConvert.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReceiveReasonConvert; }
            if (ReceiveReasonDepositReceive.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReceiveReasonDepositReceive; }
            if (ReceiveStatus01.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReceiveStatus01; }
            if (RecommendLocationTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.RecommendLocationTypeCd; }
            if (RelatedProducts.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.RelatedProducts; }
            if (RemainFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.RemainFlg; }
            if (ReplenishShape.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReplenishShape; }
            if (SampleCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SampleCls; }
            if (SearchReferenceDt.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SearchReferenceDt; }
            if (SerialManagFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SerialManagFlg; }
            if (ShapeGrpTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShapeGrpTypeCd; }
            if (SharedProductTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SharedProductTypeCd; }
            if (ShippingInspectionHidden.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingInspectionHidden; }
            if (ShippingInspectionStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingInspectionStatus; }
            if (ShippingProcessType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingProcessType; }
            if (ShippingProgress.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingProgress; }
            if (ShippingReason.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingReason; }
            if (ShippingReasonConvert.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingReasonConvert; }
            if (ShippingSlipType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingSlipType; }
            if (ShippingType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingType; }
            if (ShippingWorkType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingWorkType; }
            if (SlipType2.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SlipType2; }
            if (SpareTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SpareTypeCd; }
            if (SpecifiedNumOfShoes.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SpecifiedNumOfShoes; }
            if (SplitDeliveryTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SplitDeliveryTypeCd; }
            if (StockDifference.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockDifference; }
            if (StockDisplayType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockDisplayType; }
            if (StockExist.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockExist; }
            if (StockProcessType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockProcessType; }
            if (StockRefCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockRefCls; }
            if (StockTakingStatus.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockTakingStatus; }
            if (StockZeroDisplay.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StockZeroDisplay; }
            if (SuppliesVarietyFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SuppliesVarietyFlg; }
            if (TargetBase.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TargetBase; }
            if (TargetItemCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TargetItemCd; }
            if (TargetKoguchiCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TargetKoguchiCd; }
            if (TargetSalesCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.TargetSalesCd; }
            if (UnitCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.UnitCls; }
            if (UrgentShippingTimeZone.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.UrgentShippingTimeZone; }
            if (WorkType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.WorkType; }
            if (ReceiveLabelFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReceiveLabelFlg; }
            if (ReceiveDtUnmatchFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReceiveDtUnmatchFlg; }
            if (PrintFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PrintFlg; }
            if (ReceiveRemainFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ReceiveRemainFlg; }
            if (ShippingPickedHidden.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ShippingPickedHidden; }
            if (CarrierDataOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CarrierDataOutFlg; }
            if (PllOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.PllOutFlg; }
            if (DepositorCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.DepositorCls; }
            if (RplOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.RplOutFlg; }
            if (RecordSendFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.RecordSendFlg; }
            if (HandOverHidden.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.HandOverHidden; }
            if (ExternalWarehouseFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ExternalWarehouseFlg; }
            if (StandardPlantCls.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.StandardPlantCls; }
            if (LargeItemHadlingFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.LargeItemHadlingFlg; }
            if (HolidayCarrierFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.HolidayCarrierFlg; }
            if (OkinawaFlightFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.OkinawaFlightFlg; }
            if (BaseDefaultCarrierFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.BaseDefaultCarrierFlg; }
            if (SlipTypeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.SlipTypeCd; }
            if (ProperFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ProperFlg; }
            if (CdlOutFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CdlOutFlg; }
            if (ErrorNum.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.ErrorNum; }
            if (CenterPicListCls1.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterPicListCls1; }
            if (CenterPicListCls2.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterPicListCls2; }
            if (CenterPicListCls3.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterPicListCls3; }
            if (CenterSagawaDelivTz.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterSagawaDelivTz; }
            if (CenterTransportTypeItem.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterTransportTypeItem; }
            if (CenterSlipShapeCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterSlipShapeCd; }
            if (CenterTransportTypeSpeed.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterTransportTypeSpeed; }
            if (CenterSealType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterSealType; }
            if (CenterTagClass.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterTagClass; }
            if (CenterTagDataType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterTagDataType; }
            if (CenterTagType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterTagType; }
            if (CenterTagTypeAfter.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterTagTypeAfter; }
            if (CenterApiBinsyuCode.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterApiBinsyuCode; }
            if (CenterApiDaibikiFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterApiDaibikiFlg; }
            if (CenterApiDaibikiType.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterApiDaibikiType; }
            if (CenterApiEidomeFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterApiEidomeFlg; }
            if (CenterApiWeightCd.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterApiWeightCd; }
            if (CenterOutputTargetFlg.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterOutputTargetFlg; }
            if (CenterPrintCondition.name().equalsIgnoreCase(classificationName)) { return CDef.DefMeta.CenterPrintCondition; }
            throw new IllegalStateException("Unknown classification: " + classificationName);
        }

        @SuppressWarnings("unused")
        private String[] xinternalEmptyString() {
            return emptyStrings(); // to suppress 'unused' warning of import statement
        }
    }
}
